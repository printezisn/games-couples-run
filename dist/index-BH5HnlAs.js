var pv = Object.defineProperty;
var fv = (n, t, e) => t in n ? pv(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var vt = (n, t, e) => fv(n, typeof t != "symbol" ? t + "" : t, e);
var mv = Object.defineProperty, gv = (n, t, e) => t in n ? mv(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e, Ee = (n, t, e) => gv(n, typeof t != "symbol" ? t + "" : t, e);
const W = {
  gameName: "",
  gameContainer: document.body,
  maxFPS: 60,
  debug: !1,
  assets: {
    basePath: "/assets",
    manifest: {},
    extra: []
  },
  colors: {
    backgroundColor: "#000000"
  },
  screen: {
    width: 1280,
    aspectRatio: 1.7777777777777777
  },
  tickIntervalMillis: 16,
  loadingScene: {
    fontFamily: "Arial, sans-serif",
    fontSize: 28,
    textColor: 16777215,
    keepAliveTimeMS: 2e3,
    text: "Loading..."
  },
  pauseScene: {
    overlayColor: 0,
    overlayAlpha: 0.8,
    fontFamily: "Arial, sans-serif",
    titleFontSize: 48,
    subTitleFontSize: 28,
    textColor: 16777215,
    title: "Paused",
    subTitle: "Click/tap to continue"
  },
  signals: {
    onResize: "onResize",
    onOrientationChange: "onOrientationChange",
    onTick: "onTick",
    destroyLoadingScene: "destroyLoadingScene"
  },
  sounds: {
    click: "click"
  }
}, st = {
  screen: {
    orientation: "landscape",
    width: 0,
    height: 0
  },
  scene: null,
  muted: localStorage.getItem("muted") === "true"
};
var K = /* @__PURE__ */ ((n) => (n.Application = "application", n.WebGLPipes = "webgl-pipes", n.WebGLPipesAdaptor = "webgl-pipes-adaptor", n.WebGLSystem = "webgl-system", n.WebGPUPipes = "webgpu-pipes", n.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", n.WebGPUSystem = "webgpu-system", n.CanvasSystem = "canvas-system", n.CanvasPipesAdaptor = "canvas-pipes-adaptor", n.CanvasPipes = "canvas-pipes", n.Asset = "asset", n.LoadParser = "load-parser", n.ResolveParser = "resolve-parser", n.CacheParser = "cache-parser", n.DetectionParser = "detection-parser", n.MaskEffect = "mask-effect", n.BlendMode = "blend-mode", n.TextureSource = "texture-source", n.Environment = "environment", n.ShapeBuilder = "shape-builder", n.Batcher = "batcher", n))(K || {});
const Mh = (n) => {
  if (typeof n == "function" || typeof n == "object" && n.extension) {
    if (!n.extension)
      throw new Error("Extension class must have an extension object");
    n = { ...typeof n.extension != "object" ? { type: n.extension } : n.extension, ref: n };
  }
  if (typeof n == "object")
    n = { ...n };
  else
    throw new Error("Invalid extension type");
  return typeof n.type == "string" && (n.type = [n.type]), n;
}, No = (n, t) => Mh(n).priority ?? t, xe = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {extensions} For chaining.
   */
  remove(...n) {
    return n.map(Mh).forEach((t) => {
      t.type.forEach((e) => {
        var i, r;
        return (r = (i = this._removeHandlers)[e]) == null ? void 0 : r.call(i, t);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {extensions} For chaining.
   */
  add(...n) {
    return n.map(Mh).forEach((t) => {
      t.type.forEach((e) => {
        var i, r;
        const s = this._addHandlers, o = this._queue;
        s[e] ? (r = s[e]) == null || r.call(s, t) : (o[e] = o[e] || [], (i = o[e]) == null || i.push(t));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns {extensions} For chaining.
   */
  handle(n, t, e) {
    var i;
    const r = this._addHandlers, s = this._removeHandlers;
    if (r[n] || s[n])
      throw new Error(`Extension type ${n} already has a handler`);
    r[n] = t, s[n] = e;
    const o = this._queue;
    return o[n] && ((i = o[n]) == null || i.forEach((a) => t(a)), delete o[n]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {extensions} For chaining.
   */
  handleByMap(n, t) {
    return this.handle(
      n,
      (e) => {
        e.name && (t[e.name] = e.ref);
      },
      (e) => {
        e.name && delete t[e.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns {extensions} For chaining.
   */
  handleByNamedList(n, t, e = -1) {
    return this.handle(
      n,
      (i) => {
        t.findIndex((r) => r.name === i.name) >= 0 || (t.push({ name: i.name, value: i.ref }), t.sort((r, s) => No(s.value, e) - No(r.value, e)));
      },
      (i) => {
        const r = t.findIndex((s) => s.name === i.name);
        r !== -1 && t.splice(r, 1);
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {extensions} For chaining.
   */
  handleByList(n, t, e = -1) {
    return this.handle(
      n,
      (i) => {
        t.includes(i.ref) || (t.push(i.ref), t.sort((r, s) => No(s, e) - No(r, e)));
      },
      (i) => {
        const r = t.indexOf(i.ref);
        r !== -1 && t.splice(r, 1);
      }
    );
  }
}, yv = {
  extension: {
    type: K.Environment,
    name: "browser",
    priority: -1
  },
  test: () => !0,
  load: async () => {
    await import("./browserAll-BpoGT0PN-CQH6wEOV.js");
  }
}, _v = {
  extension: {
    type: K.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await import("./webworkerAll-DQbc7pxG-BKs0TjQA.js");
  }
};
class Kt {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t, e, i) {
    this._x = e || 0, this._y = i || 0, this._observer = t;
  }
  /**
   * Creates a clone of this point.
   * @param observer - Optional observer to pass to the new observable point.
   * @returns a copy of this observable point
   */
  clone(t) {
    return new Kt(t ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(t = 0, e = t) {
    return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `PointData`
   * @returns The observable point instance itself
   */
  copyFrom(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this._x, this._y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this._x && t.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(t) {
    this._x !== t && (this._x = t, this._observer._onUpdate(this));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(t) {
    this._y !== t && (this._y = t, this._observer._onUpdate(this));
  }
}
var ki = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var wm = { exports: {} };
(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (e = !1));
  function r(l, h, c) {
    this.fn = l, this.context = h, this.once = c || !1;
  }
  function s(l, h, c, p, f) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var u = new r(c, p || l, f), m = e ? e + h : h;
    return l._events[m] ? l._events[m].fn ? l._events[m] = [l._events[m], u] : l._events[m].push(u) : (l._events[m] = u, l._eventsCount++), l;
  }
  function o(l, h) {
    --l._eventsCount === 0 ? l._events = new i() : delete l._events[h];
  }
  function a() {
    this._events = new i(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], h, c;
    if (this._eventsCount === 0) return l;
    for (c in h = this._events)
      t.call(h, c) && l.push(e ? c.slice(1) : c);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, a.prototype.listeners = function(l) {
    var h = e ? e + l : l, c = this._events[h];
    if (!c) return [];
    if (c.fn) return [c.fn];
    for (var p = 0, f = c.length, u = new Array(f); p < f; p++)
      u[p] = c[p].fn;
    return u;
  }, a.prototype.listenerCount = function(l) {
    var h = e ? e + l : l, c = this._events[h];
    return c ? c.fn ? 1 : c.length : 0;
  }, a.prototype.emit = function(l, h, c, p, f, u) {
    var m = e ? e + l : l;
    if (!this._events[m]) return !1;
    var g = this._events[m], y = arguments.length, b, T;
    if (g.fn) {
      switch (g.once && this.removeListener(l, g.fn, void 0, !0), y) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, h), !0;
        case 3:
          return g.fn.call(g.context, h, c), !0;
        case 4:
          return g.fn.call(g.context, h, c, p), !0;
        case 5:
          return g.fn.call(g.context, h, c, p, f), !0;
        case 6:
          return g.fn.call(g.context, h, c, p, f, u), !0;
      }
      for (T = 1, b = new Array(y - 1); T < y; T++)
        b[T - 1] = arguments[T];
      g.fn.apply(g.context, b);
    } else {
      var C = g.length, P;
      for (T = 0; T < C; T++)
        switch (g[T].once && this.removeListener(l, g[T].fn, void 0, !0), y) {
          case 1:
            g[T].fn.call(g[T].context);
            break;
          case 2:
            g[T].fn.call(g[T].context, h);
            break;
          case 3:
            g[T].fn.call(g[T].context, h, c);
            break;
          case 4:
            g[T].fn.call(g[T].context, h, c, p);
            break;
          default:
            if (!b) for (P = 1, b = new Array(y - 1); P < y; P++)
              b[P - 1] = arguments[P];
            g[T].fn.apply(g[T].context, b);
        }
    }
    return !0;
  }, a.prototype.on = function(l, h, c) {
    return s(this, l, h, c, !1);
  }, a.prototype.once = function(l, h, c) {
    return s(this, l, h, c, !0);
  }, a.prototype.removeListener = function(l, h, c, p) {
    var f = e ? e + l : l;
    if (!this._events[f]) return this;
    if (!h)
      return o(this, f), this;
    var u = this._events[f];
    if (u.fn)
      u.fn === h && (!p || u.once) && (!c || u.context === c) && o(this, f);
    else {
      for (var m = 0, g = [], y = u.length; m < y; m++)
        (u[m].fn !== h || p && !u[m].once || c && u[m].context !== c) && g.push(u[m]);
      g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = e ? e + l : l, this._events[h] && o(this, h)) : (this._events = new i(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, n.exports = a;
})(wm);
var vv = wm.exports;
const Ae = /* @__PURE__ */ zc(vv), xv = Math.PI * 2, bv = 180 / Math.PI, wv = Math.PI / 180;
class ve {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t = 0, e = 0) {
    this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new ve(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(t) {
    return this.set(t.x, t.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this.x, this.y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(t = 0, e = t) {
    return this.x = t, this.y = e, this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
   * @readonly
   */
  static get shared() {
    return Nl.x = 0, Nl.y = 0, Nl;
  }
}
const Nl = new ve();
class ft {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(t = 1, e = 0, i = 0, r = 1, s = 0, o = 0) {
    this.array = null, this.a = t, this.b = e, this.c = i, this.d = r, this.tx = s, this.ty = o;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(t, e, i, r, s, o) {
    return this.a = t, this.b = e, this.c = i, this.d = r, this.tx = s, this.ty = o, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(t, e) {
    this.array || (this.array = new Float32Array(9));
    const i = e || this.array;
    return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, transformed through this matrix
   */
  apply(t, e) {
    e = e || new ve();
    const i = t.x, r = t.y;
    return e.x = this.a * i + this.c * r + this.tx, e.y = this.b * i + this.d * r + this.ty, e;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(t, e) {
    e = e || new ve();
    const i = this.a, r = this.b, s = this.c, o = this.d, a = this.tx, l = this.ty, h = 1 / (i * o + s * -r), c = t.x, p = t.y;
    return e.x = o * h * c + -s * h * p + (l * s - a * o) * h, e.y = i * h * p + -r * h * c + (-l * i + a * r) * h, e;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(t, e) {
    return this.tx += t, this.ty += e, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(t) {
    const e = Math.cos(t), i = Math.sin(t), r = this.a, s = this.c, o = this.tx;
    return this.a = r * e - this.b * i, this.b = r * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = o * e - this.ty * i, this.ty = o * i + this.ty * e, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(t) {
    const e = this.a, i = this.b, r = this.c, s = this.d;
    return this.a = t.a * e + t.b * r, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * r, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this;
  }
  /**
   * Appends two matrix's and sets the result to this matrix. AB = A * B
   * @param a - The matrix to append.
   * @param b - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  appendFrom(t, e) {
    const i = t.a, r = t.b, s = t.c, o = t.d, a = t.tx, l = t.ty, h = e.a, c = e.b, p = e.c, f = e.d;
    return this.a = i * h + r * p, this.b = i * c + r * f, this.c = s * h + o * p, this.d = s * c + o * f, this.tx = a * h + l * p + e.tx, this.ty = a * c + l * f + e.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(t, e, i, r, s, o, a, l, h) {
    return this.a = Math.cos(a + h) * s, this.b = Math.sin(a + h) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = t - (i * this.a + r * this.c), this.ty = e - (i * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(t) {
    const e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      const i = this.a, r = this.c;
      this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(t) {
    const e = this.a, i = this.b, r = this.c, s = this.d, o = t.pivot, a = -Math.atan2(-r, s), l = Math.atan2(i, e), h = Math.abs(a + l);
    return h < 1e-5 || Math.abs(xv - h) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(r * r + s * s), t.position.x = this.tx + (o.x * e + o.y * r), t.position.y = this.ty + (o.x * i + o.y * s), t;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const t = this.a, e = this.b, i = this.c, r = this.d, s = this.tx, o = t * r - e * i;
    return this.a = r / o, this.b = -e / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - r * s) / o, this.ty = -(t * this.ty - e * s) / o, this;
  }
  /** Checks if this matrix is an identity matrix */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const t = new ft();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param matrix - The matrix to copy from.
   * @returns this
   */
  copyFrom(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }
  /**
   * check to see if two matrices are the same
   * @param matrix - The matrix to compare to.
   */
  equals(t) {
    return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix.
   *
   * This is a shared object, if you want to modify it consider creating a new `Matrix`
   * @readonly
   */
  static get IDENTITY() {
    return Tv.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   * Use this object for fast but temporary calculations, as it may be mutated later on.
   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
   * @readonly
   */
  static get shared() {
    return Av.identity();
  }
}
const Av = new ft(), Tv = new ft(), Si = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Ei = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Ci = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Pi = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Vh = [], Am = [], Uo = Math.sign;
function Sv() {
  for (let n = 0; n < 16; n++) {
    const t = [];
    Vh.push(t);
    for (let e = 0; e < 16; e++) {
      const i = Uo(Si[n] * Si[e] + Ci[n] * Ei[e]), r = Uo(Ei[n] * Si[e] + Pi[n] * Ei[e]), s = Uo(Si[n] * Ci[e] + Ci[n] * Pi[e]), o = Uo(Ei[n] * Ci[e] + Pi[n] * Pi[e]);
      for (let a = 0; a < 16; a++)
        if (Si[a] === i && Ei[a] === r && Ci[a] === s && Pi[a] === o) {
          t.push(a);
          break;
        }
    }
  }
  for (let n = 0; n < 16; n++) {
    const t = new ft();
    t.set(Si[n], Ei[n], Ci[n], Pi[n], 0, 0), Am.push(t);
  }
}
Sv();
const Rt = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (n) => Si[n],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (n) => Ei[n],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (n) => Ci[n],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (n) => Pi[n],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (n) => n & 8 ? n & 15 : -n & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (n, t) => Vh[n][t],
  /**
   * Reverse of `add`.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (n, t) => Vh[n][Rt.inv(t)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof maths.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (n) => n ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (n) => (n & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof maths.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (n, t) => Math.abs(n) * 2 <= Math.abs(t) ? t >= 0 ? Rt.S : Rt.N : Math.abs(t) * 2 <= Math.abs(n) ? n > 0 ? Rt.E : Rt.W : t > 0 ? n > 0 ? Rt.SE : Rt.SW : n > 0 ? Rt.NE : Rt.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof maths.groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (n, t, e = 0, i = 0) => {
    const r = Am[Rt.inv(t)];
    r.tx = e, r.ty = i, n.append(r);
  }
}, zo = [new ve(), new ve(), new ve(), new ve()];
class Wt {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(t = 0, e = 0, i = 0, r = 0) {
    this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(r);
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** Determines whether the Rectangle is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /** A constant empty rectangle. This is a new object every time the property is accessed */
  static get EMPTY() {
    return new Wt(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new Wt(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @param bounds - The bounds to copy and convert to a rectangle.
   * @returns Returns itself.
   */
  copyFromBounds(t) {
    return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, i) {
    const { width: r, height: s } = this;
    if (r <= 0 || s <= 0)
      return !1;
    const o = this.x, a = this.y, l = o - i / 2, h = o + r + i / 2, c = a - i / 2, p = a + s + i / 2, f = o + i / 2, u = o + r - i / 2, m = a + i / 2, g = a + s - i / 2;
    return t >= l && t <= h && e >= c && e <= p && !(t > f && t < u && e > m && e < g);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(t, e) {
    if (!e) {
      const _ = this.x < t.x ? t.x : this.x;
      if ((this.right > t.right ? t.right : this.right) <= _)
        return !1;
      const x = this.y < t.y ? t.y : this.y;
      return (this.bottom > t.bottom ? t.bottom : this.bottom) > x;
    }
    const i = this.left, r = this.right, s = this.top, o = this.bottom;
    if (r <= i || o <= s)
      return !1;
    const a = zo[0].set(t.left, t.top), l = zo[1].set(t.left, t.bottom), h = zo[2].set(t.right, t.top), c = zo[3].set(t.right, t.bottom);
    if (h.x <= a.x || l.y <= a.y)
      return !1;
    const p = Math.sign(e.a * e.d - e.b * e.c);
    if (p === 0 || (e.apply(a, a), e.apply(l, l), e.apply(h, h), e.apply(c, c), Math.max(a.x, l.x, h.x, c.x) <= i || Math.min(a.x, l.x, h.x, c.x) >= r || Math.max(a.y, l.y, h.y, c.y) <= s || Math.min(a.y, l.y, h.y, c.y) >= o))
      return !1;
    const f = p * (l.y - a.y), u = p * (a.x - l.x), m = f * i + u * s, g = f * r + u * s, y = f * i + u * o, b = f * r + u * o;
    if (Math.max(m, g, y, b) <= f * a.x + u * a.y || Math.min(m, g, y, b) >= f * c.x + u * c.y)
      return !1;
    const T = p * (a.y - h.y), C = p * (h.x - a.x), P = T * i + C * s, S = T * r + C * s, I = T * i + C * o, w = T * r + C * o;
    return !(Math.max(P, S, I, w) <= T * a.x + C * a.y || Math.min(P, S, I, w) >= T * c.x + C * c.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(t = 0, e = t) {
    return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(t) {
    const e = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), r = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(i - e, 0), this.y = r, this.height = Math.max(s - r, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(t = 1, e = 1e-3) {
    const i = Math.ceil((this.x + this.width - e) * t) / t, r = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(t) {
    const e = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), r = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = i - e, this.y = r, this.height = s - r, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Wt(), t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const Ul = {
  default: -1
};
function Jt(n = "default") {
  return Ul[n] === void 0 && (Ul[n] = -1), ++Ul[n];
}
const $d = {}, gt = "8.0.0", Ev = "8.3.4";
function mt(n, t, e = 3) {
  if ($d[t])
    return;
  let i = new Error().stack;
  typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${n}`) : (i = i.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${t}
Deprecated since v${n}`
  ), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${n}`), console.warn(i))), $d[t] = !0;
}
const Tm = () => {
};
function tp(n) {
  return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
}
function ep(n) {
  return !(n & n - 1) && !!n;
}
function Cv(n) {
  const t = {};
  for (const e in n)
    n[e] !== void 0 && (t[e] = n[e]);
  return t;
}
const np = /* @__PURE__ */ Object.create(null);
function Pv(n) {
  const t = np[n];
  return t === void 0 && (np[n] = Jt("resource")), t;
}
const Sm = class Em extends Ae {
  /**
   * @param options - options for the style
   */
  constructor(t = {}) {
    super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = { ...Em.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
  }
  set addressMode(t) {
    this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(t) {
    mt(gt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(t) {
    this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(t) {
    this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this), this._sharedResourceId = null;
  }
  _generateResourceId() {
    const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    return this._sharedResourceId = Pv(t), this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
  }
};
Sm.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let Iv = Sm;
const Cm = class Pm extends Ae {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(t = {}) {
    super(), this.options = t, this.uid = Jt("textureSource"), this._resourceType = "textureSource", this._resourceId = Jt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...Pm.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new Iv(Cv(t)), this.destroyed = !1, this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(t) {
    var e, i;
    this.style !== t && ((e = this._style) == null || e.off("change", this._onStyleChange, this), this._style = t, (i = this._style) == null || i.on("change", this._onStyleChange, this), this._onStyleChange());
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(t) {
    this._style.addressMode = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(t) {
    this._style.addressMode = t;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(t) {
    this._style.magFilter = t;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(t) {
    this._style.minFilter = t;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(t) {
    this._style.mipmapFilter = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(t) {
    this._style.lodMinClamp = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(t) {
    this._style.lodMaxClamp = t;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const t = this._resolution;
      if (this.resize(this.resourceWidth / t, this.resourceHeight / t))
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = Jt("resource"), this.emit("change", this), this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource: t } = this;
    return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource: t } = this;
    return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(t, e, i) {
    i = i || this._resolution, t = t || this.width, e = e || this.height;
    const r = Math.round(t * i), s = Math.round(e * i);
    return this.width = r / i, this.height = s / i, this._resolution = i, this.pixelWidth === r && this.pixelHeight === s ? !1 : (this._refreshPOT(), this.pixelWidth = r, this.pixelHeight = s, this.emit("resize", this), this._resourceId = Jt("resource"), this.emit("change", this), !0);
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
  }
  set wrapMode(t) {
    this._style.wrapMode = t;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(t) {
    this._style.scaleMode = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = ep(this.pixelWidth) && ep(this.pixelHeight);
  }
  static test(t) {
    throw new Error("Unimplemented");
  }
};
Cm.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: !1,
  sampleCount: 1,
  antialias: !1,
  autoGarbageCollect: !1
};
let En = Cm;
class jc extends En {
  constructor(t) {
    const e = t.resource || new Float32Array(t.width * t.height * 4);
    let i = t.format;
    i || (e instanceof Float32Array ? i = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? i = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? i = "rgba16uint" : i = "bgra8unorm"), super({
      ...t,
      resource: e,
      format: i
    }), this.uploadMethodId = "buffer";
  }
  static test(t) {
    return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
  }
}
jc.extension = K.TextureSource;
const ip = new ft();
class Rv {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(t, e) {
    this.mapCoord = new ft(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = !1, this.texture = t;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(t) {
    var e;
    this.texture !== t && ((e = this._texture) == null || e.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(t, e) {
    e === void 0 && (e = t);
    const i = this.mapCoord;
    for (let r = 0; r < t.length; r += 2) {
      const s = t[r], o = t[r + 1];
      e[r] = s * i.a + o * i.c + i.tx, e[r + 1] = s * i.b + o * i.d + i.ty;
    }
    return e;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const t = this._texture;
    this._updateID++;
    const e = t.uvs;
    this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
    const i = t.orig, r = t.trim;
    r && (ip.set(
      i.width / r.width,
      0,
      0,
      i.height / r.height,
      -r.x / r.width,
      -r.y / r.height
    ), this.mapCoord.append(ip));
    const s = t.source, o = this.uClampFrame, a = this.clampMargin / s._resolution, l = this.clampOffset / s._resolution;
    return o[0] = (t.frame.x + a + l) / s.width, o[1] = (t.frame.y + a + l) / s.height, o[2] = (t.frame.x + t.frame.width - a + l) / s.width, o[3] = (t.frame.y + t.frame.height - a + l) / s.height, this.uClampOffset[0] = this.clampOffset / s.pixelWidth, this.uClampOffset[1] = this.clampOffset / s.pixelHeight, this.isSimple = t.frame.width === s.width && t.frame.height === s.height && t.rotate === 0, !0;
  }
}
class ot extends Ae {
  /**
   * @param {rendering.TextureOptions} options - Options for the texture
   */
  constructor({
    source: t,
    label: e,
    frame: i,
    orig: r,
    trim: s,
    defaultAnchor: o,
    defaultBorders: a,
    rotate: l,
    dynamic: h
  } = {}) {
    if (super(), this.uid = Jt("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new Wt(), this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new En(), this.noFrame = !i, i)
      this.frame.copyFrom(i);
    else {
      const { width: c, height: p } = this._source;
      this.frame.width = c, this.frame.height = p;
    }
    this.orig = r || this.frame, this.trim = s, this.rotate = l ?? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = !1, this.dynamic = h || !1, this.updateUvs();
  }
  set source(t) {
    this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    return this._textureMatrix || (this._textureMatrix = new Rv(this)), this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs: t, frame: e } = this, { width: i, height: r } = this._source, s = e.x / i, o = e.y / r, a = e.width / i, l = e.height / r;
    let h = this.rotate;
    if (h) {
      const c = a / 2, p = l / 2, f = s + c, u = o + p;
      h = Rt.add(h, Rt.NW), t.x0 = f + c * Rt.uX(h), t.y0 = u + p * Rt.uY(h), h = Rt.add(h, 2), t.x1 = f + c * Rt.uX(h), t.y1 = u + p * Rt.uY(h), h = Rt.add(h, 2), t.x2 = f + c * Rt.uX(h), t.y2 = u + p * Rt.uY(h), h = Rt.add(h, 2), t.x3 = f + c * Rt.uX(h), t.y3 = u + p * Rt.uY(h);
    } else
      t.x0 = s, t.y0 = o, t.x1 = s + a, t.y1 = o, t.x2 = s + a, t.y2 = o + l, t.x3 = s, t.y3 = o + l;
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(t = !1) {
    this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    return mt(gt, "Texture.baseTexture is now Texture.source"), this._source;
  }
}
ot.EMPTY = new ot({
  label: "EMPTY",
  source: new En({
    label: "EMPTY"
  })
});
ot.EMPTY.destroy = Tm;
ot.WHITE = new ot({
  source: new jc({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
ot.WHITE.destroy = Tm;
function kv(n, t, e, i) {
  const { width: r, height: s } = e.orig, o = e.trim;
  if (o) {
    const a = o.width, l = o.height;
    n.minX = o.x - t._x * r - i, n.maxX = n.minX + a, n.minY = o.y - t._y * s - i, n.maxY = n.minY + l;
  } else
    n.minX = -t._x * r - i, n.maxX = n.minX + r, n.minY = -t._y * s - i, n.maxY = n.minY + s;
}
const rp = new ft();
let oi = class Im {
  constructor(t = 1 / 0, e = 1 / 0, i = -1 / 0, r = -1 / 0) {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = rp, this.minX = t, this.minY = e, this.maxX = i, this.maxY = r;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** The bounding rectangle of the bounds. */
  get rectangle() {
    this._rectangle || (this._rectangle = new Wt());
    const t = this._rectangle;
    return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
  }
  /** Clears the bounds and resets. */
  clear() {
    return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = rp, this;
  }
  /**
   * Sets the bounds.
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  set(t, e, i, r) {
    this.minX = t, this.minY = e, this.maxX = i, this.maxY = r;
  }
  /**
   * Adds sprite frame
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param matrix
   */
  addFrame(t, e, i, r, s) {
    s || (s = this.matrix);
    const o = s.a, a = s.b, l = s.c, h = s.d, c = s.tx, p = s.ty;
    let f = this.minX, u = this.minY, m = this.maxX, g = this.maxY, y = o * t + l * e + c, b = a * t + h * e + p;
    y < f && (f = y), b < u && (u = b), y > m && (m = y), b > g && (g = b), y = o * i + l * e + c, b = a * i + h * e + p, y < f && (f = y), b < u && (u = b), y > m && (m = y), b > g && (g = b), y = o * t + l * r + c, b = a * t + h * r + p, y < f && (f = y), b < u && (u = b), y > m && (m = y), b > g && (g = b), y = o * i + l * r + c, b = a * i + h * r + p, y < f && (f = y), b < u && (u = b), y > m && (m = y), b > g && (g = b), this.minX = f, this.minY = u, this.maxX = m, this.maxY = g;
  }
  /**
   * Adds a rectangle to the bounds.
   * @param rect - The rectangle to be added.
   * @param matrix - The matrix to apply to the bounds.
   */
  addRect(t, e) {
    this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
  }
  /**
   * Adds other {@link Bounds}.
   * @param bounds - The Bounds to be added
   * @param matrix
   */
  addBounds(t, e) {
    this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param mask - The Bounds to be added.
   */
  addBoundsMask(t) {
    this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
  }
  /**
   * Adds other Bounds, multiplied with matrix.
   * @param matrix - The matrix to apply to the bounds.
   */
  applyMatrix(t) {
    const e = this.minX, i = this.minY, r = this.maxX, s = this.maxY, { a: o, b: a, c: l, d: h, tx: c, ty: p } = t;
    let f = o * e + l * i + c, u = a * e + h * i + p;
    this.minX = f, this.minY = u, this.maxX = f, this.maxY = u, f = o * r + l * i + c, u = a * r + h * i + p, this.minX = f < this.minX ? f : this.minX, this.minY = u < this.minY ? u : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = u > this.maxY ? u : this.maxY, f = o * e + l * s + c, u = a * e + h * s + p, this.minX = f < this.minX ? f : this.minX, this.minY = u < this.minY ? u : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = u > this.maxY ? u : this.maxY, f = o * r + l * s + c, u = a * r + h * s + p, this.minX = f < this.minX ? f : this.minX, this.minY = u < this.minY ? u : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = u > this.maxY ? u : this.maxY;
  }
  /**
   * Resizes the bounds object to include the given rectangle.
   * @param rect - The rectangle to be included.
   */
  fit(t) {
    return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * @param left - The left value of the bounds.
   * @param right - The right value of the bounds.
   * @param top - The top value of the bounds.
   * @param bottom - The bottom value of the bounds.
   */
  fitBounds(t, e, i, r) {
    return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < i && (this.minY = i), this.maxY > r && (this.maxY = r), this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(t, e = t) {
    return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
  }
  /** Ceils the bounds. */
  ceil() {
    return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
  }
  /** Clones the bounds. */
  clone() {
    return new Im(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values
   * @param x - The X value to scale by.
   * @param y - The Y value to scale by.
   */
  scale(t, e = t) {
    return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
  }
  /** the x value of the bounds. */
  get x() {
    return this.minX;
  }
  set x(t) {
    const e = this.maxX - this.minX;
    this.minX = t, this.maxX = t + e;
  }
  /** the y value of the bounds. */
  get y() {
    return this.minY;
  }
  set y(t) {
    const e = this.maxY - this.minY;
    this.minY = t, this.maxY = t + e;
  }
  /** the width value of the bounds. */
  get width() {
    return this.maxX - this.minX;
  }
  set width(t) {
    this.maxX = this.minX + t;
  }
  /** the height value of the bounds. */
  get height() {
    return this.maxY - this.minY;
  }
  set height(t) {
    this.maxY = this.minY + t;
  }
  /** the left value of the bounds. */
  get left() {
    return this.minX;
  }
  /** the right value of the bounds. */
  get right() {
    return this.maxX;
  }
  /** the top value of the bounds. */
  get top() {
    return this.minY;
  }
  /** the bottom value of the bounds. */
  get bottom() {
    return this.maxY;
  }
  /** Is the bounds positive. */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  get isValid() {
    return this.minX + this.minY !== 1 / 0;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param matrix
   */
  addVertexData(t, e, i, r) {
    let s = this.minX, o = this.minY, a = this.maxX, l = this.maxY;
    r || (r = this.matrix);
    const h = r.a, c = r.b, p = r.c, f = r.d, u = r.tx, m = r.ty;
    for (let g = e; g < i; g += 2) {
      const y = t[g], b = t[g + 1], T = h * y + p * b + u, C = c * y + f * b + m;
      s = T < s ? T : s, o = C < o ? C : o, a = T > a ? T : a, l = C > l ? C : l;
    }
    this.minX = s, this.minY = o, this.maxX = a, this.maxY = l;
  }
  /**
   * Checks if the point is contained within the bounds.
   * @param x - x coordinate
   * @param y - y coordinate
   */
  containsPoint(t, e) {
    return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
  }
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
};
var Mv = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, kn = function(n) {
  return typeof n == "string" ? n.length > 0 : typeof n == "number";
}, re = function(n, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * n) / e + 0;
}, nn = function(n, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = 1), n > e ? e : n > t ? n : t;
}, Rm = function(n) {
  return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
}, sp = function(n) {
  return { r: nn(n.r, 0, 255), g: nn(n.g, 0, 255), b: nn(n.b, 0, 255), a: nn(n.a) };
}, zl = function(n) {
  return { r: re(n.r), g: re(n.g), b: re(n.b), a: re(n.a, 3) };
}, Vv = /^#([0-9a-f]{3,8})$/i, jo = function(n) {
  var t = n.toString(16);
  return t.length < 2 ? "0" + t : t;
}, km = function(n) {
  var t = n.r, e = n.g, i = n.b, r = n.a, s = Math.max(t, e, i), o = s - Math.min(t, e, i), a = o ? s === t ? (e - i) / o : s === e ? 2 + (i - t) / o : 4 + (t - e) / o : 0;
  return { h: 60 * (a < 0 ? a + 6 : a), s: s ? o / s * 100 : 0, v: s / 255 * 100, a: r };
}, Mm = function(n) {
  var t = n.h, e = n.s, i = n.v, r = n.a;
  t = t / 360 * 6, e /= 100, i /= 100;
  var s = Math.floor(t), o = i * (1 - e), a = i * (1 - (t - s) * e), l = i * (1 - (1 - t + s) * e), h = s % 6;
  return { r: 255 * [i, a, o, o, l, i][h], g: 255 * [l, i, i, a, o, o][h], b: 255 * [o, o, l, i, i, a][h], a: r };
}, op = function(n) {
  return { h: Rm(n.h), s: nn(n.s, 0, 100), l: nn(n.l, 0, 100), a: nn(n.a) };
}, ap = function(n) {
  return { h: re(n.h), s: re(n.s), l: re(n.l), a: re(n.a, 3) };
}, lp = function(n) {
  return Mm((e = (t = n).s, { h: t.h, s: (e *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * e / (i + e) * 100 : 0, v: i + e, a: t.a }));
  var t, e, i;
}, Ds = function(n) {
  return { h: (t = km(n)).h, s: (r = (200 - (e = t.s)) * (i = t.v) / 100) > 0 && r < 200 ? e * i / 100 / (r <= 100 ? r : 200 - r) * 100 : 0, l: r / 2, a: t.a };
  var t, e, i, r;
}, Dv = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Bv = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Ov = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Fv = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Dh = { string: [[function(n) {
  var t = Vv.exec(n);
  return t ? (n = t[1]).length <= 4 ? { r: parseInt(n[0] + n[0], 16), g: parseInt(n[1] + n[1], 16), b: parseInt(n[2] + n[2], 16), a: n.length === 4 ? re(parseInt(n[3] + n[3], 16) / 255, 2) : 1 } : n.length === 6 || n.length === 8 ? { r: parseInt(n.substr(0, 2), 16), g: parseInt(n.substr(2, 2), 16), b: parseInt(n.substr(4, 2), 16), a: n.length === 8 ? re(parseInt(n.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(n) {
  var t = Ov.exec(n) || Fv.exec(n);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : sp({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(n) {
  var t = Dv.exec(n) || Bv.exec(n);
  if (!t) return null;
  var e, i, r = op({ h: (e = t[1], i = t[2], i === void 0 && (i = "deg"), Number(e) * (Mv[i] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return lp(r);
}, "hsl"]], object: [[function(n) {
  var t = n.r, e = n.g, i = n.b, r = n.a, s = r === void 0 ? 1 : r;
  return kn(t) && kn(e) && kn(i) ? sp({ r: Number(t), g: Number(e), b: Number(i), a: Number(s) }) : null;
}, "rgb"], [function(n) {
  var t = n.h, e = n.s, i = n.l, r = n.a, s = r === void 0 ? 1 : r;
  if (!kn(t) || !kn(e) || !kn(i)) return null;
  var o = op({ h: Number(t), s: Number(e), l: Number(i), a: Number(s) });
  return lp(o);
}, "hsl"], [function(n) {
  var t = n.h, e = n.s, i = n.v, r = n.a, s = r === void 0 ? 1 : r;
  if (!kn(t) || !kn(e) || !kn(i)) return null;
  var o = function(a) {
    return { h: Rm(a.h), s: nn(a.s, 0, 100), v: nn(a.v, 0, 100), a: nn(a.a) };
  }({ h: Number(t), s: Number(e), v: Number(i), a: Number(s) });
  return Mm(o);
}, "hsv"]] }, hp = function(n, t) {
  for (var e = 0; e < t.length; e++) {
    var i = t[e][0](n);
    if (i) return [i, t[e][1]];
  }
  return [null, void 0];
}, Lv = function(n) {
  return typeof n == "string" ? hp(n.trim(), Dh.string) : typeof n == "object" && n !== null ? hp(n, Dh.object) : [null, void 0];
}, jl = function(n, t) {
  var e = Ds(n);
  return { h: e.h, s: nn(e.s + 100 * t, 0, 100), l: e.l, a: e.a };
}, Gl = function(n) {
  return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
}, cp = function(n, t) {
  var e = Ds(n);
  return { h: e.h, s: e.s, l: nn(e.l + 100 * t, 0, 100), a: e.a };
}, Bh = function() {
  function n(t) {
    this.parsed = Lv(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return n.prototype.isValid = function() {
    return this.parsed !== null;
  }, n.prototype.brightness = function() {
    return re(Gl(this.rgba), 2);
  }, n.prototype.isDark = function() {
    return Gl(this.rgba) < 0.5;
  }, n.prototype.isLight = function() {
    return Gl(this.rgba) >= 0.5;
  }, n.prototype.toHex = function() {
    return t = zl(this.rgba), e = t.r, i = t.g, r = t.b, o = (s = t.a) < 1 ? jo(re(255 * s)) : "", "#" + jo(e) + jo(i) + jo(r) + o;
    var t, e, i, r, s, o;
  }, n.prototype.toRgb = function() {
    return zl(this.rgba);
  }, n.prototype.toRgbString = function() {
    return t = zl(this.rgba), e = t.r, i = t.g, r = t.b, (s = t.a) < 1 ? "rgba(" + e + ", " + i + ", " + r + ", " + s + ")" : "rgb(" + e + ", " + i + ", " + r + ")";
    var t, e, i, r, s;
  }, n.prototype.toHsl = function() {
    return ap(Ds(this.rgba));
  }, n.prototype.toHslString = function() {
    return t = ap(Ds(this.rgba)), e = t.h, i = t.s, r = t.l, (s = t.a) < 1 ? "hsla(" + e + ", " + i + "%, " + r + "%, " + s + ")" : "hsl(" + e + ", " + i + "%, " + r + "%)";
    var t, e, i, r, s;
  }, n.prototype.toHsv = function() {
    return t = km(this.rgba), { h: re(t.h), s: re(t.s), v: re(t.v), a: re(t.a, 3) };
    var t;
  }, n.prototype.invert = function() {
    return mn({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, n.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), mn(jl(this.rgba, t));
  }, n.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), mn(jl(this.rgba, -t));
  }, n.prototype.grayscale = function() {
    return mn(jl(this.rgba, -1));
  }, n.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), mn(cp(this.rgba, t));
  }, n.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), mn(cp(this.rgba, -t));
  }, n.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, n.prototype.alpha = function(t) {
    return typeof t == "number" ? mn({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t }) : re(this.rgba.a, 3);
    var e;
  }, n.prototype.hue = function(t) {
    var e = Ds(this.rgba);
    return typeof t == "number" ? mn({ h: t, s: e.s, l: e.l, a: e.a }) : re(e.h);
  }, n.prototype.isEqual = function(t) {
    return this.toHex() === mn(t).toHex();
  }, n;
}(), mn = function(n) {
  return n instanceof Bh ? n : new Bh(n);
}, up = [], Nv = function(n) {
  n.forEach(function(t) {
    up.indexOf(t) < 0 && (t(Bh, Dh), up.push(t));
  });
};
function Uv(n, t) {
  var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, i = {};
  for (var r in e) i[e[r]] = r;
  var s = {};
  n.prototype.toName = function(o) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var a, l, h = i[this.toHex()];
    if (h) return h;
    if (o != null && o.closest) {
      var c = this.toRgb(), p = 1 / 0, f = "black";
      if (!s.length) for (var u in e) s[u] = new n(e[u]).toRgb();
      for (var m in e) {
        var g = (a = c, l = s[m], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
        g < p && (p = g, f = m);
      }
      return f;
    }
  }, t.string.push([function(o) {
    var a = o.toLowerCase(), l = a === "transparent" ? "#0000" : e[a];
    return l ? new n(l).toRgb() : null;
  }, "name"]);
}
Nv([Uv]);
const Cr = class ws {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(t = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see Color.value
   */
  setValue(t) {
    return this.value = t, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
   *   {@link Color.premultiply premultiply} or {@link Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   */
  set value(t) {
    if (t instanceof ws)
      this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
    else {
      if (t === null)
        throw new Error("Cannot set Color#value to null");
      (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(t) {
    return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(t, e) {
    const i = typeof t;
    if (i !== typeof e)
      return !1;
    if (i === "number" || i === "string" || t instanceof Number)
      return t === e;
    if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
      return t.length !== e.length ? !1 : t.every((r, s) => r === e[s]);
    if (t !== null && e !== null) {
      const r = Object.keys(t), s = Object.keys(e);
      return r.length !== s.length ? !1 : r.every((o) => t[o] === e[o]);
    }
    return t === e;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [t, e, i, r] = this._components;
    return { r: t, g: e, b: i, a: r };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [t, e, i] = this._components;
    return { r: t, g: e, b: i };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [t, e, i] = this.toUint8RgbArray();
    return `rgba(${t},${e},${i},${this.alpha})`;
  }
  toUint8RgbArray(t) {
    const [e, i, r] = this._components;
    return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(i * 255), t[2] = Math.round(r * 255), t;
  }
  toArray(t) {
    this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba;
    const [e, i, r, s] = this._components;
    return t[0] = e, t[1] = i, t[2] = r, t[3] = s, t;
  }
  toRgbArray(t) {
    this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb;
    const [e, i, r] = this._components;
    return t[0] = e, t[1] = i, t[2] = r, t;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   */
  toBgrNumber() {
    const [t, e, i] = this.toUint8RgbArray();
    return (i << 16) + (e << 8) + t;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const t = this._int;
    return (t >> 16) + (t & 65280) + ((t & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {ColorSource} value - The color to multiply by.
   */
  multiply(t) {
    const [e, i, r, s] = ws._temp.setValue(t)._components;
    return this._components[0] *= e, this._components[1] *= i, this._components[2] *= r, this._components[3] *= s, this._refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {Color} - Itself.
   */
  premultiply(t, e = !0) {
    return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(t, e = !0) {
    if (t === 1)
      return (255 << 24) + this._int;
    if (t === 0)
      return e ? 0 : this._int;
    let i = this._int >> 16 & 255, r = this._int >> 8 & 255, s = this._int & 255;
    return e && (i = i * t + 0.5 | 0, r = r * t + 0.5 | 0, s = s * t + 0.5 | 0), (t * 255 << 24) + (i << 16) + (r << 8) + s;
  }
  /**
   * Convert to a hexadecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const t = this._int.toString(16);
    return `#${"000000".substring(0, 6 - t.length) + t}`;
  }
  /**
   * Convert to a hexadecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const t = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - t.length) + t;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(t) {
    return this._components[3] = this._clamp(t), this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(t) {
    let e, i, r, s;
    if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
      const o = t;
      e = (o >> 16 & 255) / 255, i = (o >> 8 & 255) / 255, r = (o & 255) / 255, s = 1;
    } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t), [e, i, r, s = 1] = t;
    else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t, 0, 255), [e, i, r, s = 255] = t, e /= 255, i /= 255, r /= 255, s /= 255;
    else if (typeof t == "string" || typeof t == "object") {
      if (typeof t == "string") {
        const a = ws.HEX_PATTERN.exec(t);
        a && (t = `#${a[2]}`);
      }
      const o = mn(t);
      o.isValid() && ({ r: e, g: i, b: r, a: s } = o.rgba, e /= 255, i /= 255, r /= 255);
    }
    if (e !== void 0)
      this._components[0] = e, this._components[1] = i, this._components[2] = r, this._components[3] = s, this._refreshInt();
    else
      throw new Error(`Unable to convert color ${t}`);
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [t, e, i] = this._components;
    this._int = (t * 255 << 16) + (e * 255 << 8) + (i * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(t, e = 0, i = 1) {
    return typeof t == "number" ? Math.min(Math.max(t, e), i) : (t.forEach((r, s) => {
      t[s] = Math.min(Math.max(r, e), i);
    }), t);
  }
  /**
   * Check if the value is a color-like object
   * @param value - Value to check
   * @returns True if the value is a color-like object
   * @static
   * @example
   * import { Color } from 'pixi.js';
   * Color.isColorLike('white'); // returns true
   * Color.isColorLike(0xffffff); // returns true
   * Color.isColorLike([1, 1, 1]); // returns true
   */
  static isColorLike(t) {
    return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof ws || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
  }
};
Cr.shared = new Cr();
Cr._temp = new Cr();
Cr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Yt = Cr;
const zv = {
  cullArea: null,
  cullable: !1,
  cullableChildren: !0
};
class Gc {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(t, e) {
    this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(t) {
    for (let e = 0; e < t; e++)
      this._pool[this._index++] = new this._classType();
    this._count += t;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t) {
    var e;
    let i;
    return this._index > 0 ? i = this._pool[--this._index] : i = new this._classType(), (e = i.init) == null || e.call(i, t), i;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(t) {
    var e;
    (e = t.reset) == null || e.call(t), this._pool[this._index++] = t;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   * @member {number}
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   * @member {number}
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   * @member {number}
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool - mainly used for debugging! */
  clear() {
    this._pool.length = 0, this._index = 0;
  }
}
class jv {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(t, e) {
    this.getPool(t).prepopulate(e);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t, e) {
    return this.getPool(t).get(e);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(t) {
    this.getPool(t.constructor).return(t);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(t) {
    return this._poolsByClass.has(t) || this._poolsByClass.set(t, new Gc(t)), this._poolsByClass.get(t);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const t = {};
    return this._poolsByClass.forEach((e) => {
      const i = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
      t[i] = {
        free: e.totalFree,
        used: e.totalUsed,
        size: e.totalSize
      };
    }), t;
  }
}
const Bn = new jv();
function Gv(n, t, e) {
  const i = n.length;
  let r;
  if (t >= i || e === 0)
    return;
  e = t + e > i ? i - t : e;
  const s = i - e;
  for (r = t; r < s; ++r)
    n[r] = n[r + e];
  n.length = s;
}
const Hv = {
  allowChildren: !0,
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   * @memberof scene.Container#
   */
  removeChildren(n = 0, t) {
    const e = t ?? this.children.length, i = e - n, r = [];
    if (i > 0 && i <= e) {
      for (let o = e - 1; o >= n; o--) {
        const a = this.children[o];
        a && (r.push(a), a.parent = null);
      }
      Gv(this.children, n, e);
      const s = this.renderGroup || this.parentRenderGroup;
      s && s.removeChildren(r);
      for (let o = 0; o < r.length; ++o)
        this.emit("childRemoved", r[o], this, o), r[o].emit("removed", this);
      return r;
    } else if (i === 0 && this.children.length === 0)
      return r;
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   * @memberof scene.Container#
   */
  removeChildAt(n) {
    const t = this.getChildAt(n);
    return this.removeChild(t);
  },
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   * @memberof scene.Container#
   */
  getChildAt(n) {
    if (n < 0 || n >= this.children.length)
      throw new Error(`getChildAt: Index (${n}) does not exist.`);
    return this.children[n];
  },
  /**
   * Changes the position of an existing child in the container container
   * @param child - The child Container instance for which you want to change the index number
   * @param index - The resulting index number for the child container
   * @memberof scene.Container#
   */
  setChildIndex(n, t) {
    if (t < 0 || t >= this.children.length)
      throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
    this.getChildIndex(n), this.addChildAt(n, t);
  },
  /**
   * Returns the index position of a child Container instance
   * @param child - The Container instance to identify
   * @returns - The index position of the child container to identify
   * @memberof scene.Container#
   */
  getChildIndex(n) {
    const t = this.children.indexOf(n);
    if (t === -1)
      throw new Error("The supplied Container must be a child of the caller");
    return t;
  },
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {Container} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {Container} The child that was added.
   * @memberof scene.Container#
   */
  addChildAt(n, t) {
    this.allowChildren || mt(gt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    const { children: e } = this;
    if (t < 0 || t > e.length)
      throw new Error(`${n}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
    if (n.parent) {
      const r = n.parent.children.indexOf(n);
      if (n.parent === this && r === t)
        return n;
      r !== -1 && n.parent.children.splice(r, 1);
    }
    t === e.length ? e.push(n) : e.splice(t, 0, n), n.parent = this, n.didChange = !0, n._updateFlags = 15;
    const i = this.renderGroup || this.parentRenderGroup;
    return i && i.addChild(n), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", n, this, t), n.emit("added", this), n;
  },
  /**
   * Swaps the position of 2 Containers within this container.
   * @param child - First container to swap
   * @param child2 - Second container to swap
   * @memberof scene.Container#
   */
  swapChildren(n, t) {
    if (n === t)
      return;
    const e = this.getChildIndex(n), i = this.getChildIndex(t);
    this.children[e] = t, this.children[i] = n;
    const r = this.renderGroup || this.parentRenderGroup;
    r && (r.structureDidChange = !0), this._didContainerChangeTick++;
  },
  /**
   * Remove the Container from its parent Container. If the Container has no parent, do nothing.
   * @memberof scene.Container#
   */
  removeFromParent() {
    var n;
    (n = this.parent) == null || n.removeChild(this);
  },
  /**
   * Reparent the child to this container, keeping the same worldTransform.
   * @param child - The child to reparent
   * @returns The first child that was reparented.
   * @memberof scene.Container#
   */
  reparentChild(...n) {
    return n.length === 1 ? this.reparentChildAt(n[0], this.children.length) : (n.forEach((t) => this.reparentChildAt(t, this.children.length)), n[0]);
  },
  /**
   * Reparent the child to this container at the specified index, keeping the same worldTransform.
   * @param child - The child to reparent
   * @param index - The index to reparent the child to
   * @memberof scene.Container#
   */
  reparentChildAt(n, t) {
    if (n.parent === this)
      return this.setChildIndex(n, t), n;
    const e = n.worldTransform.clone();
    n.removeFromParent(), this.addChildAt(n, t);
    const i = this.worldTransform.clone();
    return i.invert(), e.prepend(i), n.setFromMatrix(e), n;
  }
};
class dp {
  constructor() {
    this.pipe = "filter", this.priority = 1;
  }
  destroy() {
    for (let t = 0; t < this.filters.length; t++)
      this.filters[t].destroy();
    this.filters = null, this.filterArea = null;
  }
}
class qv {
  constructor() {
    this._effectClasses = [], this._tests = [], this._initialized = !1;
  }
  init() {
    this._initialized || (this._initialized = !0, this._effectClasses.forEach((t) => {
      this.add({
        test: t.test,
        maskClass: t
      });
    }));
  }
  add(t) {
    this._tests.push(t);
  }
  getMaskEffect(t) {
    this._initialized || this.init();
    for (let e = 0; e < this._tests.length; e++) {
      const i = this._tests[e];
      if (i.test(t))
        return Bn.get(i.maskClass, t);
    }
    return t;
  }
  returnMaskEffect(t) {
    Bn.return(t);
  }
}
const Oh = new qv();
xe.handleByList(K.MaskEffect, Oh._effectClasses);
const Wv = {
  _maskEffect: null,
  _maskOptions: {
    inverse: !1
  },
  _filterEffect: null,
  /**
   * @todo Needs docs.
   * @memberof scene.Container#
   * @type {Array<Effect>}
   */
  effects: [],
  /**
   * @todo Needs docs.
   * @param effect - The effect to add.
   * @memberof scene.Container#
   * @ignore
   */
  addEffect(n) {
    if (this.effects.indexOf(n) !== -1)
      return;
    this.effects.push(n), this.effects.sort((e, i) => e.priority - i.priority);
    const t = this.renderGroup || this.parentRenderGroup;
    t && (t.structureDidChange = !0), this._updateIsSimple();
  },
  /**
   * @todo Needs docs.
   * @param effect - The effect to remove.
   * @memberof scene.Container#
   * @ignore
   */
  removeEffect(n) {
    const t = this.effects.indexOf(n);
    t !== -1 && (this.effects.splice(t, 1), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateIsSimple());
  },
  set mask(n) {
    const t = this._maskEffect;
    (t == null ? void 0 : t.mask) !== n && (t && (this.removeEffect(t), Oh.returnMaskEffect(t), this._maskEffect = null), n != null && (this._maskEffect = Oh.getMaskEffect(n), this.addEffect(this._maskEffect)));
  },
  /**
   * Used to set mask and control mask options.
   * @param options
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.setMask({
   *     mask: graphics,
   *     inverse: true,
   * });
   * @memberof scene.Container#
   */
  setMask(n) {
    this._maskOptions = {
      ...this._maskOptions,
      ...n
    }, n.mask && (this.mask = n.mask);
  },
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @memberof scene.Container#
   */
  get mask() {
    var n;
    return (n = this._maskEffect) == null ? void 0 : n.mask;
  },
  set filters(n) {
    var t;
    !Array.isArray(n) && n && (n = [n]);
    const e = this._filterEffect || (this._filterEffect = new dp());
    n = n;
    const i = (n == null ? void 0 : n.length) > 0, r = ((t = e.filters) == null ? void 0 : t.length) > 0, s = i !== r;
    n = Array.isArray(n) ? n.slice(0) : n, e.filters = Object.freeze(n), s && (i ? this.addEffect(e) : (this.removeEffect(e), e.filters = n ?? null));
  },
  /**
   * Sets the filters for the displayObject.
   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
   * To remove filters simply set this property to `'null'`.
   * @memberof scene.Container#
   */
  get filters() {
    var n;
    return (n = this._filterEffect) == null ? void 0 : n.filters;
  },
  set filterArea(n) {
    this._filterEffect || (this._filterEffect = new dp()), this._filterEffect.filterArea = n;
  },
  /**
   * The area the filter is applied to. This is used as more of an optimization
   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
   *
   * Also works as an interaction mask.
   * @memberof scene.Container#
   */
  get filterArea() {
    var n;
    return (n = this._filterEffect) == null ? void 0 : n.filterArea;
  }
}, Yv = {
  /**
   * The instance label of the object.
   * @memberof scene.Container#
   * @member {string} label
   */
  label: null,
  /**
   * The instance name of the object.
   * @deprecated since 8.0.0
   * @see scene.Container#label
   * @member {string} name
   * @memberof scene.Container#
   */
  get name() {
    return mt(gt, "Container.name property has been removed, use Container.label instead"), this.label;
  },
  set name(n) {
    mt(gt, "Container.name property has been removed, use Container.label instead"), this.label = n;
  },
  /**
   * @method getChildByName
   * @deprecated since 8.0.0
   * @param {string} name - Instance name.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified name.
   * @see scene.Container#getChildByLabel
   * @memberof scene.Container#
   */
  getChildByName(n, t = !1) {
    return this.getChildByLabel(n, t);
  },
  /**
   * Returns the first child in the container with the specified label.
   *
   * Recursive searches are done in a pre-order traversal.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified label.
   */
  getChildByLabel(n, t = !1) {
    const e = this.children;
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (r.label === n || n instanceof RegExp && n.test(r.label))
        return r;
    }
    if (t)
      for (let i = 0; i < e.length; i++) {
        const r = e[i].getChildByLabel(n, !0);
        if (r)
          return r;
      }
    return null;
  },
  /**
   * Returns all children in the container with the specified label.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @param {Container[]} [out=[]] - The array to store matching children in.
   * @returns {Container[]} An array of children with the specified label.
   */
  getChildrenByLabel(n, t = !1, e = []) {
    const i = this.children;
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      (s.label === n || n instanceof RegExp && n.test(s.label)) && e.push(s);
    }
    if (t)
      for (let r = 0; r < i.length; r++)
        i[r].getChildrenByLabel(n, !0, e);
    return e;
  }
}, On = new Gc(ft), Pr = new Gc(oi);
function Vm(n, t, e) {
  e.clear();
  let i, r;
  return n.parent ? t ? i = n.parent.worldTransform : (r = On.get().identity(), i = ya(n, r)) : i = ft.IDENTITY, Dm(n, e, i, t), r && On.return(r), e.isValid || e.set(0, 0, 0, 0), e;
}
function Dm(n, t, e, i) {
  var r, s;
  if (!n.visible || !n.measurable)
    return;
  let o;
  i ? o = n.worldTransform : (n.updateLocalTransform(), o = On.get(), o.appendFrom(n.localTransform, e));
  const a = t, l = !!n.effects.length;
  if (l && (t = Pr.get().clear()), n.boundsArea)
    t.addRect(n.boundsArea, o);
  else {
    n.addBounds && (t.matrix = o, n.addBounds(t));
    for (let h = 0; h < n.children.length; h++)
      Dm(n.children[h], t, o, i);
  }
  if (l) {
    for (let h = 0; h < n.effects.length; h++)
      (s = (r = n.effects[h]).addBounds) == null || s.call(r, t);
    a.addBounds(t, ft.IDENTITY), Pr.return(t);
  }
  i || On.return(o);
}
function ya(n, t) {
  const e = n.parent;
  return e && (ya(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
}
let Hl = 0;
const pp = 500;
function jt(...n) {
  Hl !== pp && (Hl++, Hl === pp ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...n));
}
function Bm(n, t, e) {
  return t.clear(), e || (e = ft.IDENTITY), Om(n, t, e, n, !0), t.isValid || t.set(0, 0, 0, 0), t;
}
function Om(n, t, e, i, r) {
  var s, o;
  let a;
  if (r)
    a = On.get(), a = e.copyTo(a);
  else {
    if (!n.visible || !n.measurable)
      return;
    n.updateLocalTransform();
    const c = n.localTransform;
    a = On.get(), a.appendFrom(c, e);
  }
  const l = t, h = !!n.effects.length;
  if (h && (t = Pr.get().clear()), n.boundsArea)
    t.addRect(n.boundsArea, a);
  else {
    n.renderPipeId && (t.matrix = a, n.addBounds(t));
    const c = n.children;
    for (let p = 0; p < c.length; p++)
      Om(c[p], t, a, i, !1);
  }
  if (h) {
    for (let c = 0; c < n.effects.length; c++)
      (o = (s = n.effects[c]).addLocalBounds) == null || o.call(s, t, i);
    l.addBounds(t, ft.IDENTITY), Pr.return(t);
  }
  On.return(a);
}
function Fm(n, t) {
  const e = n.children;
  for (let i = 0; i < e.length; i++) {
    const r = e[i], s = r.uid, o = (r._didViewChangeTick & 65535) << 16 | r._didContainerChangeTick & 65535, a = t.index;
    (t.data[a] !== s || t.data[a + 1] !== o) && (t.data[t.index] = s, t.data[t.index + 1] = o, t.didChange = !0), t.index = a + 2, r.children.length && Fm(r, t);
  }
  return t.didChange;
}
const Xv = new ft(), Kv = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(n, t) {
    const e = Math.sign(this.scale.x) || 1;
    t !== 0 ? this.scale.x = n / t * e : this.scale.x = e;
  },
  _setHeight(n, t) {
    const e = Math.sign(this.scale.y) || 1;
    t !== 0 ? this.scale.y = n / t * e : this.scale.y = e;
  },
  /**
   * Retrieves the local bounds of the container as a Bounds object.
   * @returns - The bounding area.
   * @memberof scene.Container#
   */
  getLocalBounds() {
    this._localBoundsCacheData || (this._localBoundsCacheData = {
      data: [],
      index: 1,
      didChange: !1,
      localBounds: new oi()
    });
    const n = this._localBoundsCacheData;
    return n.index = 1, n.didChange = !1, n.data[0] !== this._didViewChangeTick && (n.didChange = !0, n.data[0] = this._didViewChangeTick), Fm(this, n), n.didChange && Bm(this, n.localBounds, Xv), n.localBounds;
  },
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param bounds - Optional bounds to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   * @memberof scene.Container#
   */
  getBounds(n, t) {
    return Vm(this, n, t || new oi());
  }
}, Qv = {
  _onRender: null,
  set onRender(n) {
    const t = this.renderGroup || this.parentRenderGroup;
    if (!n) {
      this._onRender && (t == null || t.removeOnRender(this)), this._onRender = null;
      return;
    }
    this._onRender || t == null || t.addOnRender(this), this._onRender = n;
  },
  /**
   * This callback is used when the container is rendered. This is where you should add your custom
   * logic that is needed to be run every frame.
   *
   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
   * and "updateTransform" is no longer called every frame
   * @example
   * const container = new Container();
   * container.onRender = () => {
   *    container.rotation += 0.01;
   * };
   * @memberof scene.Container#
   */
  get onRender() {
    return this._onRender;
  }
}, Jv = {
  _zIndex: 0,
  /**
   * Should children be sorted by zIndex at the next render call.
   *
   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortDirty: !1,
  /**
   * If set to true, the container will sort its children by `zIndex` value
   * when the next render is called, or manually if `sortChildren()` is called.
   *
   * This actually changes the order of elements in the array, so should be treated
   * as a basic solution that is not performant compared to other solutions,
   * such as {@link https://github.com/pixijs/layers PixiJS Layers}
   *
   * Also be aware of that this may not work nicely with the `addChildAt()` function,
   * as the `zIndex` sorting may cause the child to automatically sorted to another position.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortableChildren: !1,
  /**
   * The zIndex of the container.
   *
   * Setting this value, will automatically set the parent to be sortable. Children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see scene.Container#sortableChildren
   * @memberof scene.Container#
   */
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(n) {
    this._zIndex !== n && (this._zIndex = n, this.depthOfChildModified());
  },
  depthOfChildModified() {
    this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
  },
  /**
   * Sorts children by zIndex.
   * @memberof scene.Container#
   */
  sortChildren() {
    this.sortDirty && (this.sortDirty = !1, this.children.sort(Zv));
  }
};
function Zv(n, t) {
  return n._zIndex - t._zIndex;
}
const $v = {
  /**
   * Returns the global position of the container.
   * @param point - The optional point to write the global value to.
   * @param skipUpdate - Should we skip the update transform.
   * @returns - The updated point.
   * @memberof scene.Container#
   */
  getGlobalPosition(n = new ve(), t = !1) {
    return this.parent ? this.parent.toGlobal(this._position, n, t) : (n.x = this._position.x, n.y = this._position.y), n;
  },
  /**
   * Calculates the global position of the container.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   * @memberof scene.Container#
   */
  toGlobal(n, t, e = !1) {
    if (!e) {
      this.updateLocalTransform();
      const i = ya(this, new ft());
      return i.append(this.localTransform), i.apply(n, t);
    }
    return this.worldTransform.apply(n, t);
  },
  /**
   * Calculates the local position of the container relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The Container to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   * @memberof scene.Container#
   */
  toLocal(n, t, e, i) {
    if (t && (n = t.toGlobal(n, e, i)), !i) {
      this.updateLocalTransform();
      const r = ya(this, new ft());
      return r.append(this.localTransform), r.applyInverse(n, e);
    }
    return this.worldTransform.applyInverse(n, e);
  }
};
let tx = 0;
class Lm {
  constructor() {
    this.uid = Jt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.tick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0, this.tick = tx++;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(t) {
    this.instructions[this.instructionSize++] = t;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   * @ignore
   */
  log() {
    this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
  }
}
class ex {
  constructor() {
    this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new ft(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new Lm(), this._onRenderContainers = [];
  }
  init(t) {
    this.root = t, t._onRender && this.addOnRender(t), t.didChange = !0;
    const e = t.children;
    for (let i = 0; i < e.length; i++)
      this.addChild(e[i]);
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const t in this.childrenToUpdate) {
      const e = this.childrenToUpdate[t];
      e.list.fill(null), e.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null;
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(t) {
    t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
  }
  _removeRenderGroupChild(t) {
    const e = this.renderGroupChildren.indexOf(t);
    e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
  }
  addChild(t) {
    if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) {
      this.addRenderGroupChild(t.renderGroup);
      return;
    }
    t._onRender && this.addOnRender(t);
    const e = t.children;
    for (let i = 0; i < e.length; i++)
      this.addChild(e[i]);
  }
  removeChild(t) {
    if (this.structureDidChange = !0, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
      this._removeRenderGroupChild(t.renderGroup);
      return;
    }
    const e = t.children;
    for (let i = 0; i < e.length; i++)
      this.removeChild(e[i]);
  }
  removeChildren(t) {
    for (let e = 0; e < t.length; e++)
      this.removeChild(t[e]);
  }
  onChildUpdate(t) {
    let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
    e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
      index: 0,
      list: []
    }), e.list[e.index++] = t;
  }
  updateRenderable(t) {
    t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1);
  }
  onChildViewUpdate(t) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(t) {
    this._onRenderContainers.push(t);
  }
  removeOnRender(t) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
  }
  runOnRender() {
    for (let t = 0; t < this._onRenderContainers.length; t++)
      this._onRenderContainers[t]._onRender();
  }
  destroy() {
    this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
  }
  getChildren(t = []) {
    const e = this.root.children;
    for (let i = 0; i < e.length; i++)
      this._getChildren(e[i], t);
    return t;
  }
  _getChildren(t, e = []) {
    if (e.push(t), t.renderGroup)
      return e;
    const i = t.children;
    for (let r = 0; r < i.length; r++)
      this._getChildren(i[r], e);
    return e;
  }
}
function nx(n, t, e = {}) {
  for (const i in t)
    !e[i] && t[i] !== void 0 && (n[i] = t[i]);
}
const ql = new Kt(null), Wl = new Kt(null), Yl = new Kt(null, 1, 1), fp = 1, ix = 2, Xl = 4;
class Ie extends Ae {
  constructor(t = {}) {
    var e, i;
    super(), this.uid = Jt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new ft(), this.relativeGroupTransform = new ft(), this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Kt(this, 0, 0), this._scale = Yl, this._pivot = Wl, this._skew = ql, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], nx(this, t, {
      children: !0,
      parent: !0,
      effects: !0
    }), (e = t.children) == null || e.forEach((r) => this.addChild(r)), (i = t.parent) == null || i.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   */
  static mixin(t) {
    Object.defineProperties(Ie.prototype, Object.getOwnPropertyDescriptors(t));
  }
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(t) {
    this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
  }
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...Container} children - The Container(s) to add to the container
   * @returns {Container} - The first child that was added.
   */
  addChild(...t) {
    if (this.allowChildren || mt(gt, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.addChild(t[r]);
      return t[0];
    }
    const e = t[0];
    if (e.parent === this)
      return this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), e;
    e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e._updateFlags = 15;
    const i = this.renderGroup || this.parentRenderGroup;
    return i && i.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e;
  }
  /**
   * Removes one or more children from the container.
   * @param {...Container} children - The Container(s) to remove
   * @returns {Container} The first child that was removed.
   */
  removeChild(...t) {
    if (t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.removeChild(t[r]);
      return t[0];
    }
    const e = t[0], i = this.children.indexOf(e);
    return i > -1 && (this._didViewChangeTick++, this.children.splice(i, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, i), e.emit("removed", this)), e;
  }
  /** @ignore */
  _onUpdate(t) {
    t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
  }
  set isRenderGroup(t) {
    !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), this.renderGroup = Bn.get(ex, this), this.groupTransform = ft.IDENTITY, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** This will disable the render group for this container. */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), Bn.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    return this._worldTransform || (this._worldTransform = new ft()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
  }
  // / ////// transform related stuff
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this._position.x;
  }
  set x(t) {
    this._position.x = t;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this._position.y;
  }
  set y(t) {
    this._position.y = t;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position.copyFrom(t);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.rotation * bv;
  }
  set angle(t) {
    this.rotation = t * wv;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    return this._pivot === Wl && (this._pivot = new Kt(this, 0, 0)), this._pivot;
  }
  set pivot(t) {
    this._pivot === Wl && (this._pivot = new Kt(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    return this._skew === ql && (this._skew = new Kt(this, 0, 0)), this._skew;
  }
  set skew(t) {
    this._skew === ql && (this._skew = new Kt(this, 0, 0)), this._skew.copyFrom(t);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    return this._scale === Yl && (this._scale = new Kt(this, 1, 1)), this._scale;
  }
  set scale(t) {
    this._scale === Yl && (this._scale = new Kt(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(t) {
    const e = this.getLocalBounds().width;
    this._setWidth(t, e);
  }
  /**
   * The height of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(t) {
    const e = this.getLocalBounds().height;
    this._setHeight(t, e);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the container.
   * @memberof scene.Container#
   */
  getSize(t) {
    t || (t = {});
    const e = this.getLocalBounds();
    return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   * @memberof scene.Container#
   */
  setSize(t, e) {
    const i = this.getLocalBounds();
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, i.width), e !== void 0 && this._setHeight(e, i.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const t = this._rotation, e = this._skew;
    this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
  }
  /**
   * Updates the transform properties of the container (accepts partial values).
   * @param {object} opts - The options for updating the transform.
   * @param {number} opts.x - The x position of the container.
   * @param {number} opts.y - The y position of the container.
   * @param {number} opts.scaleX - The scale factor on the x-axis.
   * @param {number} opts.scaleY - The scale factor on the y-axis.
   * @param {number} opts.rotation - The rotation of the container, in radians.
   * @param {number} opts.skewX - The skew factor on the x-axis.
   * @param {number} opts.skewY - The skew factor on the y-axis.
   * @param {number} opts.pivotX - The x coordinate of the pivot point.
   * @param {number} opts.pivotY - The y coordinate of the pivot point.
   */
  updateTransform(t) {
    return this.position.set(
      typeof t.x == "number" ? t.x : this.position.x,
      typeof t.y == "number" ? t.y : this.position.y
    ), this.scale.set(
      typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x,
      typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y
    ), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(
      typeof t.skewX == "number" ? t.skewX : this.skew.x,
      typeof t.skewY == "number" ? t.skewY : this.skew.y
    ), this.pivot.set(
      typeof t.pivotX == "number" ? t.pivotX : this.pivot.x,
      typeof t.pivotY == "number" ? t.pivotY : this.pivot.y
    ), this;
  }
  /**
   * Updates the local transform using the given matrix.
   * @param matrix - The matrix to use for updating the transform.
   */
  setFromMatrix(t) {
    t.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const t = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === t)
      return;
    this._didLocalTransformChangeId = t;
    const e = this.localTransform, i = this._scale, r = this._pivot, s = this._position, o = i._x, a = i._y, l = r._x, h = r._y;
    e.a = this._cx * o, e.b = this._sx * o, e.c = this._cy * a, e.d = this._sy * a, e.tx = s._x - (l * e.a + h * e.c), e.ty = s._y - (l * e.b + h * e.d);
  }
  // / ///// color related stuff
  set alpha(t) {
    t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= fp, this._onUpdate());
  }
  /** The opacity of the object. */
  get alpha() {
    return this.localAlpha;
  }
  set tint(t) {
    const e = Yt.shared.setValue(t ?? 16777215).toBgrNumber();
    e !== this.localColor && (this.localColor = e, this._updateFlags |= fp, this._onUpdate());
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    const t = this.localColor;
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
  }
  // / //////////////// blend related stuff
  set blendMode(t) {
    this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= ix, this.localBlendMode = t, this._onUpdate());
  }
  /**
   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
   * @default 'normal'
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(t) {
    const e = t ? 2 : 0;
    (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Xl, this.localDisplayStatus ^= 2, this._onUpdate());
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(t) {
    const e = t ? 0 : 4;
    (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Xl, this.localDisplayStatus ^= 4, this._onUpdate());
  }
  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(t) {
    const e = t ? 1 : 0;
    (this.localDisplayStatus & 1) !== e && (this._updateFlags |= Xl, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
  }
  /** Whether or not the object should be rendered. */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
   * is set to true it should destroy the texture of the child sprite
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true it should destroy the texture source of the child sprite
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true it should destroy the context of the child graphics
   */
  destroy(t = !1) {
    var e;
    if (this.destroyed)
      return;
    this.destroyed = !0;
    let i;
    if (this.children.length && (i = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t == null ? void 0 : t.children) && i)
      for (let r = 0; r < i.length; ++r)
        i[r].destroy(t);
    (e = this.renderGroup) == null || e.destroy(), this.renderGroup = null;
  }
}
Ie.mixin(Hv);
Ie.mixin($v);
Ie.mixin(Qv);
Ie.mixin(Kv);
Ie.mixin(Wv);
Ie.mixin(Yv);
Ie.mixin(Jv);
Ie.mixin(zv);
class Wa extends Ie {
  constructor() {
    super(...arguments), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = 0, this._lastInstructionTick = -1, this._bounds = new oi(0, 1, 0, 0), this._boundsDirty = !0;
  }
  /** @private */
  _updateBounds() {
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @type {boolean}
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(t) {
    this._roundPixels = t ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds, { x: i, y: r } = t;
    return i >= e.minX && i <= e.maxX && r >= e.minY && r <= e.maxY;
  }
  /** @private */
  onViewUpdate() {
    if (this._didViewChangeTick++, this.didViewUpdate)
      return;
    this.didViewUpdate = !0;
    const t = this.renderGroup || this.parentRenderGroup;
    t && t.onChildViewUpdate(this);
  }
  destroy(t) {
    super.destroy(t), this._bounds = null;
  }
}
class Ir extends Wa {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(t = ot.EMPTY) {
    t instanceof ot && (t = { texture: t });
    const { texture: e = ot.EMPTY, anchor: i, roundPixels: r, width: s, height: o, ...a } = t;
    super({
      label: "Sprite",
      ...a
    }), this.renderPipeId = "sprite", this.batched = !0, this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._sourceBoundsDirty = !0, this._anchor = new Kt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), i ? this.anchor = i : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = r ?? !1, s !== void 0 && (this.width = s), o !== void 0 && (this.height = o);
  }
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image, video, canvas element, video element, texture
   * @param source - Source to create texture from
   * @param [skipCache] - Whether to skip the cache or not
   * @returns The newly created sprite
   */
  static from(t, e = !1) {
    return t instanceof ot ? new Ir(t) : new Ir(ot.from(t, e));
  }
  set texture(t) {
    t || (t = ot.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /**
   * The bounds of the sprite, taking the texture's trim into account.
   * @type {rendering.Bounds}
   */
  get sourceBounds() {
    return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = !1), this._sourceBounds;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.sourceBounds;
    return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this._texture.trim ? this.sourceBounds : this.bounds;
    t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
  }
  onViewUpdate() {
    this._sourceBoundsDirty = this._boundsDirty = !0, super.onViewUpdate();
  }
  _updateBounds() {
    kv(this._bounds, this._anchor, this._texture, 0);
  }
  _updateSourceBounds() {
    const t = this._anchor, e = this._texture, i = this._sourceBounds, { width: r, height: s } = e.orig;
    i.maxX = -t._x * r, i.minX = i.maxX + r, i.maxY = -t._y * s, i.minY = i.maxY + s;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(e);
    }
    this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(t) {
    this._setWidth(t, this._texture.orig.width), this._width = t;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(t) {
    this._setHeight(t, this._texture.orig.height), this._height = t;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Sprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
  }
}
const rx = new oi();
function Nm(n, t, e) {
  const i = rx;
  n.measurable = !0, Vm(n, e, i), t.addBoundsMask(i), n.measurable = !1;
}
function Um(n, t, e) {
  const i = Pr.get();
  n.measurable = !0;
  const r = On.get().identity(), s = zm(n, e, r);
  Bm(n, i, s), n.measurable = !1, t.addBoundsMask(i), On.return(r), Pr.return(i);
}
function zm(n, t, e) {
  return n ? (n !== t && (zm(n.parent, t, e), n.updateLocalTransform(), e.append(n.localTransform)), e) : (jt("Mask bounds, renderable is not inside the root container"), e);
}
class jm {
  constructor(t) {
    this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.renderMaskToTexture = !(t instanceof Ir), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask = null;
  }
  addBounds(t, e) {
    this.inverse || Nm(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    Um(this.mask, t, e);
  }
  containsPoint(t, e) {
    const i = this.mask;
    return e(i, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Ir;
  }
}
jm.extension = K.MaskEffect;
class Gm {
  constructor(t) {
    this.priority = 0, this.pipe = "colorMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t;
  }
  destroy() {
  }
  static test(t) {
    return typeof t == "number";
  }
}
Gm.extension = K.MaskEffect;
class Hm {
  constructor(t) {
    this.priority = 0, this.pipe = "stencilMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
  }
  addBounds(t, e) {
    Nm(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    Um(this.mask, t, e);
  }
  containsPoint(t, e) {
    const i = this.mask;
    return e(i, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Ie;
  }
}
Hm.extension = K.MaskEffect;
const sx = {
  createCanvas: (n, t) => {
    const e = document.createElement("canvas");
    return e.width = n, e.height = t, e;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (n, t) => fetch(n, t),
  parseXML: (n) => new DOMParser().parseFromString(n, "text/xml")
};
let mp = sx;
const Bt = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return mp;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(n) {
    mp = n;
  }
};
class qm extends En {
  constructor(t) {
    t.resource || (t.resource = Bt.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity;
    const e = t.resource;
    (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent;
  }
  resizeCanvas() {
    this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
  }
  resize(t = this.width, e = this.height, i = this._resolution) {
    const r = super.resize(t, e, i);
    return r && this.resizeCanvas(), r;
  }
  static test(t) {
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
qm.extension = K.TextureSource;
class Hr extends En {
  constructor(t) {
    if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
      const e = Bt.get().createCanvas(t.resource.width, t.resource.height);
      e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, jt("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
    }
    super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
  }
  static test(t) {
    return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
  }
}
Hr.extension = K.TextureSource;
var Fh = /* @__PURE__ */ ((n) => (n[n.INTERACTION = 50] = "INTERACTION", n[n.HIGH = 25] = "HIGH", n[n.NORMAL = 0] = "NORMAL", n[n.LOW = -25] = "LOW", n[n.UTILITY = -50] = "UTILITY", n))(Fh || {});
class Kl {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(t, e = null, i = 0, r = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = i, this._once = r;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(t, e = null) {
    return this._fn === t && this._context === e;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(t) {
    this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
    const e = this.next;
    return this._once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(t = !1) {
    this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }
}
const Wm = class He {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Kl(null, null, 1 / 0), this.deltaMS = 1 / He.targetFPMS, this.elapsedMS = 1 / He.targetFPMS, this._tick = (t) => {
      this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(t, e, i = Fh.NORMAL) {
    return this._addListener(new Kl(t, e, i));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(t, e, i = Fh.NORMAL) {
    return this._addListener(new Kl(t, e, i, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(t) {
    let e = this._head.next, i = this._head;
    if (!e)
      t.connect(i);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(i);
          break;
        }
        i = e, e = e.next;
      }
      t.previous || t.connect(i);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(t, e) {
    let i = this._head.next;
    for (; i; )
      i.match(t, e) ? i = i.destroy() : i = i.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let t = 0, e = this._head;
    for (; e = e.next; )
      t++;
    return t;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let t = this._head.next;
      for (; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link ticker.Ticker#elapsedMS|elapsedMS},
   * the current {@link ticker.Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(t = performance.now()) {
    let e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        const s = t - this._lastFrame | 0;
        if (s < this._minElapsedMS)
          return;
        this._lastFrame = t - s % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * He.targetFPMS;
      const i = this._head;
      let r = i.next;
      for (; r; )
        r = r.emit(this);
      i.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link ticker.Ticker#speed|speed}, which is specific
   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(t) {
    const e = Math.min(this.maxFPS, t), i = Math.min(Math.max(0, e) / 1e3, He.targetFPMS);
    this._maxElapsedMS = 1 / i;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(t) {
    if (t === 0)
      this._minElapsedMS = 0;
    else {
      const e = Math.max(this.minFPS, t);
      this._minElapsedMS = 1 / (e / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get shared() {
    if (!He._shared) {
      const t = He._shared = new He();
      t.autoStart = !0, t._protected = !0;
    }
    return He._shared;
  }
  /**
   * The system ticker instance used by {@link BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get system() {
    if (!He._system) {
      const t = He._system = new He();
      t.autoStart = !0, t._protected = !0;
    }
    return He._system;
  }
};
Wm.targetFPMS = 0.06;
let Dn = Wm, Ql;
async function Ym() {
  return Ql ?? (Ql = (async () => {
    var n;
    const t = document.createElement("canvas").getContext("webgl");
    if (!t)
      return "premultiply-alpha-on-upload";
    const e = await new Promise((o) => {
      const a = document.createElement("video");
      a.onloadeddata = () => o(a), a.onerror = () => o(null), a.autoplay = !1, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
    });
    if (!e)
      return "premultiply-alpha-on-upload";
    const i = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, i);
    const r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      i,
      0
    ), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
    const s = new Uint8Array(4);
    return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, s), t.deleteFramebuffer(r), t.deleteTexture(i), (n = t.getExtension("WEBGL_lose_context")) == null || n.loseContext(), s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })()), Ql;
}
const Ya = class Xm extends En {
  constructor(t) {
    super(t), this.isReady = !1, this.uploadMethodId = "video", t = {
      ...Xm.defaultOptions,
      ...t
    }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load();
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const t = Dn.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load)
      return this._load;
    const t = this.resource, e = this.options;
    return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await Ym(), this._load = new Promise((i, r) => {
      this.isValid ? i(this) : (this._resolve = i, this._reject = r, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
        this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
      })), t.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(t) {
    this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const t = this.resource;
    return !t.paused && !t.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    return this.resource.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.isValid || this._mediaReady(), this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
  }
  _onCanPlay() {
    this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
  }
  _onCanPlayThrough() {
    this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const t = this.resource;
    this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const t = this.resource;
    t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(t) {
    t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(t) {
    t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Dn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Dn.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Dn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  static test(t) {
    return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
  }
};
Ya.extension = K.TextureSource;
Ya.defaultOptions = {
  ...En.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: !0,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: !0,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: !0,
  /** If true, the video will loop when it ends. */
  loop: !1,
  /** If true, the video will be muted. */
  muted: !0,
  /** If true, the video will play inline. */
  playsinline: !0,
  /** If true, the video will be preloaded. */
  preload: !1
};
Ya.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let ia = Ya;
const hn = (n, t, e = !1) => (Array.isArray(n) || (n = [n]), t ? n.map((i) => typeof i == "string" || e ? t(i) : i) : n);
class ox {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(t) {
    return this._cache.has(t);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(t) {
    const e = this._cache.get(t);
    return e || jt(`[Assets] Asset id ${t} was not found in the Cache`), e;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(t, e) {
    const i = hn(t);
    let r;
    for (let l = 0; l < this.parsers.length; l++) {
      const h = this.parsers[l];
      if (h.test(e)) {
        r = h.getCacheableAssets(i, e);
        break;
      }
    }
    const s = new Map(Object.entries(r || {}));
    r || i.forEach((l) => {
      s.set(l, e);
    });
    const o = [...s.keys()], a = {
      cacheKeys: o,
      keys: i
    };
    i.forEach((l) => {
      this._cacheMap.set(l, a);
    }), o.forEach((l) => {
      const h = r ? r[l] : e;
      this._cache.has(l) && this._cache.get(l) !== h && jt("[Cache] already has key:", l), this._cache.set(l, s.get(l));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(t) {
    if (!this._cacheMap.has(t)) {
      jt(`[Assets] Asset id ${t} was not found in the Cache`);
      return;
    }
    const e = this._cacheMap.get(t);
    e.cacheKeys.forEach((i) => {
      this._cache.delete(i);
    }), e.keys.forEach((i) => {
      this._cacheMap.delete(i);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const Mt = new ox(), Lh = [];
xe.handleByList(K.TextureSource, Lh);
function Km(n = {}) {
  const t = n && n.resource, e = t ? n.resource : n, i = t ? n : { resource: n };
  for (let r = 0; r < Lh.length; r++) {
    const s = Lh[r];
    if (s.test(e))
      return new s(i);
  }
  throw new Error(`Could not find a source type for resource: ${i.resource}`);
}
function ax(n = {}, t = !1) {
  const e = n && n.resource, i = e ? n.resource : n, r = e ? n : { resource: n };
  if (!t && Mt.has(i))
    return Mt.get(i);
  const s = new ot({ source: Km(r) });
  return s.on("destroy", () => {
    Mt.has(i) && Mt.remove(i);
  }), t || Mt.set(i, s), s;
}
function lx(n, t = !1) {
  return typeof n == "string" ? Mt.get(n) : n instanceof En ? new ot({ source: n }) : ax(n, t);
}
ot.from = lx;
En.from = Km;
xe.add(jm, Gm, Hm, ia, Hr, qm, jc);
var Hn = /* @__PURE__ */ ((n) => (n[n.Low = 0] = "Low", n[n.Normal = 1] = "Normal", n[n.High = 2] = "High", n))(Hn || {});
function ln(n) {
  if (typeof n != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(n)}`);
}
function gs(n) {
  return n.split("?")[0].split("#")[0];
}
function hx(n) {
  return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function cx(n, t, e) {
  return n.replace(new RegExp(hx(t), "g"), e);
}
function ux(n, t) {
  let e = "", i = 0, r = -1, s = 0, o = -1;
  for (let a = 0; a <= n.length; ++a) {
    if (a < n.length)
      o = n.charCodeAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(r === a - 1 || s === 1)) if (r !== a - 1 && s === 2) {
        if (e.length < 2 || i !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
          if (e.length > 2) {
            const l = e.lastIndexOf("/");
            if (l !== e.length - 1) {
              l === -1 ? (e = "", i = 0) : (e = e.slice(0, l), i = e.length - 1 - e.lastIndexOf("/")), r = a, s = 0;
              continue;
            }
          } else if (e.length === 2 || e.length === 1) {
            e = "", i = 0, r = a, s = 0;
            continue;
          }
        }
      } else
        e.length > 0 ? e += `/${n.slice(r + 1, a)}` : e = n.slice(r + 1, a), i = a - r - 1;
      r = a, s = 0;
    } else o === 46 && s !== -1 ? ++s : s = -1;
  }
  return e;
}
const ue = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(n) {
    return cx(n, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(n) {
    return /^https?:/.test(this.toPosix(n));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(n) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(n);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(n) {
    return n.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(n) {
    return /^[^/:]+:/.test(this.toPosix(n));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(n) {
    ln(n), n = this.toPosix(n);
    const t = /^file:\/\/\//.exec(n);
    if (t)
      return t[0];
    const e = /^[^/:]+:\/{0,2}/.exec(n);
    return e ? e[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(n, t, e) {
    if (ln(n), this.isDataUrl(n) || this.isBlobUrl(n))
      return n;
    const i = gs(this.toPosix(t ?? Bt.get().getBaseUrl())), r = gs(this.toPosix(e ?? this.rootname(i)));
    return n = this.toPosix(n), n.startsWith("/") ? ue.join(r, n.slice(1)) : this.isAbsolute(n) ? n : this.join(i, n);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(n) {
    if (ln(n), n.length === 0)
      return ".";
    if (this.isDataUrl(n) || this.isBlobUrl(n))
      return n;
    n = this.toPosix(n);
    let t = "";
    const e = n.startsWith("/");
    this.hasProtocol(n) && (t = this.rootname(n), n = n.slice(t.length));
    const i = n.endsWith("/");
    return n = ux(n), n.length > 0 && i && (n += "/"), e ? `/${n}` : t + n;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(n) {
    return ln(n), n = this.toPosix(n), this.hasProtocol(n) ? !0 : n.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...n) {
    if (n.length === 0)
      return ".";
    let t;
    for (let e = 0; e < n.length; ++e) {
      const i = n[e];
      if (ln(i), i.length > 0)
        if (t === void 0)
          t = i;
        else {
          const r = n[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(r).toLowerCase()) ? t += `/../${i}` : t += `/${i}`;
        }
    }
    return t === void 0 ? "." : this.normalize(t);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(n) {
    if (ln(n), n.length === 0)
      return ".";
    n = this.toPosix(n);
    let t = n.charCodeAt(0);
    const e = t === 47;
    let i = -1, r = !0;
    const s = this.getProtocol(n), o = n;
    n = n.slice(s.length);
    for (let a = n.length - 1; a >= 1; --a)
      if (t = n.charCodeAt(a), t === 47) {
        if (!r) {
          i = a;
          break;
        }
      } else
        r = !1;
    return i === -1 ? e ? "/" : this.isUrl(o) ? s + n : s : e && i === 1 ? "//" : s + n.slice(0, i);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(n) {
    ln(n), n = this.toPosix(n);
    let t = "";
    if (n.startsWith("/") ? t = "/" : t = this.getProtocol(n), this.isUrl(n)) {
      const e = n.indexOf("/", t.length);
      e !== -1 ? t = n.slice(0, e) : t = n, t.endsWith("/") || (t += "/");
    }
    return t;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(n, t) {
    ln(n), t && ln(t), n = gs(this.toPosix(n));
    let e = 0, i = -1, r = !0, s;
    if (t !== void 0 && t.length > 0 && t.length <= n.length) {
      if (t.length === n.length && t === n)
        return "";
      let o = t.length - 1, a = -1;
      for (s = n.length - 1; s >= 0; --s) {
        const l = n.charCodeAt(s);
        if (l === 47) {
          if (!r) {
            e = s + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = s + 1), o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (i = s) : (o = -1, i = a));
      }
      return e === i ? i = a : i === -1 && (i = n.length), n.slice(e, i);
    }
    for (s = n.length - 1; s >= 0; --s)
      if (n.charCodeAt(s) === 47) {
        if (!r) {
          e = s + 1;
          break;
        }
      } else i === -1 && (r = !1, i = s + 1);
    return i === -1 ? "" : n.slice(e, i);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(n) {
    ln(n), n = gs(this.toPosix(n));
    let t = -1, e = 0, i = -1, r = !0, s = 0;
    for (let o = n.length - 1; o >= 0; --o) {
      const a = n.charCodeAt(o);
      if (a === 47) {
        if (!r) {
          e = o + 1;
          break;
        }
        continue;
      }
      i === -1 && (r = !1, i = o + 1), a === 46 ? t === -1 ? t = o : s !== 1 && (s = 1) : t !== -1 && (s = -1);
    }
    return t === -1 || i === -1 || s === 0 || s === 1 && t === i - 1 && t === e + 1 ? "" : n.slice(t, i);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(n) {
    ln(n);
    const t = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return t;
    n = gs(this.toPosix(n));
    let e = n.charCodeAt(0);
    const i = this.isAbsolute(n);
    let r;
    t.root = this.rootname(n), i || this.hasProtocol(n) ? r = 1 : r = 0;
    let s = -1, o = 0, a = -1, l = !0, h = n.length - 1, c = 0;
    for (; h >= r; --h) {
      if (e = n.charCodeAt(h), e === 47) {
        if (!l) {
          o = h + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = h + 1), e === 46 ? s === -1 ? s = h : c !== 1 && (c = 1) : s !== -1 && (c = -1);
    }
    return s === -1 || a === -1 || c === 0 || c === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && i ? t.base = t.name = n.slice(1, a) : t.base = t.name = n.slice(o, a)) : (o === 0 && i ? (t.name = n.slice(1, s), t.base = n.slice(1, a)) : (t.name = n.slice(o, s), t.base = n.slice(o, a)), t.ext = n.slice(s, a)), t.dir = this.dirname(n), t;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function Qm(n, t, e, i, r) {
  const s = t[e];
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    e < t.length - 1 ? Qm(n.replace(i[e], a), t, e + 1, i, r) : r.push(n.replace(i[e], a));
  }
}
function dx(n) {
  const t = /\{(.*?)\}/g, e = n.match(t), i = [];
  if (e) {
    const r = [];
    e.forEach((s) => {
      const o = s.substring(1, s.length - 1).split(",");
      r.push(o);
    }), Qm(n, r, 0, e, i);
  } else
    i.push(n);
  return i;
}
const _a = (n) => !Array.isArray(n);
class qr {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
      extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(t) {
    if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...t) {
    t.forEach((e) => {
      this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(t) {
    this._basePath = t;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(t) {
    this._rootPath = t;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(t) {
    if (typeof t == "string")
      this._defaultSearchParams = t;
    else {
      const e = t;
      this._defaultSearchParams = Object.keys(e).map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(t) {
    const { alias: e, src: i } = t;
    return hn(
      e || i,
      (r) => typeof r == "string" ? r : Array.isArray(r) ? r.map((s) => (s == null ? void 0 : s.src) ?? s) : r != null && r.src ? r.src : r,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(t) {
    this._manifest && jt("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
      this.addBundle(e.name, e.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    const i = [];
    let r = e;
    Array.isArray(e) || (r = Object.entries(e).map(([s, o]) => typeof o == "string" || Array.isArray(o) ? { alias: s, src: o } : { alias: s, ...o })), r.forEach((s) => {
      const o = s.src, a = s.alias;
      let l;
      if (typeof a == "string") {
        const h = this._createBundleAssetId(t, a);
        i.push(h), l = [a, h];
      } else {
        const h = a.map((c) => this._createBundleAssetId(t, c));
        i.push(...h), l = [...a, ...h];
      }
      this.add({
        ...s,
        alias: l,
        src: o
      });
    }), this._bundles[t] = i;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(t) {
    const e = [];
    Array.isArray(t) ? e.push(...t) : e.push(t);
    let i;
    i = (r) => {
      this.hasKey(r) && jt(`[Resolver] already has key: ${r} overwriting`);
    }, hn(e).forEach((r) => {
      const { src: s } = r;
      let { data: o, format: a, loadParser: l } = r;
      const h = hn(s).map((f) => typeof f == "string" ? dx(f) : Array.isArray(f) ? f : [f]), c = this.getAlias(r);
      Array.isArray(c) ? c.forEach(i) : i(c);
      const p = [];
      h.forEach((f) => {
        f.forEach((u) => {
          let m = {};
          if (typeof u != "object") {
            m.src = u;
            for (let g = 0; g < this._parsers.length; g++) {
              const y = this._parsers[g];
              if (y.test(u)) {
                m = y.parse(u);
                break;
              }
            }
          } else
            o = u.data ?? o, a = u.format ?? a, l = u.loadParser ?? l, m = {
              ...m,
              ...u
            };
          if (!c)
            throw new Error(`[Resolver] alias is undefined for this asset: ${m.src}`);
          m = this._buildResolvedAsset(m, {
            aliases: c,
            data: o,
            format: a,
            loadParser: l
          }), p.push(m);
        });
      }), c.forEach((f) => {
        this._assetMap[f] = p;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(t) {
    const e = _a(t);
    t = hn(t);
    const i = {};
    return t.forEach((r) => {
      const s = this._bundles[r];
      if (s) {
        const o = this.resolve(s), a = {};
        for (const l in o) {
          const h = o[l];
          a[this._extractAssetIdFromBundle(r, l)] = h;
        }
        i[r] = a;
      }
    }), e ? i[t[0]] : i;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(t) {
    const e = this.resolve(t);
    if (typeof t != "string") {
      const i = {};
      for (const r in e)
        i[r] = e[r].src;
      return i;
    }
    return e.src;
  }
  resolve(t) {
    const e = _a(t);
    t = hn(t);
    const i = {};
    return t.forEach((r) => {
      if (!this._resolverHash[r])
        if (this._assetMap[r]) {
          let s = this._assetMap[r];
          const o = this._getPreferredOrder(s);
          o == null || o.priority.forEach((a) => {
            o.params[a].forEach((l) => {
              const h = s.filter((c) => c[a] ? c[a] === l : !1);
              h.length && (s = h);
            });
          }), this._resolverHash[r] = s[0];
        } else
          this._resolverHash[r] = this._buildResolvedAsset({
            alias: [r],
            src: r
          }, {});
      i[r] = this._resolverHash[r];
    }), e ? i[t[0]] : i;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(t) {
    return !!this._assetMap[t];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(t) {
    return !!this._bundles[t];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[0], r = this._preferredOrder.find((s) => s.params.format.includes(i.format));
      if (r)
        return r;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(t) {
    if (!this._defaultSearchParams)
      return t;
    const e = /\?/.test(t) ? "&" : "?";
    return `${t}${e}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(t, e) {
    const { aliases: i, data: r, loadParser: s, format: o } = e;
    return (this._basePath || this._rootPath) && (t.src = ue.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = i ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...r || {}, ...t.data }, t.loadParser = s ?? t.loadParser, t.format = o ?? t.format ?? px(t.src), t;
  }
}
qr.RETINA_PREFIX = /@([0-9\.]+)x/;
function px(n) {
  return n.split(".").pop().split("?").shift().split("#").shift();
}
const Nh = (n, t) => {
  const e = t.split("?")[1];
  return e && (n += `?${e}`), n;
}, Jm = class As {
  /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   */
  constructor(t, e) {
    this.linkedSheets = [], this._texture = t instanceof ot ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
    const i = parseFloat(e.meta.scale);
    i ? (this.resolution = i, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((t) => {
      this._callback = t, this._batchIndex = 0, this._frameKeys.length <= As.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(t) {
    let e = t;
    const i = As.BATCH_SIZE;
    for (; e - t < i && e < this._frameKeys.length; ) {
      const r = this._frameKeys[e], s = this._frames[r], o = s.frame;
      if (o) {
        let a = null, l = null;
        const h = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, c = new Wt(
          0,
          0,
          Math.floor(h.w) / this.resolution,
          Math.floor(h.h) / this.resolution
        );
        s.rotated ? a = new Wt(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.h) / this.resolution,
          Math.floor(o.w) / this.resolution
        ) : a = new Wt(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        ), s.trimmed !== !1 && s.spriteSourceSize && (l = new Wt(
          Math.floor(s.spriteSourceSize.x) / this.resolution,
          Math.floor(s.spriteSourceSize.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        )), this.textures[r] = new ot({
          source: this.textureSource,
          frame: a,
          orig: c,
          trim: l,
          rotate: s.rotated ? 2 : 0,
          defaultAnchor: s.anchor,
          defaultBorders: s.borders,
          label: r.toString()
        });
      }
      e++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const t = this.data.animations || {};
    for (const e in t) {
      this.animations[e] = [];
      for (let i = 0; i < t[e].length; i++) {
        const r = t[e][i];
        this.animations[e].push(this.textures[r]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * As.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * As.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(t = !1) {
    var e;
    for (const i in this.textures)
      this.textures[i].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) == null || e.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
  }
};
Jm.BATCH_SIZE = 1e3;
let gp = Jm;
const fx = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function Zm(n, t, e) {
  const i = {};
  if (n.forEach((r) => {
    i[r] = t;
  }), Object.keys(t.textures).forEach((r) => {
    i[r] = t.textures[r];
  }), !e) {
    const r = ue.dirname(n[0]);
    t.linkedSheets.forEach((s, o) => {
      const a = Zm([`${r}/${t.data.meta.related_multi_packs[o]}`], s, !0);
      Object.assign(i, a);
    });
  }
  return i;
}
const mx = {
  extension: K.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (n) => n instanceof gp,
    getCacheableAssets: (n, t) => Zm(n, t, !1)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: K.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (n) => {
      const t = n.split("?")[0].split("."), e = t.pop(), i = t.pop();
      return e === "json" && fx.includes(i);
    },
    parse: (n) => {
      var t;
      const e = n.split(".");
      return {
        resolution: parseFloat(((t = qr.RETINA_PREFIX.exec(n)) == null ? void 0 : t[1]) ?? "1"),
        format: e[e.length - 2],
        src: n
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: K.LoadParser,
      priority: Hn.Normal,
      name: "spritesheetLoader"
    },
    async testParse(n, t) {
      return ue.extname(t.src).toLowerCase() === ".json" && !!n.frames;
    },
    async parse(n, t, e) {
      var i, r;
      const {
        texture: s,
        // if user need to use preloaded texture
        imageFilename: o
        // if user need to use custom filename (not from jsonFile.meta.image)
      } = (t == null ? void 0 : t.data) ?? {};
      let a = ue.dirname(t.src);
      a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
      let l;
      if (s instanceof ot)
        l = s;
      else {
        const p = Nh(a + (o ?? n.meta.image), t.src);
        l = (await e.load([p]))[p];
      }
      const h = new gp(
        l.source,
        n
      );
      await h.parse();
      const c = (i = n == null ? void 0 : n.meta) == null ? void 0 : i.related_multi_packs;
      if (Array.isArray(c)) {
        const p = [];
        for (const u of c) {
          if (typeof u != "string")
            continue;
          let m = a + u;
          (r = t.data) != null && r.ignoreMultiPack || (m = Nh(m, t.src), p.push(e.load({
            src: m,
            data: {
              ignoreMultiPack: !0
            }
          })));
        }
        const f = await Promise.all(p);
        h.linkedSheets = f, f.forEach((u) => {
          u.linkedSheets = [h].concat(h.linkedSheets.filter((m) => m !== u));
        });
      }
      return h;
    },
    async unload(n, t, e) {
      await e.unload(n.textureSource._sourceOrigin), n.destroy(!1);
    }
  }
};
xe.add(mx);
const Jl = /* @__PURE__ */ Object.create(null), yp = /* @__PURE__ */ Object.create(null);
function Hc(n, t) {
  let e = yp[n];
  return e === void 0 && (Jl[t] === void 0 && (Jl[t] = 1), yp[n] = e = Jl[t]++), e;
}
let ys;
function $m() {
  return (!ys || ys != null && ys.isContextLost()) && (ys = Bt.get().createCanvas().getContext("webgl", {})), ys;
}
let Go;
function gx() {
  if (!Go) {
    Go = "mediump";
    const n = $m();
    n && n.getShaderPrecisionFormat && (Go = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision ? "highp" : "mediump");
  }
  return Go;
}
function yx(n, t, e) {
  return t ? n : e ? (n = n.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${n}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${n}
        `;
}
function _x(n, t, e) {
  const i = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
  if (n.substring(0, 9) !== "precision") {
    let r = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
    return r === "highp" && i !== "highp" && (r = "mediump"), `precision ${r} float;
${n}`;
  } else if (i !== "highp" && n.substring(0, 15) === "precision highp")
    return n.replace("precision highp", "precision mediump");
  return n;
}
function vx(n, t) {
  return t ? `#version 300 es
${n}` : n;
}
const xx = {}, bx = {};
function wx(n, { name: t = "pixi-program" }, e = !0) {
  t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
  const i = e ? xx : bx;
  return i[t] ? (i[t]++, t += `-${i[t]}`) : i[t] = 1, n.indexOf("#define SHADER_NAME") !== -1 ? n : `${`#define SHADER_NAME ${t}`}
${n}`;
}
function Ax(n, t) {
  return t ? n.replace("#version 300 es", "") : n;
}
const Zl = {
  // strips any version headers..
  stripVersion: Ax,
  // adds precision string if not already present
  ensurePrecision: _x,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: yx,
  // add the program name to the shader
  setProgramName: wx,
  // add the version string to the shader header
  insertVersion: vx
}, $l = /* @__PURE__ */ Object.create(null), tg = class Uh {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(t) {
    t = { ...Uh.defaultOptions, ...t };
    const e = t.fragment.indexOf("#version 300 es") !== -1, i = {
      stripVersion: e,
      ensurePrecision: {
        requestedFragmentPrecision: t.preferredFragmentPrecision,
        requestedVertexPrecision: t.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: gx()
      },
      setProgramName: {
        name: t.name
      },
      addProgramDefines: e,
      insertVersion: e
    };
    let r = t.fragment, s = t.vertex;
    Object.keys(Zl).forEach((o) => {
      const a = i[o];
      r = Zl[o](r, a, !0), s = Zl[o](s, a, !1);
    }), this.fragment = r, this.vertex = s, this._key = Hc(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex}:${t.fragment}`;
    return $l[e] || ($l[e] = new Uh(t)), $l[e];
  }
};
tg.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let eg = tg;
const _p = {
  uint8x2: { size: 2, stride: 2, normalised: !1 },
  uint8x4: { size: 4, stride: 4, normalised: !1 },
  sint8x2: { size: 2, stride: 2, normalised: !1 },
  sint8x4: { size: 4, stride: 4, normalised: !1 },
  unorm8x2: { size: 2, stride: 2, normalised: !0 },
  unorm8x4: { size: 4, stride: 4, normalised: !0 },
  snorm8x2: { size: 2, stride: 2, normalised: !0 },
  snorm8x4: { size: 4, stride: 4, normalised: !0 },
  uint16x2: { size: 2, stride: 4, normalised: !1 },
  uint16x4: { size: 4, stride: 8, normalised: !1 },
  sint16x2: { size: 2, stride: 4, normalised: !1 },
  sint16x4: { size: 4, stride: 8, normalised: !1 },
  unorm16x2: { size: 2, stride: 4, normalised: !0 },
  unorm16x4: { size: 4, stride: 8, normalised: !0 },
  snorm16x2: { size: 2, stride: 4, normalised: !0 },
  snorm16x4: { size: 4, stride: 8, normalised: !0 },
  float16x2: { size: 2, stride: 4, normalised: !1 },
  float16x4: { size: 4, stride: 8, normalised: !1 },
  float32: { size: 1, stride: 4, normalised: !1 },
  float32x2: { size: 2, stride: 8, normalised: !1 },
  float32x3: { size: 3, stride: 12, normalised: !1 },
  float32x4: { size: 4, stride: 16, normalised: !1 },
  uint32: { size: 1, stride: 4, normalised: !1 },
  uint32x2: { size: 2, stride: 8, normalised: !1 },
  uint32x3: { size: 3, stride: 12, normalised: !1 },
  uint32x4: { size: 4, stride: 16, normalised: !1 },
  sint32: { size: 1, stride: 4, normalised: !1 },
  sint32x2: { size: 2, stride: 8, normalised: !1 },
  sint32x3: { size: 3, stride: 12, normalised: !1 },
  sint32x4: { size: 4, stride: 16, normalised: !1 }
};
function Tx(n) {
  return _p[n] ?? _p.float32;
}
const Sx = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function Ex({ source: n, entryPoint: t }) {
  const e = {}, i = n.indexOf(`fn ${t}`);
  if (i !== -1) {
    const r = n.indexOf("->", i);
    if (r !== -1) {
      const s = n.substring(i, r), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let a;
      for (; (a = o.exec(s)) !== null; ) {
        const l = Sx[a[3]] ?? "float32";
        e[a[2]] = {
          location: parseInt(a[1], 10),
          format: l,
          stride: Tx(l).stride,
          offset: 0,
          instance: !1,
          start: 0
        };
      }
    }
  }
  return e;
}
function th(n) {
  var t, e;
  const i = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, r = /@group\((\d+)\)/, s = /@binding\((\d+)\)/, o = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, l = /struct\s+(\w+)\s*{([^}]+)}/g, h = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, p = (t = n.match(i)) == null ? void 0 : t.map((u) => ({
    group: parseInt(u.match(r)[1], 10),
    binding: parseInt(u.match(s)[1], 10),
    name: u.match(o)[2],
    isUniform: u.match(o)[1] === "<uniform>",
    type: u.match(a)[1]
  }));
  if (!p)
    return {
      groups: [],
      structs: []
    };
  const f = ((e = n.match(l)) == null ? void 0 : e.map((u) => {
    const m = u.match(c)[1], g = u.match(h).reduce((y, b) => {
      const [T, C] = b.split(":");
      return y[T.trim()] = C.trim(), y;
    }, {});
    return g ? { name: m, members: g } : null;
  }).filter(({ name: u }) => p.some((m) => m.type === u))) ?? [];
  return {
    groups: p,
    structs: f
  };
}
var Ts = /* @__PURE__ */ ((n) => (n[n.VERTEX = 1] = "VERTEX", n[n.FRAGMENT = 2] = "FRAGMENT", n[n.COMPUTE = 4] = "COMPUTE", n))(Ts || {});
function Cx({ groups: n }) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const i = n[e];
    t[i.group] || (t[i.group] = []), i.isUniform ? t[i.group].push({
      binding: i.binding,
      visibility: Ts.VERTEX | Ts.FRAGMENT,
      buffer: {
        type: "uniform"
      }
    }) : i.type === "sampler" ? t[i.group].push({
      binding: i.binding,
      visibility: Ts.FRAGMENT,
      sampler: {
        type: "filtering"
      }
    }) : i.type === "texture_2d" && t[i.group].push({
      binding: i.binding,
      visibility: Ts.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: !1
      }
    });
  }
  return t;
}
function Px({ groups: n }) {
  const t = [];
  for (let e = 0; e < n.length; e++) {
    const i = n[e];
    t[i.group] || (t[i.group] = {}), t[i.group][i.name] = i.binding;
  }
  return t;
}
function Ix(n, t) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), r = [...n.structs, ...t.structs].filter((o) => e.has(o.name) ? !1 : (e.add(o.name), !0)), s = [...n.groups, ...t.groups].filter((o) => {
    const a = `${o.name}-${o.binding}`;
    return i.has(a) ? !1 : (i.add(a), !0);
  });
  return { structs: r, groups: s };
}
const eh = /* @__PURE__ */ Object.create(null);
class Xa {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(t) {
    var e, i;
    this._layoutKey = 0, this._attributeLocationsKey = 0;
    const { fragment: r, vertex: s, layout: o, gpuLayout: a, name: l } = t;
    if (this.name = l, this.fragment = r, this.vertex = s, r.source === s.source) {
      const h = th(r.source);
      this.structsAndGroups = h;
    } else {
      const h = th(s.source), c = th(r.source);
      this.structsAndGroups = Ix(h, c);
    }
    this.layout = o ?? Px(this.structsAndGroups), this.gpuLayout = a ?? Cx(this.structsAndGroups), this.autoAssignGlobalUniforms = ((e = this.layout[0]) == null ? void 0 : e.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((i = this.layout[1]) == null ? void 0 : i.localUniforms) !== void 0, this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex: t, fragment: e } = this, i = t.source + e.source + t.entryPoint + e.entryPoint;
    this._layoutKey = Hc(i, "program");
  }
  get attributeData() {
    return this._attributeData ?? (this._attributeData = Ex(this.vertex)), this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
    return eh[e] || (eh[e] = new Xa(t)), eh[e];
  }
}
const ng = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>"
], Rx = ng.reduce((n, t) => (n[t] = !0, n), {});
function kx(n, t) {
  switch (n) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * t);
    case "vec3<f32>":
      return new Float32Array(3 * t);
    case "vec4<f32>":
      return new Float32Array(4 * t);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const ig = class rg {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(t, e) {
    this._touched = 0, this.uid = Jt("uniform"), this._resourceType = "uniformGroup", this._resourceId = Jt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = { ...rg.defaultOptions, ...e }, this.uniformStructures = t;
    const i = {};
    for (const r in t) {
      const s = t[r];
      if (s.name = r, s.size = s.size ?? 1, !Rx[s.type])
        throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${ng.join(", ")}`);
      s.value ?? (s.value = kx(s.type, s.size)), i[r] = s.value;
    }
    this.uniforms = i, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = Hc(Object.keys(i).map(
      (r) => `${r}-${t[r].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
ig.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: !1,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: !1
};
let sg = ig;
class ra {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(t) {
    this.resources = /* @__PURE__ */ Object.create(null), this._dirty = !0;
    let e = 0;
    for (const i in t) {
      const r = t[i];
      this.setResource(r, e++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   * @ignore
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = !1;
    const t = [];
    let e = 0;
    for (const i in this.resources)
      t[e++] = this.resources[i]._resourceId;
    this._key = t.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(t, e) {
    var i, r;
    const s = this.resources[e];
    t !== s && (s && ((i = t.off) == null || i.call(t, "change", this.onResourceChange, this)), (r = t.on) == null || r.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0);
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(t) {
    return this.resources[t];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   * @ignore
   */
  _touch(t) {
    const e = this.resources;
    for (const i in e)
      e[i]._touched = t;
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    var t;
    const e = this.resources;
    for (const i in e) {
      const r = e[i];
      (t = r.off) == null || t.call(r, "change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(t) {
    if (this._dirty = !0, t.destroyed) {
      const e = this.resources;
      for (const i in e)
        e[i] === t && (e[i] = null);
    } else
      this._updateKey();
  }
}
var zh = /* @__PURE__ */ ((n) => (n[n.WEBGL = 1] = "WEBGL", n[n.WEBGPU = 2] = "WEBGPU", n[n.BOTH = 3] = "BOTH", n))(zh || {});
class qc extends Ae {
  constructor(t) {
    super(), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
    let {
      gpuProgram: e,
      glProgram: i,
      groups: r,
      resources: s,
      compatibleRenderers: o,
      groupMap: a
    } = t;
    this.gpuProgram = e, this.glProgram = i, o === void 0 && (o = 0, e && (o |= zh.WEBGPU), i && (o |= zh.WEBGL)), this.compatibleRenderers = o;
    const l = {};
    if (!s && !r && (s = {}), s && r)
      throw new Error("[Shader] Cannot have both resources and groups");
    if (!e && r && !a)
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    if (!e && r && a)
      for (const h in a)
        for (const c in a[h]) {
          const p = a[h][c];
          l[p] = {
            group: h,
            binding: c,
            name: p
          };
        }
    else if (e && r && !a) {
      const h = e.structsAndGroups.groups;
      a = {}, h.forEach((c) => {
        a[c.group] = a[c.group] || {}, a[c.group][c.binding] = c.name, l[c.name] = c;
      });
    } else if (s) {
      r = {}, a = {}, e && e.structsAndGroups.groups.forEach((c) => {
        a[c.group] = a[c.group] || {}, a[c.group][c.binding] = c.name, l[c.name] = c;
      });
      let h = 0;
      for (const c in s)
        l[c] || (r[99] || (r[99] = new ra(), this._ownedBindGroups.push(r[99])), l[c] = { group: 99, binding: h, name: c }, a[99] = a[99] || {}, a[99][h] = c, h++);
      for (const c in s) {
        const p = c;
        let f = s[c];
        !f.source && !f._resourceType && (f = new sg(f));
        const u = l[p];
        u && (r[u.group] || (r[u.group] = new ra(), this._ownedBindGroups.push(r[u.group])), r[u.group].setResource(f, u.binding));
      }
    }
    this.groups = r, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(r, l);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(t, e, i) {
    var r, s;
    (r = this._uniformBindMap)[e] || (r[e] = {}), (s = this._uniformBindMap[e])[i] || (s[i] = t), this.groups[e] || (this.groups[e] = new ra(), this._ownedBindGroups.push(this.groups[e]));
  }
  _buildResourceAccessor(t, e) {
    const i = {};
    for (const r in e) {
      const s = e[r];
      Object.defineProperty(i, s.name, {
        get() {
          return t[s.group].getResource(s.binding);
        },
        set(o) {
          t[s.group].setResource(o, s.binding);
        }
      });
    }
    return i;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(t = !1) {
    var e, i;
    this.emit("destroy", this), t && ((e = this.gpuProgram) == null || e.destroy(), (i = this.glProgram) == null || i.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((r) => {
      r.destroy();
    }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
  }
  static from(t) {
    const { gpu: e, gl: i, ...r } = t;
    let s, o;
    return e && (s = Xa.from(e)), i && (o = eg.from(i)), new qc({
      gpuProgram: s,
      glProgram: o,
      ...r
    });
  }
}
const jh = [];
xe.handleByNamedList(K.Environment, jh);
async function Mx(n) {
  if (!n)
    for (let t = 0; t < jh.length; t++) {
      const e = jh[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
}
let _s;
function Vx() {
  if (typeof _s == "boolean")
    return _s;
  try {
    _s = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    _s = !1;
  }
  return _s;
}
var Wc = { exports: {} };
Wc.exports = Ka;
Wc.exports.default = Ka;
function Ka(n, t, e) {
  e = e || 2;
  var i = t && t.length, r = i ? t[0] * e : n.length, s = og(n, 0, r, e, !0), o = [];
  if (!s || s.next === s.prev) return o;
  var a, l, h, c, p, f, u;
  if (i && (s = Lx(n, t, s, e)), n.length > 80 * e) {
    a = h = n[0], l = c = n[1];
    for (var m = e; m < r; m += e)
      p = n[m], f = n[m + 1], p < a && (a = p), f < l && (l = f), p > h && (h = p), f > c && (c = f);
    u = Math.max(h - a, c - l), u = u !== 0 ? 32767 / u : 0;
  }
  return qs(s, o, e, a, l, u, 0), o;
}
function og(n, t, e, i, r) {
  var s, o;
  if (r === qh(n, t, e, i) > 0)
    for (s = t; s < e; s += i) o = vp(s, n[s], n[s + 1], o);
  else
    for (s = e - i; s >= t; s -= i) o = vp(s, n[s], n[s + 1], o);
  return o && Qa(o, o.next) && (Ys(o), o = o.next), o;
}
function Gi(n, t) {
  if (!n) return n;
  t || (t = n);
  var e = n, i;
  do
    if (i = !1, !e.steiner && (Qa(e, e.next) || Vt(e.prev, e, e.next) === 0)) {
      if (Ys(e), e = t = e.prev, e === e.next) break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== t);
  return t;
}
function qs(n, t, e, i, r, s, o) {
  if (n) {
    !o && s && Gx(n, i, r, s);
    for (var a = n, l, h; n.prev !== n.next; ) {
      if (l = n.prev, h = n.next, s ? Bx(n, i, r, s) : Dx(n)) {
        t.push(l.i / e | 0), t.push(n.i / e | 0), t.push(h.i / e | 0), Ys(n), n = h.next, a = h.next;
        continue;
      }
      if (n = h, n === a) {
        o ? o === 1 ? (n = Ox(Gi(n), t, e), qs(n, t, e, i, r, s, 2)) : o === 2 && Fx(n, t, e, i, r, s) : qs(Gi(n), t, e, i, r, s, 1);
        break;
      }
    }
  }
}
function Dx(n) {
  var t = n.prev, e = n, i = n.next;
  if (Vt(t, e, i) >= 0) return !1;
  for (var r = t.x, s = e.x, o = i.x, a = t.y, l = e.y, h = i.y, c = r < s ? r < o ? r : o : s < o ? s : o, p = a < l ? a < h ? a : h : l < h ? l : h, f = r > s ? r > o ? r : o : s > o ? s : o, u = a > l ? a > h ? a : h : l > h ? l : h, m = i.next; m !== t; ) {
    if (m.x >= c && m.x <= f && m.y >= p && m.y <= u && mr(r, a, s, l, o, h, m.x, m.y) && Vt(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function Bx(n, t, e, i) {
  var r = n.prev, s = n, o = n.next;
  if (Vt(r, s, o) >= 0) return !1;
  for (var a = r.x, l = s.x, h = o.x, c = r.y, p = s.y, f = o.y, u = a < l ? a < h ? a : h : l < h ? l : h, m = c < p ? c < f ? c : f : p < f ? p : f, g = a > l ? a > h ? a : h : l > h ? l : h, y = c > p ? c > f ? c : f : p > f ? p : f, b = Gh(u, m, t, e, i), T = Gh(g, y, t, e, i), C = n.prevZ, P = n.nextZ; C && C.z >= b && P && P.z <= T; ) {
    if (C.x >= u && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && mr(a, c, l, p, h, f, C.x, C.y) && Vt(C.prev, C, C.next) >= 0 || (C = C.prevZ, P.x >= u && P.x <= g && P.y >= m && P.y <= y && P !== r && P !== o && mr(a, c, l, p, h, f, P.x, P.y) && Vt(P.prev, P, P.next) >= 0)) return !1;
    P = P.nextZ;
  }
  for (; C && C.z >= b; ) {
    if (C.x >= u && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && mr(a, c, l, p, h, f, C.x, C.y) && Vt(C.prev, C, C.next) >= 0) return !1;
    C = C.prevZ;
  }
  for (; P && P.z <= T; ) {
    if (P.x >= u && P.x <= g && P.y >= m && P.y <= y && P !== r && P !== o && mr(a, c, l, p, h, f, P.x, P.y) && Vt(P.prev, P, P.next) >= 0) return !1;
    P = P.nextZ;
  }
  return !0;
}
function Ox(n, t, e) {
  var i = n;
  do {
    var r = i.prev, s = i.next.next;
    !Qa(r, s) && ag(r, i, i.next, s) && Ws(r, s) && Ws(s, r) && (t.push(r.i / e | 0), t.push(i.i / e | 0), t.push(s.i / e | 0), Ys(i), Ys(i.next), i = n = s), i = i.next;
  } while (i !== n);
  return Gi(i);
}
function Fx(n, t, e, i, r, s) {
  var o = n;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && Wx(o, a)) {
        var l = lg(o, a);
        o = Gi(o, o.next), l = Gi(l, l.next), qs(o, t, e, i, r, s, 0), qs(l, t, e, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function Lx(n, t, e, i) {
  var r = [], s, o, a, l, h;
  for (s = 0, o = t.length; s < o; s++)
    a = t[s] * i, l = s < o - 1 ? t[s + 1] * i : n.length, h = og(n, a, l, i, !1), h === h.next && (h.steiner = !0), r.push(qx(h));
  for (r.sort(Nx), s = 0; s < r.length; s++)
    e = Ux(r[s], e);
  return e;
}
function Nx(n, t) {
  return n.x - t.x;
}
function Ux(n, t) {
  var e = zx(n, t);
  if (!e)
    return t;
  var i = lg(e, n);
  return Gi(i, i.next), Gi(e, e.next);
}
function zx(n, t) {
  var e = t, i = n.x, r = n.y, s = -1 / 0, o;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= i && a > s && (s = a, o = e.x < e.next.x ? e : e.next, a === i))
        return o;
    }
    e = e.next;
  } while (e !== t);
  if (!o) return null;
  var l = o, h = o.x, c = o.y, p = 1 / 0, f;
  e = o;
  do
    i >= e.x && e.x >= h && i !== e.x && mr(r < c ? i : s, r, h, c, r < c ? s : i, r, e.x, e.y) && (f = Math.abs(r - e.y) / (i - e.x), Ws(e, n) && (f < p || f === p && (e.x > o.x || e.x === o.x && jx(o, e))) && (o = e, p = f)), e = e.next;
  while (e !== l);
  return o;
}
function jx(n, t) {
  return Vt(n.prev, n, t.prev) < 0 && Vt(t.next, n, n.next) < 0;
}
function Gx(n, t, e, i) {
  var r = n;
  do
    r.z === 0 && (r.z = Gh(r.x, r.y, t, e, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n);
  r.prevZ.nextZ = null, r.prevZ = null, Hx(r);
}
function Hx(n) {
  var t, e, i, r, s, o, a, l, h = 1;
  do {
    for (e = n, n = null, s = null, o = 0; e; ) {
      for (o++, i = e, a = 0, t = 0; t < h && (a++, i = i.nextZ, !!i); t++)
        ;
      for (l = h; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || e.z <= i.z) ? (r = e, e = e.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
      e = i;
    }
    s.nextZ = null, h *= 2;
  } while (o > 1);
  return n;
}
function Gh(n, t, e, i, r) {
  return n = (n - e) * r | 0, t = (t - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n | t << 1;
}
function qx(n) {
  var t = n, e = n;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== n);
  return e;
}
function mr(n, t, e, i, r, s, o, a) {
  return (r - o) * (t - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (r - o) * (i - a);
}
function Wx(n, t) {
  return n.next.i !== t.i && n.prev.i !== t.i && !Yx(n, t) && // dones't intersect other edges
  (Ws(n, t) && Ws(t, n) && Xx(n, t) && // locally visible
  (Vt(n.prev, n, t.prev) || Vt(n, t.prev, t)) || // does not create opposite-facing sectors
  Qa(n, t) && Vt(n.prev, n, n.next) > 0 && Vt(t.prev, t, t.next) > 0);
}
function Vt(n, t, e) {
  return (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y);
}
function Qa(n, t) {
  return n.x === t.x && n.y === t.y;
}
function ag(n, t, e, i) {
  var r = qo(Vt(n, t, e)), s = qo(Vt(n, t, i)), o = qo(Vt(e, i, n)), a = qo(Vt(e, i, t));
  return !!(r !== s && o !== a || r === 0 && Ho(n, e, t) || s === 0 && Ho(n, i, t) || o === 0 && Ho(e, n, i) || a === 0 && Ho(e, t, i));
}
function Ho(n, t, e) {
  return t.x <= Math.max(n.x, e.x) && t.x >= Math.min(n.x, e.x) && t.y <= Math.max(n.y, e.y) && t.y >= Math.min(n.y, e.y);
}
function qo(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function Yx(n, t) {
  var e = n;
  do {
    if (e.i !== n.i && e.next.i !== n.i && e.i !== t.i && e.next.i !== t.i && ag(e, e.next, n, t)) return !0;
    e = e.next;
  } while (e !== n);
  return !1;
}
function Ws(n, t) {
  return Vt(n.prev, n, n.next) < 0 ? Vt(n, t, n.next) >= 0 && Vt(n, n.prev, t) >= 0 : Vt(n, t, n.prev) < 0 || Vt(n, n.next, t) < 0;
}
function Xx(n, t) {
  var e = n, i = !1, r = (n.x + t.x) / 2, s = (n.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== n);
  return i;
}
function lg(n, t) {
  var e = new Hh(n.i, n.x, n.y), i = new Hh(t.i, t.x, t.y), r = n.next, s = t.prev;
  return n.next = t, t.prev = n, e.next = r, r.prev = e, i.next = e, e.prev = i, s.next = i, i.prev = s, i;
}
function vp(n, t, e, i) {
  var r = new Hh(n, t, e);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function Ys(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function Hh(n, t, e) {
  this.i = n, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Ka.deviation = function(n, t, e, i) {
  var r = t && t.length, s = r ? t[0] * e : n.length, o = Math.abs(qh(n, 0, s, e));
  if (r)
    for (var a = 0, l = t.length; a < l; a++) {
      var h = t[a] * e, c = a < l - 1 ? t[a + 1] * e : n.length;
      o -= Math.abs(qh(n, h, c, e));
    }
  var p = 0;
  for (a = 0; a < i.length; a += 3) {
    var f = i[a] * e, u = i[a + 1] * e, m = i[a + 2] * e;
    p += Math.abs(
      (n[f] - n[m]) * (n[u + 1] - n[f + 1]) - (n[f] - n[u]) * (n[m + 1] - n[f + 1])
    );
  }
  return o === 0 && p === 0 ? 0 : Math.abs((p - o) / o);
};
function qh(n, t, e, i) {
  for (var r = 0, s = t, o = e - i; s < e; s += i)
    r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
  return r;
}
Ka.flatten = function(n) {
  for (var t = n[0][0].length, e = { vertices: [], holes: [], dimensions: t }, i = 0, r = 0; r < n.length; r++) {
    for (var s = 0; s < n[r].length; s++)
      for (var o = 0; o < t; o++) e.vertices.push(n[r][s][o]);
    r > 0 && (i += n[r - 1].length, e.holes.push(i));
  }
  return e;
};
var Kx = Wc.exports;
const Qx = /* @__PURE__ */ zc(Kx);
var hg = /* @__PURE__ */ ((n) => (n[n.NONE = 0] = "NONE", n[n.COLOR = 16384] = "COLOR", n[n.STENCIL = 1024] = "STENCIL", n[n.DEPTH = 256] = "DEPTH", n[n.COLOR_DEPTH = 16640] = "COLOR_DEPTH", n[n.COLOR_STENCIL = 17408] = "COLOR_STENCIL", n[n.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", n[n.ALL = 17664] = "ALL", n))(hg || {});
class Jx {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(t) {
    this.items = [], this._name = t;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(t, e, i, r, s, o, a, l) {
    const { name: h, items: c } = this;
    for (let p = 0, f = c.length; p < f; p++)
      c[p][h](t, e, i, r, s, o, a, l);
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(t) {
    return t[this._name] && (this.remove(t), this.items.push(t)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(t) {
    const e = this.items.indexOf(t);
    return e !== -1 && this.items.splice(e, 1), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(t) {
    return this.items.indexOf(t) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const Zx = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "reset",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
], cg = class ug extends Ae {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(t) {
    super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
    const e = [...Zx, ...this.config.runners ?? []];
    this._addRunners(...e), this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(t = {}) {
    const e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1;
    await Mx(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const i in this._systemsHash)
      t = { ...this._systemsHash[i].constructor.defaultOptions, ...t };
    t = { ...ug.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0;
    for (let i = 0; i < this.runners.init.items.length; i++)
      await this.runners.init.items[i].init(t);
    this._initOptions = t;
  }
  render(t, e) {
    let i = t;
    if (i instanceof Ie && (i = { container: i }, e && (mt(gt, "passing a second argument is deprecated, please use render options instead"), i.target = e.renderTexture)), i.target || (i.target = this.view.renderTarget), i.target === this.view.renderTarget && (this._lastObjectRendered = i.container, i.clearColor = this.background.colorRgba), i.clearColor) {
      const r = Array.isArray(i.clearColor) && i.clearColor.length === 4;
      i.clearColor = r ? i.clearColor : Yt.shared.setValue(i.clearColor).toArray();
    }
    i.transform || (i.container.updateLocalTransform(), i.transform = i.container.localTransform), this.runners.prerender.emit(i), this.runners.renderStart.emit(i), this.runners.render.emit(i), this.runners.renderEnd.emit(i), this.runners.postrender.emit(i);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(t, e, i) {
    const r = this.view.resolution;
    this.view.resize(t, e, i), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), i !== void 0 && i !== r && this.runners.resolutionChange.emit(i);
  }
  clear(t = {}) {
    const e = this;
    t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = hg.ALL);
    const { clear: i, clearColor: r, target: s } = t;
    Yt.shared.setValue(r ?? this.background.colorRgba), e.renderTarget.clear(s, i, Yt.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(t) {
    this.view.resolution = t, this.runners.resolutionChange.emit(t);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    return this.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...t) {
    t.forEach((e) => {
      this.runners[e] = new Jx(e);
    });
  }
  _addSystems(t) {
    let e;
    for (e in t) {
      const i = t[e];
      this._addSystem(i.value, i.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(t, e) {
    const i = new t(this);
    if (this[e])
      throw new Error(`Whoops! The name "${e}" is already in use`);
    this[e] = i, this._systemsHash[e] = i;
    for (const r in this.runners)
      this.runners[r].add(i);
    return this;
  }
  _addPipes(t, e) {
    const i = e.reduce((r, s) => (r[s.name] = s.value, r), {});
    t.forEach((r) => {
      const s = r.value, o = r.name, a = i[o];
      this.renderPipes[o] = new s(
        this,
        a ? new a() : null
      );
    });
  }
  destroy(t = !1) {
    this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
      e.destroy();
    }), this._systemsHash = null, this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(t) {
    return this.textureGenerator.generateTexture(t);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!Vx())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
};
cg.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: !1,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: !1
};
let dg = cg, nh;
function $x(n) {
  return nh !== void 0 || (nh = (() => {
    var t;
    const e = {
      stencil: !0,
      failIfMajorPerformanceCaveat: n ?? dg.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!Bt.get().getWebGLRenderingContext())
        return !1;
      let i = Bt.get().createCanvas().getContext("webgl", e);
      const r = !!((t = i == null ? void 0 : i.getContextAttributes()) != null && t.stencil);
      if (i) {
        const s = i.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return i = null, r;
    } catch {
      return !1;
    }
  })()), nh;
}
let ih;
async function tb(n = {}) {
  return ih !== void 0 || (ih = await (async () => {
    const t = Bt.get().getNavigator().gpu;
    if (!t)
      return !1;
    try {
      return await (await t.requestAdapter(n)).requestDevice(), !0;
    } catch {
      return !1;
    }
  })()), ih;
}
const xp = ["webgl", "webgpu", "canvas"];
async function eb(n) {
  let t = [];
  n.preference ? (t.push(n.preference), xp.forEach((s) => {
    s !== n.preference && t.push(s);
  })) : t = xp.slice();
  let e, i = {};
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    if (o === "webgpu" && await tb()) {
      const { WebGPURenderer: a } = await import("./WebGPURenderer-CFR6AS1D-DDW9BpWv.js");
      e = a, i = { ...n, ...n.webgpu };
      break;
    } else if (o === "webgl" && $x(
      n.failIfMajorPerformanceCaveat ?? dg.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: a } = await import("./WebGLRenderer-Di-BqfWs-Cwl7Y4IX.js");
      e = a, i = { ...n, ...n.webgl };
      break;
    } else if (o === "canvas")
      throw i = { ...n }, new Error("CanvasRenderer is not yet implemented");
  }
  if (delete i.webgpu, delete i.webgl, !e)
    throw new Error("No available renderer for the current environment");
  const r = new e();
  return await r.init(i), r;
}
const pg = "8.5.2";
class fg {
  static init() {
    var t;
    (t = globalThis.__PIXI_APP_INIT__) == null || t.call(globalThis, this, pg);
  }
  static destroy() {
  }
}
fg.extension = K.Application;
class nb {
  constructor(t) {
    this._renderer = t;
  }
  init() {
    var t;
    (t = globalThis.__PIXI_RENDERER_INIT__) == null || t.call(globalThis, this._renderer, pg);
  }
  destroy() {
    this._renderer = null;
  }
}
nb.extension = {
  type: [
    K.WebGLSystem,
    K.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const mg = class Wh {
  /** @ignore */
  constructor(...t) {
    this.stage = new Ie(), t[0] !== void 0 && mt(gt, "Application constructor options are deprecated, please use Application.init() instead.");
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(t) {
    t = { ...t }, this.renderer = await eb(t), Wh._plugins.forEach((e) => {
      e.init.call(this, t);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   * @member {HTMLCanvasElement}
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */
  get view() {
    return mt(gt, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(t = !1, e = !1) {
    const i = Wh._plugins.slice(0);
    i.reverse(), i.forEach((r) => {
      r.destroy.call(this);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }
};
mg._plugins = [];
let gg = mg;
xe.handleByList(K.Application, gg._plugins);
xe.add(fg);
class yg extends Ae {
  constructor() {
    super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    return mt(gt, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    return mt(gt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    return mt(gt, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    return mt(gt, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    return mt(gt, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
  }
  destroy(t = !1) {
    var e;
    this.emit("destroy", this), this.removeAllListeners();
    for (const i in this.chars)
      (e = this.chars[i].texture) == null || e.destroy();
    this.chars = null, t && (this.pages.forEach((i) => i.texture.destroy(!0)), this.pages = null);
  }
}
const _g = class Yh {
  constructor(t, e, i, r) {
    this.uid = Jt("fillGradient"), this.type = "linear", this.gradientStops = [], this._styleKey = null, this.x0 = t, this.y0 = e, this.x1 = i, this.y1 = r;
  }
  addColorStop(t, e) {
    return this.gradientStops.push({ offset: t, color: Yt.shared.setValue(e).toHexa() }), this._styleKey = null, this;
  }
  // TODO move to the system!
  buildLinearGradient() {
    const t = Yh.defaultTextureSize, { gradientStops: e } = this, i = Bt.get().createCanvas();
    i.width = t, i.height = t;
    const r = i.getContext("2d"), s = r.createLinearGradient(0, 0, Yh.defaultTextureSize, 1);
    for (let g = 0; g < e.length; g++) {
      const y = e[g];
      s.addColorStop(y.offset, y.color);
    }
    r.fillStyle = s, r.fillRect(0, 0, t, t), this.texture = new ot({
      source: new Hr({
        resource: i,
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      })
    });
    const { x0: o, y0: a, x1: l, y1: h } = this, c = new ft(), p = l - o, f = h - a, u = Math.sqrt(p * p + f * f), m = Math.atan2(f, p);
    c.translate(-o, -a), c.scale(1 / t, 1 / t), c.rotate(-m), c.scale(256 / u, 1), this.transform = c, this._styleKey = null;
  }
  get styleKey() {
    if (this._styleKey)
      return this._styleKey;
    const t = this.gradientStops.map((r) => `${r.offset}-${r.color}`).join("-"), e = this.texture.uid, i = this.transform.toArray().join("-");
    return `fill-gradient-${this.uid}-${t}-${e}-${i}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
  }
};
_g.defaultTextureSize = 256;
let Xs = _g;
const bp = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class Ja {
  constructor(t, e) {
    this.uid = Jt("fillPattern"), this.transform = new ft(), this._styleKey = null, this.texture = t, this.transform.scale(
      1 / t.frame.width,
      1 / t.frame.height
    ), e && (t.source.style.addressModeU = bp[e].addressModeU, t.source.style.addressModeV = bp[e].addressModeV);
  }
  setTransform(t) {
    const e = this.texture;
    this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(
      1 / e.frame.width,
      1 / e.frame.height
    ), this._styleKey = null;
  }
  get styleKey() {
    return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
  }
}
var ib = sb, rh = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, rb = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function sb(n) {
  var t = [];
  return n.replace(rb, function(e, i, r) {
    var s = i.toLowerCase();
    for (r = ab(r), s == "m" && r.length > 2 && (t.push([i].concat(r.splice(0, 2))), s = "l", i = i == "m" ? "l" : "L"); ; ) {
      if (r.length == rh[s])
        return r.unshift(i), t.push(r);
      if (r.length < rh[s]) throw new Error("malformed path data");
      t.push([i].concat(r.splice(0, rh[s])));
    }
  }), t;
}
var ob = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function ab(n) {
  var t = n.match(ob);
  return t ? t.map(Number) : [];
}
const lb = /* @__PURE__ */ zc(ib);
function hb(n, t) {
  const e = lb(n), i = [];
  let r = null, s = 0, o = 0;
  for (let a = 0; a < e.length; a++) {
    const l = e[a], h = l[0], c = l;
    switch (h) {
      case "M":
        s = c[1], o = c[2], t.moveTo(s, o);
        break;
      case "m":
        s += c[1], o += c[2], t.moveTo(s, o);
        break;
      case "H":
        s = c[1], t.lineTo(s, o);
        break;
      case "h":
        s += c[1], t.lineTo(s, o);
        break;
      case "V":
        o = c[1], t.lineTo(s, o);
        break;
      case "v":
        o += c[1], t.lineTo(s, o);
        break;
      case "L":
        s = c[1], o = c[2], t.lineTo(s, o);
        break;
      case "l":
        s += c[1], o += c[2], t.lineTo(s, o);
        break;
      case "C":
        s = c[5], o = c[6], t.bezierCurveTo(
          c[1],
          c[2],
          c[3],
          c[4],
          s,
          o
        );
        break;
      case "c":
        t.bezierCurveTo(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4],
          s + c[5],
          o + c[6]
        ), s += c[5], o += c[6];
        break;
      case "S":
        s = c[3], o = c[4], t.bezierCurveToShort(
          c[1],
          c[2],
          s,
          o
        );
        break;
      case "s":
        t.bezierCurveToShort(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4]
        ), s += c[3], o += c[4];
        break;
      case "Q":
        s = c[3], o = c[4], t.quadraticCurveTo(
          c[1],
          c[2],
          s,
          o
        );
        break;
      case "q":
        t.quadraticCurveTo(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4]
        ), s += c[3], o += c[4];
        break;
      case "T":
        s = c[1], o = c[2], t.quadraticCurveToShort(
          s,
          o
        );
        break;
      case "t":
        s += c[1], o += c[2], t.quadraticCurveToShort(
          s,
          o
        );
        break;
      case "A":
        s = c[6], o = c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          s,
          o
        );
        break;
      case "a":
        s += c[6], o += c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          s,
          o
        );
        break;
      case "Z":
      case "z":
        t.closePath(), i.length > 0 && (r = i.pop(), r ? (s = r.startX, o = r.startY) : (s = 0, o = 0)), r = null;
        break;
      default:
        jt(`Unknown SVG path command: ${h}`);
    }
    h !== "Z" && h !== "z" && r === null && (r = { startX: s, startY: o }, i.push(r));
  }
  return t;
}
class Za {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(t = 0, e = 0, i = 0) {
    this.type = "circle", this.x = t, this.y = e, this.radius = i;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Za(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(t, e) {
    if (this.radius <= 0)
      return !1;
    const i = this.radius * this.radius;
    let r = this.x - t, s = this.y - e;
    return r *= r, s *= s, r + s <= i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @returns Whether the x/y coordinates are within this Circle
   */
  strokeContains(t, e, i) {
    if (this.radius === 0)
      return !1;
    const r = this.x - t, s = this.y - e, o = this.radius, a = i / 2, l = Math.sqrt(r * r + s * s);
    return l < o + a && l > o - a;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Wt(), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
  }
  /**
   * Copies another circle to this one.
   * @param circle - The circle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @param circle - The circle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class Yc {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(t = 0, e = 0, i = 0, r = 0) {
    this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = i, this.halfHeight = r;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {Ellipse} A copy of the ellipse
   */
  clone() {
    return new Yc(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(t, e) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let i = (t - this.x) / this.halfWidth, r = (e - this.y) / this.halfHeight;
    return i *= i, r *= r, i + r <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width
   * @returns Whether the x/y coords are within this ellipse
   */
  strokeContains(t, e, i) {
    const { halfWidth: r, halfHeight: s } = this;
    if (r <= 0 || s <= 0)
      return !1;
    const o = i / 2, a = r - o, l = s - o, h = r + o, c = s + o, p = t - this.x, f = e - this.y, u = p * p / (a * a) + f * f / (l * l), m = p * p / (h * h) + f * f / (c * c);
    return u > 1 && m <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Wt(), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
  }
  /**
   * Copies another ellipse to this one.
   * @param ellipse - The ellipse to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @param ellipse - The ellipse to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function cb(n, t, e, i, r, s) {
  const o = n - e, a = t - i, l = r - e, h = s - i, c = o * l + a * h, p = l * l + h * h;
  let f = -1;
  p !== 0 && (f = c / p);
  let u, m;
  f < 0 ? (u = e, m = i) : f > 1 ? (u = r, m = s) : (u = e + f * l, m = i + f * h);
  const g = n - u, y = t - m;
  return g * g + y * y;
}
class vr {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...t) {
    this.type = "polygon";
    let e = Array.isArray(t[0]) ? t[0] : t;
    if (typeof e[0] != "number") {
      const i = [];
      for (let r = 0, s = e.length; r < s; r++)
        i.push(e[r].x, e[r].y);
      e = i;
    }
    this.points = e, this.closePath = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const t = this.points.slice(), e = new vr(t);
    return e.closePath = this.closePath, e;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(t, e) {
    let i = !1;
    const r = this.points.length / 2;
    for (let s = 0, o = r - 1; s < r; o = s++) {
      const a = this.points[s * 2], l = this.points[s * 2 + 1], h = this.points[o * 2], c = this.points[o * 2 + 1];
      l > e != c > e && t < (h - a) * ((e - l) / (c - l)) + a && (i = !i);
    }
    return i;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this polygon
   */
  strokeContains(t, e, i) {
    const r = i / 2, s = r * r, { points: o } = this, a = o.length - (this.closePath ? 0 : 2);
    for (let l = 0; l < a; l += 2) {
      const h = o[l], c = o[l + 1], p = o[(l + 2) % o.length], f = o[(l + 3) % o.length];
      if (cb(t, e, h, c, p, f) <= s)
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    t = t || new Wt();
    const e = this.points;
    let i = 1 / 0, r = -1 / 0, s = 1 / 0, o = -1 / 0;
    for (let a = 0, l = e.length; a < l; a += 2) {
      const h = e[a], c = e[a + 1];
      i = h < i ? h : i, r = h > r ? h : r, s = c < s ? c : s, o = c > o ? c : o;
    }
    return t.x = i, t.width = r - i, t.y = s, t.height = o - s, t;
  }
  /**
   * Copies another polygon to this one.
   * @param polygon - The polygon to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.points = t.points.slice(), this.closePath = t.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @param polygon - The polygon to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon
   * @readonly
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon
   * @readonly
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon
   * @readonly
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the first Y coordinate of the polygon
   * @readonly
   */
  get y() {
    return this.points[this.points.length - 1];
  }
}
const Wo = (n, t, e, i, r, s) => {
  const o = n - e, a = t - i, l = Math.sqrt(o * o + a * a);
  return l >= r - s && l <= r + s;
};
class $a {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(t = 0, e = 0, i = 0, r = 0, s = 20) {
    this.type = "roundedRectangle", this.x = t, this.y = e, this.width = i, this.height = r, this.radius = s;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new Wt(), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new $a(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + i && e <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
        return !0;
      let r = t - (this.x + i), s = e - (this.y + i);
      const o = i * i;
      if (r * r + s * s <= o || (r = t - (this.x + this.width - i), r * r + s * s <= o) || (s = e - (this.y + this.height - i), r * r + s * s <= o) || (r = t - (this.x + i), r * r + s * s <= o))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, i) {
    const { x: r, y: s, width: o, height: a, radius: l } = this, h = i / 2, c = r + l, p = s + l, f = o - l * 2, u = a - l * 2, m = r + o, g = s + a;
    return (t >= r - h && t <= r + h || t >= m - h && t <= m + h) && e >= p && e <= p + u || (e >= s - h && e <= s + h || e >= g - h && e <= g + h) && t >= c && t <= c + f ? !0 : (
      // Top-left
      t < c && e < p && Wo(t, e, c, p, l, h) || t > m - l && e < p && Wo(t, e, m - l, p, l, h) || t > m - l && e > g - l && Wo(t, e, m - l, g - l, l, h) || t < c && e > g - l && Wo(t, e, c, g - l, l, h)
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const ub = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function db(n) {
  let t = "";
  for (let e = 0; e < n; ++e)
    e > 0 && (t += `
else `), e < n - 1 && (t += `if(test == ${e}.0){}`);
  return t;
}
function pb(n, t) {
  if (n === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const e = t.createShader(t.FRAGMENT_SHADER);
  try {
    for (; ; ) {
      const i = ub.replace(/%forloop%/gi, db(n));
      if (t.shaderSource(e, i), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
        n = n / 2 | 0;
      else
        break;
    }
  } finally {
    t.deleteShader(e);
  }
  return n;
}
let ar = null;
function vg() {
  var n;
  if (ar)
    return ar;
  const t = $m();
  return ar = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), ar = pb(
    ar,
    t
  ), (n = t.getExtension("WEBGL_lose_context")) == null || n.loseContext(), ar;
}
const xg = {};
function fb(n, t) {
  let e = 2166136261;
  for (let i = 0; i < t; i++)
    e ^= n[i].uid, e = Math.imul(e, 16777619), e >>>= 0;
  return xg[e] || mb(n, t, e);
}
let sh = 0;
function mb(n, t, e) {
  const i = {};
  let r = 0;
  sh || (sh = vg());
  for (let o = 0; o < sh; o++) {
    const a = o < t ? n[o] : ot.EMPTY.source;
    i[r++] = a.source, i[r++] = a.style;
  }
  const s = new ra(i);
  return xg[e] = s, s;
}
class wp {
  constructor(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(t) {
    return this[`${t}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${t} isn't a valid view type`);
    }
  }
}
function Ap(n, t) {
  const e = n.byteLength / 8 | 0, i = new Float64Array(n, 0, e);
  new Float64Array(t, 0, e).set(i);
  const r = n.byteLength - e * 8;
  if (r > 0) {
    const s = new Uint8Array(n, e * 8, r);
    new Uint8Array(t, e * 8, r).set(s);
  }
}
const gb = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var yb = /* @__PURE__ */ ((n) => (n[n.DISABLED = 0] = "DISABLED", n[n.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", n[n.MASK_ACTIVE = 2] = "MASK_ACTIVE", n[n.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", n[n.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", n[n.NONE = 5] = "NONE", n))(yb || {});
function Tp(n, t) {
  return t.alphaMode === "no-premultiply-alpha" && gb[n] || n;
}
class _b {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let t = 0; t < this.count; t++) {
      const e = this.textures[t];
      this.textures[t] = null, this.ids[e.uid] = null;
    }
    this.count = 0;
  }
}
class vb {
  constructor() {
    this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new _b(), this.blendMode = "normal", this.canBundle = !0;
  }
  destroy() {
    this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
  }
}
const bg = [];
let Xh = 0;
function Sp() {
  return Xh > 0 ? bg[--Xh] : new vb();
}
function Ep(n) {
  bg[Xh++] = n;
}
let vs = 0;
const wg = class sa {
  constructor(t = {}) {
    this.uid = Jt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], sa.defaultOptions.maxTextures = sa.defaultOptions.maxTextures ?? vg(), t = { ...sa.defaultOptions, ...t };
    const { maxTextures: e, attributesInitialSize: i, indicesInitialSize: r } = t;
    this.attributeBuffer = new wp(i * 4), this.indexBuffer = new Uint16Array(r), this.maxTextures = e;
  }
  begin() {
    this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
    for (let t = 0; t < this.batchIndex; t++)
      Ep(this.batches[t]);
    this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
  }
  add(t) {
    this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(t, e) {
    const i = t._batch.textures.ids[e._source.uid];
    return !i && i !== 0 ? !1 : (t._textureId = i, t.texture = e, !0);
  }
  updateElement(t) {
    this.dirty = !0;
    const e = this.attributeBuffer;
    t.packAsQuad ? this.packQuadAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    ) : this.packAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    );
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(t) {
    const e = this._elements;
    if (!e[this.elementStart])
      return;
    let i = Sp(), r = i.textures;
    r.clear();
    const s = e[this.elementStart];
    let o = Tp(s.blendMode, s.texture._source);
    this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
    const a = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, h = this.indexBuffer;
    let c = this._batchIndexSize, p = this._batchIndexStart, f = "startBatch";
    const u = this.maxTextures;
    for (let m = this.elementStart; m < this.elementSize; ++m) {
      const g = e[m];
      e[m] = null;
      const y = g.texture._source, b = Tp(g.blendMode, y), T = o !== b;
      if (y._batchTick === vs && !T) {
        g._textureId = y._textureBindLocation, c += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(
          g,
          a,
          l,
          g._attributeStart,
          g._textureId
        ), this.packQuadIndex(
          h,
          g._indexStart,
          g._attributeStart / this.vertexSize
        )) : (this.packAttributes(
          g,
          a,
          l,
          g._attributeStart,
          g._textureId
        ), this.packIndex(
          g,
          h,
          g._indexStart,
          g._attributeStart / this.vertexSize
        )), g._batch = i;
        continue;
      }
      y._batchTick = vs, (r.count >= u || T) && (this._finishBatch(
        i,
        p,
        c - p,
        r,
        o,
        t,
        f
      ), f = "renderBatch", p = c, o = b, i = Sp(), r = i.textures, r.clear(), ++vs), g._textureId = y._textureBindLocation = r.count, r.ids[y.uid] = r.count, r.textures[r.count++] = y, g._batch = i, c += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(
        g,
        a,
        l,
        g._attributeStart,
        g._textureId
      ), this.packQuadIndex(
        h,
        g._indexStart,
        g._attributeStart / this.vertexSize
      )) : (this.packAttributes(
        g,
        a,
        l,
        g._attributeStart,
        g._textureId
      ), this.packIndex(
        g,
        h,
        g._indexStart,
        g._attributeStart / this.vertexSize
      ));
    }
    r.count > 0 && (this._finishBatch(
      i,
      p,
      c - p,
      r,
      o,
      t,
      f
    ), p = c, ++vs), this.elementStart = this.elementSize, this._batchIndexStart = p, this._batchIndexSize = c;
  }
  _finishBatch(t, e, i, r, s, o, a) {
    t.gpuBindGroup = null, t.bindGroup = null, t.action = a, t.batcher = this, t.textures = r, t.blendMode = s, t.start = e, t.size = i, ++vs, this.batches[this.batchIndex++] = t, o.add(t);
  }
  finish(t) {
    this.break(t);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(t) {
    t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(t) {
    t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
  }
  _resizeAttributeBuffer(t) {
    const e = Math.max(t, this.attributeBuffer.size * 2), i = new wp(e);
    Ap(this.attributeBuffer.rawBinaryData, i.rawBinaryData), this.attributeBuffer = i;
  }
  _resizeIndexBuffer(t) {
    const e = this.indexBuffer;
    let i = Math.max(t, e.length * 1.5);
    i += i % 2;
    const r = i > 65535 ? new Uint32Array(i) : new Uint16Array(i);
    if (r.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
      for (let s = 0; s < e.length; s++)
        r[s] = e[s];
    else
      Ap(e.buffer, r.buffer);
    this.indexBuffer = r;
  }
  packQuadIndex(t, e, i) {
    t[e] = i + 0, t[e + 1] = i + 1, t[e + 2] = i + 2, t[e + 3] = i + 0, t[e + 4] = i + 2, t[e + 5] = i + 3;
  }
  packIndex(t, e, i, r) {
    const s = t.indices, o = t.indexSize, a = t.indexOffset, l = t.attributeOffset;
    for (let h = 0; h < o; h++)
      e[i++] = r + s[h + a] - l;
  }
  destroy() {
    for (let t = 0; t < this.batches.length; t++)
      Ep(this.batches[t]);
    this.batches = null;
    for (let t = 0; t < this._elements.length; t++)
      this._elements[t]._batch = null;
    this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
  }
};
wg.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let xb = wg;
var Me = /* @__PURE__ */ ((n) => (n[n.MAP_READ = 1] = "MAP_READ", n[n.MAP_WRITE = 2] = "MAP_WRITE", n[n.COPY_SRC = 4] = "COPY_SRC", n[n.COPY_DST = 8] = "COPY_DST", n[n.INDEX = 16] = "INDEX", n[n.VERTEX = 32] = "VERTEX", n[n.UNIFORM = 64] = "UNIFORM", n[n.STORAGE = 128] = "STORAGE", n[n.INDIRECT = 256] = "INDIRECT", n[n.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", n[n.STATIC = 1024] = "STATIC", n))(Me || {});
class Ks extends Ae {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(t) {
    let { data: e, size: i } = t;
    const { usage: r, label: s, shrinkToFit: o } = t;
    super(), this.uid = Jt("buffer"), this._resourceType = "buffer", this._resourceId = Jt("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, i = i ?? (e == null ? void 0 : e.byteLength);
    const a = !!e;
    this.descriptor = {
      size: i,
      usage: r,
      mappedAtCreation: a,
      label: s
    }, this.shrinkToFit = o ?? !0;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(t) {
    this.setDataWithSize(t, t.length, !0);
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & Me.STATIC);
  }
  set static(t) {
    t ? this.descriptor.usage |= Me.STATIC : this.descriptor.usage &= ~Me.STATIC;
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(t, e, i) {
    if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
      i && this.emit("update", this);
      return;
    }
    const r = this._data;
    if (this._data = t, r.length !== t.length) {
      !this.shrinkToFit && t.byteLength < r.byteLength ? i && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Jt("resource"), this.emit("change", this));
      return;
    }
    i && this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(t) {
    this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
  }
}
function Ag(n, t) {
  if (!(n instanceof Ks)) {
    let e = t ? Me.INDEX : Me.VERTEX;
    n instanceof Array && (t ? (n = new Uint32Array(n), e = Me.INDEX | Me.COPY_DST) : (n = new Float32Array(n), e = Me.VERTEX | Me.COPY_DST)), n = new Ks({
      data: n,
      label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: e
    });
  }
  return n;
}
function bb(n, t, e) {
  const i = n.getAttribute(t);
  if (!i)
    return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
  const r = i.buffer.data;
  let s = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0;
  const h = r.BYTES_PER_ELEMENT, c = (i.offset || 0) / h, p = (i.stride || 2 * 4) / h;
  for (let f = c; f < r.length; f += p) {
    const u = r[f], m = r[f + 1];
    u > a && (a = u), m > l && (l = m), u < s && (s = u), m < o && (o = m);
  }
  return e.minX = s, e.minY = o, e.maxX = a, e.maxY = l, e;
}
function wb(n) {
  return (n instanceof Ks || Array.isArray(n) || n.BYTES_PER_ELEMENT) && (n = {
    buffer: n
  }), n.buffer = Ag(n.buffer, !1), n;
}
class Ab extends Ae {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(t = {}) {
    super(), this.uid = Jt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new oi(), this._boundsDirty = !0;
    const { attributes: e, indexBuffer: i, topology: r } = t;
    if (this.buffers = [], this.attributes = {}, e)
      for (const s in e)
        this.addAttribute(s, e[s]);
    this.instanceCount = t.instanceCount || 1, i && this.addIndex(i), this.topology = r || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = !0, this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(t) {
    return this.getAttribute(t).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const t in this.attributes) {
      const e = this.attributes[t];
      return e.buffer.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(t, e) {
    const i = wb(e);
    this.buffers.indexOf(i.buffer) === -1 && (this.buffers.push(i.buffer), i.buffer.on("update", this.onBufferUpdate, this), i.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = i;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(t) {
    this.indexBuffer = Ag(t, !0), this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    return this._boundsDirty ? (this._boundsDirty = !1, bb(this, "aPosition", this._bounds)) : this._bounds;
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(t = !1) {
    this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
  }
}
const Tb = new Float32Array(1), Sb = new Uint32Array(1);
class Eb extends Ab {
  constructor() {
    const t = new Ks({
      data: Tb,
      label: "attribute-batch-buffer",
      usage: Me.VERTEX | Me.COPY_DST,
      shrinkToFit: !1
    }), e = new Ks({
      data: Sb,
      label: "index-batch-buffer",
      usage: Me.INDEX | Me.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: !1
    }), i = 6 * 4;
    super({
      attributes: {
        aPosition: {
          buffer: t,
          format: "float32x2",
          stride: i,
          offset: 0
        },
        aUV: {
          buffer: t,
          format: "float32x2",
          stride: i,
          offset: 2 * 4
        },
        aColor: {
          buffer: t,
          format: "unorm8x4",
          stride: i,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: t,
          format: "uint16x2",
          stride: i,
          offset: 5 * 4
        }
      },
      indexBuffer: e
    });
  }
}
function Cp(n, t, e) {
  if (n)
    for (const i in n) {
      const r = i.toLocaleLowerCase(), s = t[r];
      if (s) {
        let o = n[i];
        i === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && s.push(`//----${e}----//`), s.push(o);
      } else
        jt(`${i} placement hook does not exist in shader`);
    }
}
const Cb = /\{\{(.*?)\}\}/g;
function Pp(n) {
  var t;
  const e = {};
  return (((t = n.match(Cb)) == null ? void 0 : t.map((i) => i.replace(/[{()}]/g, ""))) ?? []).forEach((i) => {
    e[i] = [];
  }), e;
}
function Ip(n, t) {
  let e;
  const i = /@in\s+([^;]+);/g;
  for (; (e = i.exec(n)) !== null; )
    t.push(e[1]);
}
function Rp(n, t, e = !1) {
  const i = [];
  Ip(t, i), n.forEach((a) => {
    a.header && Ip(a.header, i);
  });
  const r = i;
  e && r.sort();
  const s = r.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
  let o = t.replace(/@in\s+[^;]+;\s*/g, "");
  return o = o.replace("{{in}}", `
${s}
`), o;
}
function kp(n, t) {
  let e;
  const i = /@out\s+([^;]+);/g;
  for (; (e = i.exec(n)) !== null; )
    t.push(e[1]);
}
function Pb(n) {
  const t = /\b(\w+)\s*:/g.exec(n);
  return t ? t[1] : "";
}
function Ib(n) {
  const t = /@.*?\s+/g;
  return n.replace(t, "");
}
function Rb(n, t) {
  const e = [];
  kp(t, e), n.forEach((l) => {
    l.header && kp(l.header, e);
  });
  let i = 0;
  const r = e.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${i++}) ${l}`).join(`,
`), s = e.sort().map((l) => `       var ${Ib(l)};`).join(`
`), o = `return VSOutput(
                ${e.sort().map((l) => ` ${Pb(l)}`).join(`,
`)});`;
  let a = t.replace(/@out\s+[^;]+;\s*/g, "");
  return a = a.replace("{{struct}}", `
${r}
`), a = a.replace("{{start}}", `
${s}
`), a = a.replace("{{return}}", `
${o}
`), a;
}
function Mp(n, t) {
  let e = n;
  for (const i in t) {
    const r = t[i];
    r.join(`
`).length ? e = e.replace(`{{${i}}}`, `//-----${i} START-----//
${r.join(`
`)}
//----${i} FINISH----//`) : e = e.replace(`{{${i}}}`, "");
  }
  return e;
}
const Mi = /* @__PURE__ */ Object.create(null), oh = /* @__PURE__ */ new Map();
let kb = 0;
function Mb({
  template: n,
  bits: t
}) {
  const e = Tg(n, t);
  if (Mi[e])
    return Mi[e];
  const { vertex: i, fragment: r } = Db(n, t);
  return Mi[e] = Sg(i, r, t), Mi[e];
}
function Vb({
  template: n,
  bits: t
}) {
  const e = Tg(n, t);
  return Mi[e] || (Mi[e] = Sg(n.vertex, n.fragment, t)), Mi[e];
}
function Db(n, t) {
  const e = t.map((o) => o.vertex).filter((o) => !!o), i = t.map((o) => o.fragment).filter((o) => !!o);
  let r = Rp(e, n.vertex, !0);
  r = Rb(e, r);
  const s = Rp(i, n.fragment, !0);
  return {
    vertex: r,
    fragment: s
  };
}
function Tg(n, t) {
  return t.map((e) => (oh.has(e) || oh.set(e, kb++), oh.get(e))).sort((e, i) => e - i).join("-") + n.vertex + n.fragment;
}
function Sg(n, t, e) {
  const i = Pp(n), r = Pp(t);
  return e.forEach((s) => {
    Cp(s.vertex, i, s.name), Cp(s.fragment, r, s.name);
  }), {
    vertex: Mp(n, i),
    fragment: Mp(t, r)
  };
}
const Bb = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
), Ob = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
), Fb = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
), Lb = (
  /* glsl */
  `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`
), Nb = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
}, Ub = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function zb({ bits: n, name: t }) {
  const e = Mb({
    template: {
      fragment: Ob,
      vertex: Bb
    },
    bits: [
      Nb,
      ...n
    ]
  });
  return Xa.from({
    name: t,
    vertex: {
      source: e.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: e.fragment,
      entryPoint: "main"
    }
  });
}
function jb({ bits: n, name: t }) {
  return new eg({
    name: t,
    ...Vb({
      template: {
        vertex: Fb,
        fragment: Lb
      },
      bits: [
        Ub,
        ...n
      ]
    })
  });
}
const Gb = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, Hb = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, ah = {};
function qb(n) {
  const t = [];
  if (n === 1)
    t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
  else {
    let e = 0;
    for (let i = 0; i < n; i++)
      t.push(`@group(1) @binding(${e++}) var textureSource${i + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${i + 1}: sampler;`);
  }
  return t.join(`
`);
}
function Wb(n) {
  const t = [];
  if (n === 1)
    t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  else {
    t.push("switch vTextureId {");
    for (let e = 0; e < n; e++)
      e === n - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
    t.push("}");
  }
  return t.join(`
`);
}
function Yb(n) {
  return ah[n] || (ah[n] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
    },
    fragment: {
      header: `
                @in @interpolate(flat) vTextureId: u32;

                ${qb(n)}
            `,
      main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Wb(n)}
            `
    }
  }), ah[n];
}
const lh = {};
function Xb(n) {
  const t = [];
  for (let e = 0; e < n; e++)
    e > 0 && t.push("else"), e < n - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
  return t.join(`
`);
}
function Kb(n) {
  return lh[n] || (lh[n] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
    },
    fragment: {
      header: `
                in float vTextureId;

                uniform sampler2D uTextures[${n}];

            `,
      main: `

                ${Xb(n)}
            `
    }
  }), lh[n];
}
const Qb = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, Jb = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, Vp = {};
function Zb(n) {
  let t = Vp[n];
  if (t)
    return t;
  const e = new Int32Array(n);
  for (let i = 0; i < n; i++)
    e[i] = i;
  return t = Vp[n] = new sg({
    uTextures: { value: e, type: "i32", size: n }
  }, { isStatic: !0 }), t;
}
class $b extends qc {
  constructor(t) {
    const e = jb({
      name: "batch",
      bits: [
        Hb,
        Kb(t),
        Jb
      ]
    }), i = zb({
      name: "batch",
      bits: [
        Gb,
        Yb(t),
        Qb
      ]
    });
    super({
      glProgram: e,
      gpuProgram: i,
      resources: {
        batchSamplers: Zb(t)
      }
    });
  }
}
let Dp = null;
const Eg = class Cg extends xb {
  constructor() {
    super(...arguments), this.geometry = new Eb(), this.shader = Dp || (Dp = new $b(this.maxTextures)), this.name = Cg.extension.name, this.vertexSize = 6;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(t, e, i, r, s) {
    const o = s << 16 | t.roundPixels & 65535, a = t.transform, l = a.a, h = a.b, c = a.c, p = a.d, f = a.tx, u = a.ty, { positions: m, uvs: g } = t, y = t.color, b = t.attributeOffset, T = b + t.attributeSize;
    for (let C = b; C < T; C++) {
      const P = C * 2, S = m[P], I = m[P + 1];
      e[r++] = l * S + c * I + f, e[r++] = p * I + h * S + u, e[r++] = g[P], e[r++] = g[P + 1], i[r++] = y, i[r++] = o;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(t, e, i, r, s) {
    const o = t.texture, a = t.transform, l = a.a, h = a.b, c = a.c, p = a.d, f = a.tx, u = a.ty, m = t.bounds, g = m.maxX, y = m.minX, b = m.maxY, T = m.minY, C = o.uvs, P = t.color, S = s << 16 | t.roundPixels & 65535;
    e[r + 0] = l * y + c * T + f, e[r + 1] = p * T + h * y + u, e[r + 2] = C.x0, e[r + 3] = C.y0, i[r + 4] = P, i[r + 5] = S, e[r + 6] = l * g + c * T + f, e[r + 7] = p * T + h * g + u, e[r + 8] = C.x1, e[r + 9] = C.y1, i[r + 10] = P, i[r + 11] = S, e[r + 12] = l * g + c * b + f, e[r + 13] = p * b + h * g + u, e[r + 14] = C.x2, e[r + 15] = C.y2, i[r + 16] = P, i[r + 17] = S, e[r + 18] = l * y + c * b + f, e[r + 19] = p * b + h * y + u, e[r + 20] = C.x3, e[r + 21] = C.y3, i[r + 22] = P, i[r + 23] = S;
  }
};
Eg.extension = {
  type: [
    K.Batcher
  ],
  name: "default"
};
let t1 = Eg;
function e1(n, t, e, i, r, s, o, a = null) {
  let l = 0;
  e *= t, r *= s;
  const h = a.a, c = a.b, p = a.c, f = a.d, u = a.tx, m = a.ty;
  for (; l < o; ) {
    const g = n[e], y = n[e + 1];
    i[r] = h * g + p * y + u, i[r + 1] = c * g + f * y + m, r += s, e += t, l++;
  }
}
function n1(n, t, e, i) {
  let r = 0;
  for (t *= e; r < i; )
    n[t] = 0, n[t + 1] = 0, t += e, r++;
}
function Pg(n, t, e, i, r) {
  const s = t.a, o = t.b, a = t.c, l = t.d, h = t.tx, c = t.ty;
  e = e || 0, i = i || 2, r = r || n.length / i - e;
  let p = e * i;
  for (let f = 0; f < r; f++) {
    const u = n[p], m = n[p + 1];
    n[p] = s * u + a * m + h, n[p + 1] = o * u + l * m + c, p += i;
  }
}
function i1(n, t) {
  if (n === 16777215 || !t)
    return t;
  if (t === 16777215 || !n)
    return n;
  const e = n >> 16 & 255, i = n >> 8 & 255, r = n & 255, s = t >> 16 & 255, o = t >> 8 & 255, a = t & 255, l = e * s / 255, h = i * o / 255, c = r * a / 255;
  return (l << 16) + (h << 8) + c;
}
const r1 = new ft();
class Ig {
  constructor() {
    this.packAsQuad = !1, this.batcherName = "default", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    return this.applyTransform ? this.renderable.groupBlendMode : "normal";
  }
  get color() {
    const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, i = this.renderable;
    return i ? i1(e, i.groupColor) + (this.alpha * i.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
  }
  get transform() {
    var t;
    return ((t = this.renderable) == null ? void 0 : t.groupTransform) || r1;
  }
  copyTo(t) {
    t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData;
  }
  reset() {
    this.applyTransform = !0, this.renderable = null;
  }
}
const Qs = {
  extension: {
    type: K.ShapeBuilder,
    name: "circle"
  },
  build(n, t) {
    let e, i, r, s, o, a;
    if (n.type === "circle") {
      const P = n;
      e = P.x, i = P.y, o = a = P.radius, r = s = 0;
    } else if (n.type === "ellipse") {
      const P = n;
      e = P.x, i = P.y, o = P.halfWidth, a = P.halfHeight, r = s = 0;
    } else {
      const P = n, S = P.width / 2, I = P.height / 2;
      e = P.x + S, i = P.y + I, o = a = Math.max(0, Math.min(P.radius, Math.min(S, I))), r = S - o, s = I - a;
    }
    if (!(o >= 0 && a >= 0 && r >= 0 && s >= 0))
      return t;
    const l = Math.ceil(2.3 * Math.sqrt(o + a)), h = l * 8 + (r ? 4 : 0) + (s ? 4 : 0);
    if (h === 0)
      return t;
    if (l === 0)
      return t[0] = t[6] = e + r, t[1] = t[3] = i + s, t[2] = t[4] = e - r, t[5] = t[7] = i - s, t;
    let c = 0, p = l * 4 + (r ? 2 : 0) + 2, f = p, u = h, m = r + o, g = s, y = e + m, b = e - m, T = i + g;
    if (t[c++] = y, t[c++] = T, t[--p] = T, t[--p] = b, s) {
      const P = i - g;
      t[f++] = b, t[f++] = P, t[--u] = P, t[--u] = y;
    }
    for (let P = 1; P < l; P++) {
      const S = Math.PI / 2 * (P / l), I = r + Math.cos(S) * o, w = s + Math.sin(S) * a, _ = e + I, x = e - I, A = i + w, R = i - w;
      t[c++] = _, t[c++] = A, t[--p] = A, t[--p] = x, t[f++] = x, t[f++] = R, t[--u] = R, t[--u] = _;
    }
    m = r, g = s + a, y = e + m, b = e - m, T = i + g;
    const C = i - g;
    return t[c++] = y, t[c++] = T, t[--u] = C, t[--u] = y, r && (t[c++] = b, t[c++] = T, t[--u] = C, t[--u] = b), t;
  },
  triangulate(n, t, e, i, r, s) {
    if (n.length === 0)
      return;
    let o = 0, a = 0;
    for (let c = 0; c < n.length; c += 2)
      o += n[c], a += n[c + 1];
    o /= n.length / 2, a /= n.length / 2;
    let l = i;
    t[l * e] = o, t[l * e + 1] = a;
    const h = l++;
    for (let c = 0; c < n.length; c += 2)
      t[l * e] = n[c], t[l * e + 1] = n[c + 1], c > 0 && (r[s++] = l, r[s++] = h, r[s++] = l - 1), l++;
    r[s++] = h + 1, r[s++] = h, r[s++] = l - 1;
  }
}, s1 = { ...Qs, extension: { ...Qs.extension, name: "ellipse" } }, o1 = { ...Qs, extension: { ...Qs.extension, name: "roundedRectangle" } }, a1 = 1e-4, Bp = 1e-4;
function l1(n) {
  const t = n.length;
  if (t < 6)
    return 1;
  let e = 0;
  for (let i = 0, r = n[t - 2], s = n[t - 1]; i < t; i += 2) {
    const o = n[i], a = n[i + 1];
    e += (o - r) * (a + s), r = o, s = a;
  }
  return e < 0 ? -1 : 1;
}
function Op(n, t, e, i, r, s, o, a) {
  const l = n - e * r, h = t - i * r, c = n + e * s, p = t + i * s;
  let f, u;
  o ? (f = i, u = -e) : (f = -i, u = e);
  const m = l + f, g = h + u, y = c + f, b = p + u;
  return a.push(m, g), a.push(y, b), 2;
}
function wi(n, t, e, i, r, s, o, a) {
  const l = e - n, h = i - t;
  let c = Math.atan2(l, h), p = Math.atan2(r - n, s - t);
  a && c < p ? c += Math.PI * 2 : !a && c > p && (p += Math.PI * 2);
  let f = c;
  const u = p - c, m = Math.abs(u), g = Math.sqrt(l * l + h * h), y = (15 * m * Math.sqrt(g) / Math.PI >> 0) + 1, b = u / y;
  if (f += b, a) {
    o.push(n, t), o.push(e, i);
    for (let T = 1, C = f; T < y; T++, C += b)
      o.push(n, t), o.push(
        n + Math.sin(C) * g,
        t + Math.cos(C) * g
      );
    o.push(n, t), o.push(r, s);
  } else {
    o.push(e, i), o.push(n, t);
    for (let T = 1, C = f; T < y; T++, C += b)
      o.push(
        n + Math.sin(C) * g,
        t + Math.cos(C) * g
      ), o.push(n, t);
    o.push(r, s), o.push(n, t);
  }
  return y * 2;
}
function h1(n, t, e, i, r, s, o, a, l) {
  const h = a1;
  if (n.length === 0)
    return;
  const c = t;
  let p = c.alignment;
  if (t.alignment !== 0.5) {
    let J = l1(n);
    p = (p - 0.5) * J + 0.5;
  }
  const f = new ve(n[0], n[1]), u = new ve(n[n.length - 2], n[n.length - 1]), m = i, g = Math.abs(f.x - u.x) < h && Math.abs(f.y - u.y) < h;
  if (m) {
    n = n.slice(), g && (n.pop(), n.pop(), u.set(n[n.length - 2], n[n.length - 1]));
    const J = (f.x + u.x) * 0.5, $ = (u.y + f.y) * 0.5;
    n.unshift(J, $), n.push(J, $);
  }
  const y = r, b = n.length / 2;
  let T = n.length;
  const C = y.length / 2, P = c.width / 2, S = P * P, I = c.miterLimit * c.miterLimit;
  let w = n[0], _ = n[1], x = n[2], A = n[3], R = 0, M = 0, k = -(_ - A), B = w - x, O = 0, U = 0, z = Math.sqrt(k * k + B * B);
  k /= z, B /= z, k *= P, B *= P;
  const Q = p, j = (1 - Q) * 2, H = Q * 2;
  m || (c.cap === "round" ? T += wi(
    w - k * (j - H) * 0.5,
    _ - B * (j - H) * 0.5,
    w - k * j,
    _ - B * j,
    w + k * H,
    _ + B * H,
    y,
    !0
  ) + 2 : c.cap === "square" && (T += Op(w, _, k, B, j, H, !0, y))), y.push(
    w - k * j,
    _ - B * j
  ), y.push(
    w + k * H,
    _ + B * H
  );
  for (let J = 1; J < b - 1; ++J) {
    w = n[(J - 1) * 2], _ = n[(J - 1) * 2 + 1], x = n[J * 2], A = n[J * 2 + 1], R = n[(J + 1) * 2], M = n[(J + 1) * 2 + 1], k = -(_ - A), B = w - x, z = Math.sqrt(k * k + B * B), k /= z, B /= z, k *= P, B *= P, O = -(A - M), U = x - R, z = Math.sqrt(O * O + U * U), O /= z, U /= z, O *= P, U *= P;
    const $ = x - w, St = _ - A, Ct = x - R, rt = M - A, Xt = $ * Ct + St * rt, Pt = St * Ct - rt * $, Ne = Pt < 0;
    if (Math.abs(Pt) < 1e-3 * Math.abs(Xt)) {
      y.push(
        x - k * j,
        A - B * j
      ), y.push(
        x + k * H,
        A + B * H
      ), Xt >= 0 && (c.join === "round" ? T += wi(
        x,
        A,
        x - k * j,
        A - B * j,
        x - O * j,
        A - U * j,
        y,
        !1
      ) + 4 : T += 2, y.push(
        x - O * H,
        A - U * H
      ), y.push(
        x + O * j,
        A + U * j
      ));
      continue;
    }
    const te = (-k + w) * (-B + A) - (-k + x) * (-B + _), ee = (-O + R) * (-U + A) - (-O + x) * (-U + M), It = ($ * ee - Ct * te) / Pt, fn = (rt * te - St * ee) / Pt, Cn = (It - x) * (It - x) + (fn - A) * (fn - A), Ue = x + (It - x) * j, ze = A + (fn - A) * j, Ze = x - (It - x) * H, je = A - (fn - A) * H, Re = Math.min($ * $ + St * St, Ct * Ct + rt * rt), Pn = Ne ? j : H, qn = Re + Pn * Pn * S;
    Cn <= qn ? c.join === "bevel" || Cn / S > I ? (Ne ? (y.push(Ue, ze), y.push(x + k * H, A + B * H), y.push(Ue, ze), y.push(x + O * H, A + U * H)) : (y.push(x - k * j, A - B * j), y.push(Ze, je), y.push(x - O * j, A - U * j), y.push(Ze, je)), T += 2) : c.join === "round" ? Ne ? (y.push(Ue, ze), y.push(x + k * H, A + B * H), T += wi(
      x,
      A,
      x + k * H,
      A + B * H,
      x + O * H,
      A + U * H,
      y,
      !0
    ) + 4, y.push(Ue, ze), y.push(x + O * H, A + U * H)) : (y.push(x - k * j, A - B * j), y.push(Ze, je), T += wi(
      x,
      A,
      x - k * j,
      A - B * j,
      x - O * j,
      A - U * j,
      y,
      !1
    ) + 4, y.push(x - O * j, A - U * j), y.push(Ze, je)) : (y.push(Ue, ze), y.push(Ze, je)) : (y.push(x - k * j, A - B * j), y.push(x + k * H, A + B * H), c.join === "round" ? Ne ? T += wi(
      x,
      A,
      x + k * H,
      A + B * H,
      x + O * H,
      A + U * H,
      y,
      !0
    ) + 2 : T += wi(
      x,
      A,
      x - k * j,
      A - B * j,
      x - O * j,
      A - U * j,
      y,
      !1
    ) + 2 : c.join === "miter" && Cn / S <= I && (Ne ? (y.push(Ze, je), y.push(Ze, je)) : (y.push(Ue, ze), y.push(Ue, ze)), T += 2), y.push(x - O * j, A - U * j), y.push(x + O * H, A + U * H), T += 2);
  }
  w = n[(b - 2) * 2], _ = n[(b - 2) * 2 + 1], x = n[(b - 1) * 2], A = n[(b - 1) * 2 + 1], k = -(_ - A), B = w - x, z = Math.sqrt(k * k + B * B), k /= z, B /= z, k *= P, B *= P, y.push(x - k * j, A - B * j), y.push(x + k * H, A + B * H), m || (c.cap === "round" ? T += wi(
    x - k * (j - H) * 0.5,
    A - B * (j - H) * 0.5,
    x - k * j,
    A - B * j,
    x + k * H,
    A + B * H,
    y,
    !1
  ) + 2 : c.cap === "square" && (T += Op(x, A, k, B, j, H, !1, y)));
  const _t = Bp * Bp;
  for (let J = C; J < T + C - 2; ++J)
    w = y[J * 2], _ = y[J * 2 + 1], x = y[(J + 1) * 2], A = y[(J + 1) * 2 + 1], R = y[(J + 2) * 2], M = y[(J + 2) * 2 + 1], !(Math.abs(w * (A - M) + x * (M - _) + R * (_ - A)) < _t) && a.push(J, J + 1, J + 2);
}
function Rg(n, t, e, i, r, s, o) {
  const a = Qx(n, t, 2);
  if (!a)
    return;
  for (let h = 0; h < a.length; h += 3)
    s[o++] = a[h] + r, s[o++] = a[h + 1] + r, s[o++] = a[h + 2] + r;
  let l = r * i;
  for (let h = 0; h < n.length; h += 2)
    e[l] = n[h], e[l + 1] = n[h + 1], l += i;
}
const c1 = [], u1 = {
  extension: {
    type: K.ShapeBuilder,
    name: "polygon"
  },
  build(n, t) {
    for (let e = 0; e < n.points.length; e++)
      t[e] = n.points[e];
    return t;
  },
  triangulate(n, t, e, i, r, s) {
    Rg(n, c1, t, e, i, r, s);
  }
}, d1 = {
  extension: {
    type: K.ShapeBuilder,
    name: "rectangle"
  },
  build(n, t) {
    const e = n, i = e.x, r = e.y, s = e.width, o = e.height;
    return s >= 0 && o >= 0 && (t[0] = i, t[1] = r, t[2] = i + s, t[3] = r, t[4] = i + s, t[5] = r + o, t[6] = i, t[7] = r + o), t;
  },
  triangulate(n, t, e, i, r, s) {
    let o = 0;
    i *= e, t[i + o] = n[0], t[i + o + 1] = n[1], o += e, t[i + o] = n[2], t[i + o + 1] = n[3], o += e, t[i + o] = n[6], t[i + o + 1] = n[7], o += e, t[i + o] = n[4], t[i + o + 1] = n[5], o += e;
    const a = i / e;
    r[s++] = a, r[s++] = a + 1, r[s++] = a + 2, r[s++] = a + 1, r[s++] = a + 3, r[s++] = a + 2;
  }
}, p1 = {
  extension: {
    type: K.ShapeBuilder,
    name: "triangle"
  },
  build(n, t) {
    return t[0] = n.x, t[1] = n.y, t[2] = n.x2, t[3] = n.y2, t[4] = n.x3, t[5] = n.y3, t;
  },
  triangulate(n, t, e, i, r, s) {
    let o = 0;
    i *= e, t[i + o] = n[0], t[i + o + 1] = n[1], o += e, t[i + o] = n[2], t[i + o + 1] = n[3], o += e, t[i + o] = n[4], t[i + o + 1] = n[5];
    const a = i / e;
    r[s++] = a, r[s++] = a + 1, r[s++] = a + 2;
  }
}, tl = {};
xe.handleByMap(K.ShapeBuilder, tl);
xe.add(d1, u1, p1, Qs, s1, o1);
const f1 = new Wt();
function m1(n, t) {
  const { geometryData: e, batches: i } = t;
  i.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
  for (let r = 0; r < n.instructions.length; r++) {
    const s = n.instructions[r];
    if (s.action === "texture")
      g1(s.data, i, e);
    else if (s.action === "fill" || s.action === "stroke") {
      const o = s.action === "stroke", a = s.data.path.shapePath, l = s.data.style, h = s.data.hole;
      o && h && Fp(h.shapePath, l, null, !0, i, e), Fp(a, l, h, o, i, e);
    }
  }
}
function g1(n, t, e) {
  const { vertices: i, uvs: r, indices: s } = e, o = s.length, a = i.length / 2, l = [], h = tl.rectangle, c = f1, p = n.image;
  c.x = n.dx, c.y = n.dy, c.width = n.dw, c.height = n.dh;
  const f = n.transform;
  h.build(c, l), f && Pg(l, f), h.triangulate(l, i, 2, a, s, o);
  const u = p.uvs;
  r.push(
    u.x0,
    u.y0,
    u.x1,
    u.y1,
    u.x3,
    u.y3,
    u.x2,
    u.y2
  );
  const m = Bn.get(Ig);
  m.indexOffset = o, m.indexSize = s.length - o, m.attributeOffset = a, m.attributeSize = i.length / 2 - a, m.baseColor = n.style, m.alpha = n.alpha, m.texture = p, m.geometryData = e, t.push(m);
}
function Fp(n, t, e, i, r, s) {
  const { vertices: o, uvs: a, indices: l } = s, h = n.shapePrimitives.length - 1;
  n.shapePrimitives.forEach(({ shape: c, transform: p }, f) => {
    const u = l.length, m = o.length / 2, g = [], y = tl[c.type];
    if (y.build(c, g), p && Pg(g, p), i) {
      const P = c.closePath ?? !0;
      h1(g, t, !1, P, o, 2, m, l);
    } else if (e && h === f) {
      h !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out");
      const P = [], S = g.slice();
      y1(e.shapePath).forEach((I) => {
        P.push(S.length / 2), S.push(...I);
      }), Rg(S, P, o, 2, m, l, u);
    } else
      y.triangulate(g, o, 2, m, l, u);
    const b = a.length / 2, T = t.texture;
    if (T !== ot.WHITE) {
      const P = t.matrix;
      P && (p && P.append(p.clone().invert()), e1(o, 2, m, a, b, 2, o.length / 2 - m, P));
    } else
      n1(a, b, 2, o.length / 2 - m);
    const C = Bn.get(Ig);
    C.indexOffset = u, C.indexSize = l.length - u, C.attributeOffset = m, C.attributeSize = o.length / 2 - m, C.baseColor = t.color, C.alpha = t.alpha, C.texture = T, C.geometryData = s, r.push(C);
  });
}
function y1(n) {
  if (!n)
    return [];
  const t = n.shapePrimitives, e = [];
  for (let i = 0; i < t.length; i++) {
    const r = t[i].shape, s = [];
    tl[r.type].build(r, s), e.push(s);
  }
  return e;
}
class _1 {
  constructor() {
    this.batches = [], this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class v1 {
  constructor() {
    this.batcher = new t1(), this.instructions = new Lm();
  }
  init() {
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    return mt(Ev, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
  }
}
const Xc = class Kh {
  constructor(t) {
    this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(t) {
    Kh.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? Kh.defaultOptions.bezierSmoothness;
  }
  getContextRenderData(t) {
    return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
  }
  // Context management functions
  updateGpuContext(t) {
    let e = this._gpuContextHash[t.uid] || this._initContext(t);
    if (t.dirty) {
      e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), m1(t, e);
      const i = t.batchMode;
      t.customShader || i === "no-batch" ? e.isBatchable = !1 : i === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = !1;
    }
    return e;
  }
  getGpuContext(t) {
    return this._gpuContextHash[t.uid] || this._initContext(t);
  }
  _initContextRenderData(t) {
    const e = Bn.get(v1), { batches: i, geometryData: r } = this._gpuContextHash[t.uid], s = r.vertices.length, o = r.indices.length;
    for (let c = 0; c < i.length; c++)
      i[c].applyTransform = !1;
    const a = e.batcher;
    a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin();
    for (let c = 0; c < i.length; c++) {
      const p = i[c];
      a.add(p);
    }
    a.finish(e.instructions);
    const l = a.geometry;
    l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
    const h = a.batches;
    for (let c = 0; c < h.length; c++) {
      const p = h[c];
      p.bindGroup = fb(p.textures.textures, p.textures.count);
    }
    return this._graphicsDataContextHash[t.uid] = e, e;
  }
  _initContext(t) {
    const e = new _1();
    return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
  }
  onGraphicsContextDestroy(t) {
    this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
  }
  _cleanGraphicsContextData(t) {
    const e = this._gpuContextHash[t.uid];
    e.isBatchable || this._graphicsDataContextHash[t.uid] && (Bn.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((i) => {
      Bn.return(i);
    });
  }
  destroy() {
    for (const t in this._gpuContextHash)
      this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
  }
};
Xc.extension = {
  type: [
    K.WebGLSystem,
    K.WebGPUSystem,
    K.CanvasSystem
  ],
  name: "graphicsContext"
};
Xc.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let kg = Xc;
const x1 = 8, Yo = 11920929e-14, b1 = 1;
function Mg(n, t, e, i, r, s, o, a, l, h) {
  const c = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, h ?? kg.defaultOptions.bezierSmoothness)
  );
  let p = (b1 - c) / 1;
  return p *= p, w1(t, e, i, r, s, o, a, l, n, p), n;
}
function w1(n, t, e, i, r, s, o, a, l, h) {
  Qh(n, t, e, i, r, s, o, a, l, h, 0), l.push(o, a);
}
function Qh(n, t, e, i, r, s, o, a, l, h, c) {
  if (c > x1)
    return;
  const p = (n + e) / 2, f = (t + i) / 2, u = (e + r) / 2, m = (i + s) / 2, g = (r + o) / 2, y = (s + a) / 2, b = (p + u) / 2, T = (f + m) / 2, C = (u + g) / 2, P = (m + y) / 2, S = (b + C) / 2, I = (T + P) / 2;
  if (c > 0) {
    let w = o - n, _ = a - t;
    const x = Math.abs((e - o) * _ - (i - a) * w), A = Math.abs((r - o) * _ - (s - a) * w);
    if (x > Yo && A > Yo) {
      if ((x + A) * (x + A) <= h * (w * w + _ * _)) {
        l.push(S, I);
        return;
      }
    } else if (x > Yo) {
      if (x * x <= h * (w * w + _ * _)) {
        l.push(S, I);
        return;
      }
    } else if (A > Yo) {
      if (A * A <= h * (w * w + _ * _)) {
        l.push(S, I);
        return;
      }
    } else if (w = S - (n + o) / 2, _ = I - (t + a) / 2, w * w + _ * _ <= h) {
      l.push(S, I);
      return;
    }
  }
  Qh(n, t, p, f, b, T, S, I, l, h, c + 1), Qh(S, I, C, P, g, y, o, a, l, h, c + 1);
}
const A1 = 8, T1 = 11920929e-14, S1 = 1;
function E1(n, t, e, i, r, s, o, a) {
  const l = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, a ?? kg.defaultOptions.bezierSmoothness)
  );
  let h = (S1 - l) / 1;
  return h *= h, C1(t, e, i, r, s, o, n, h), n;
}
function C1(n, t, e, i, r, s, o, a) {
  Jh(o, n, t, e, i, r, s, a, 0), o.push(r, s);
}
function Jh(n, t, e, i, r, s, o, a, l) {
  if (l > A1)
    return;
  const h = (t + i) / 2, c = (e + r) / 2, p = (i + s) / 2, f = (r + o) / 2, u = (h + p) / 2, m = (c + f) / 2;
  let g = s - t, y = o - e;
  const b = Math.abs((i - s) * y - (r - o) * g);
  if (b > T1) {
    if (b * b <= a * (g * g + y * y)) {
      n.push(u, m);
      return;
    }
  } else if (g = u - (t + s) / 2, y = m - (e + o) / 2, g * g + y * y <= a) {
    n.push(u, m);
    return;
  }
  Jh(n, t, e, h, c, u, m, a, l + 1), Jh(n, u, m, p, f, s, o, a, l + 1);
}
function Vg(n, t, e, i, r, s, o, a) {
  let l = Math.abs(r - s);
  (!o && r > s || o && s > r) && (l = 2 * Math.PI - l), a = a || Math.max(6, Math.floor(6 * Math.pow(i, 1 / 3) * (l / Math.PI))), a = Math.max(a, 3);
  let h = l / a, c = r;
  h *= o ? -1 : 1;
  for (let p = 0; p < a + 1; p++) {
    const f = Math.cos(c), u = Math.sin(c), m = t + f * i, g = e + u * i;
    n.push(m, g), c += h;
  }
}
function P1(n, t, e, i, r, s) {
  const o = n[n.length - 2], a = n[n.length - 1] - e, l = o - t, h = r - e, c = i - t, p = Math.abs(a * c - l * h);
  if (p < 1e-8 || s === 0) {
    (n[n.length - 2] !== t || n[n.length - 1] !== e) && n.push(t, e);
    return;
  }
  const f = a * a + l * l, u = h * h + c * c, m = a * h + l * c, g = s * Math.sqrt(f) / p, y = s * Math.sqrt(u) / p, b = g * m / f, T = y * m / u, C = g * c + y * l, P = g * h + y * a, S = l * (y + b), I = a * (y + b), w = c * (g + T), _ = h * (g + T), x = Math.atan2(I - P, S - C), A = Math.atan2(_ - P, w - C);
  Vg(
    n,
    C + t,
    P + e,
    s,
    x,
    A,
    l * h > c * a
  );
}
const Bs = Math.PI * 2, hh = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
}, ch = ({ x: n, y: t }, e, i, r, s, o, a, l) => {
  n *= e, t *= i;
  const h = r * n - s * t, c = s * n + r * t;
  return l.x = h + o, l.y = c + a, l;
};
function I1(n, t) {
  const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), i = t === 1.5707963267948966 ? 0.551915024494 : e, r = Math.cos(n), s = Math.sin(n), o = Math.cos(n + t), a = Math.sin(n + t);
  return [
    {
      x: r - s * i,
      y: s + r * i
    },
    {
      x: o + a * i,
      y: a - o * i
    },
    {
      x: o,
      y: a
    }
  ];
}
const Lp = (n, t, e, i) => {
  const r = n * i - t * e < 0 ? -1 : 1;
  let s = n * e + t * i;
  return s > 1 && (s = 1), s < -1 && (s = -1), r * Math.acos(s);
}, R1 = (n, t, e, i, r, s, o, a, l, h, c, p, f) => {
  const u = Math.pow(r, 2), m = Math.pow(s, 2), g = Math.pow(c, 2), y = Math.pow(p, 2);
  let b = u * m - u * y - m * g;
  b < 0 && (b = 0), b /= u * y + m * g, b = Math.sqrt(b) * (o === a ? -1 : 1);
  const T = b * r / s * p, C = b * -s / r * c, P = h * T - l * C + (n + e) / 2, S = l * T + h * C + (t + i) / 2, I = (c - T) / r, w = (p - C) / s, _ = (-c - T) / r, x = (-p - C) / s, A = Lp(1, 0, I, w);
  let R = Lp(I, w, _, x);
  a === 0 && R > 0 && (R -= Bs), a === 1 && R < 0 && (R += Bs), f.centerX = P, f.centerY = S, f.ang1 = A, f.ang2 = R;
};
function k1(n, t, e, i, r, s, o, a = 0, l = 0, h = 0) {
  if (s === 0 || o === 0)
    return;
  const c = Math.sin(a * Bs / 360), p = Math.cos(a * Bs / 360), f = p * (t - i) / 2 + c * (e - r) / 2, u = -c * (t - i) / 2 + p * (e - r) / 2;
  if (f === 0 && u === 0)
    return;
  s = Math.abs(s), o = Math.abs(o);
  const m = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(u, 2) / Math.pow(o, 2);
  m > 1 && (s *= Math.sqrt(m), o *= Math.sqrt(m)), R1(
    t,
    e,
    i,
    r,
    s,
    o,
    l,
    h,
    c,
    p,
    f,
    u,
    hh
  );
  let { ang1: g, ang2: y } = hh;
  const { centerX: b, centerY: T } = hh;
  let C = Math.abs(y) / (Bs / 4);
  Math.abs(1 - C) < 1e-7 && (C = 1);
  const P = Math.max(Math.ceil(C), 1);
  y /= P;
  let S = n[n.length - 2], I = n[n.length - 1];
  const w = { x: 0, y: 0 };
  for (let _ = 0; _ < P; _++) {
    const x = I1(g, y), { x: A, y: R } = ch(x[0], s, o, p, c, b, T, w), { x: M, y: k } = ch(x[1], s, o, p, c, b, T, w), { x: B, y: O } = ch(x[2], s, o, p, c, b, T, w);
    Mg(
      n,
      S,
      I,
      A,
      R,
      M,
      k,
      B,
      O
    ), S = B, I = O, g += y;
  }
}
function M1(n, t, e) {
  const i = (o, a) => {
    const l = a.x - o.x, h = a.y - o.y, c = Math.sqrt(l * l + h * h), p = l / c, f = h / c;
    return { len: c, nx: p, ny: f };
  }, r = (o, a) => {
    o === 0 ? n.moveTo(a.x, a.y) : n.lineTo(a.x, a.y);
  };
  let s = t[t.length - 1];
  for (let o = 0; o < t.length; o++) {
    const a = t[o % t.length], l = a.radius ?? e;
    if (l <= 0) {
      r(o, a), s = a;
      continue;
    }
    const h = t[(o + 1) % t.length], c = i(a, s), p = i(a, h);
    if (c.len < 1e-4 || p.len < 1e-4) {
      r(o, a), s = a;
      continue;
    }
    let f = Math.asin(c.nx * p.ny - c.ny * p.nx), u = 1, m = !1;
    c.nx * p.nx - c.ny * -p.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, u = -1, m = !0) : f > 0 && (u = -1, m = !0);
    const g = f / 2;
    let y, b = Math.abs(
      Math.cos(g) * l / Math.sin(g)
    );
    b > Math.min(c.len / 2, p.len / 2) ? (b = Math.min(c.len / 2, p.len / 2), y = Math.abs(b * Math.sin(g) / Math.cos(g))) : y = l;
    const T = a.x + p.nx * b + -p.ny * y * u, C = a.y + p.ny * b + p.nx * y * u, P = Math.atan2(c.ny, c.nx) + Math.PI / 2 * u, S = Math.atan2(p.ny, p.nx) - Math.PI / 2 * u;
    o === 0 && n.moveTo(
      T + Math.cos(P) * y,
      C + Math.sin(P) * y
    ), n.arc(T, C, y, P, S, m), s = a;
  }
}
function V1(n, t, e, i) {
  const r = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2), s = (a, l, h) => ({
    x: a.x + (l.x - a.x) * h,
    y: a.y + (l.y - a.y) * h
  }), o = t.length;
  for (let a = 0; a < o; a++) {
    const l = t[(a + 1) % o], h = l.radius ?? e;
    if (h <= 0) {
      a === 0 ? n.moveTo(l.x, l.y) : n.lineTo(l.x, l.y);
      continue;
    }
    const c = t[a], p = t[(a + 2) % o], f = r(c, l);
    let u;
    if (f < 1e-4)
      u = l;
    else {
      const y = Math.min(f / 2, h);
      u = s(
        l,
        c,
        y / f
      );
    }
    const m = r(p, l);
    let g;
    if (m < 1e-4)
      g = l;
    else {
      const y = Math.min(m / 2, h);
      g = s(
        l,
        p,
        y / m
      );
    }
    a === 0 ? n.moveTo(u.x, u.y) : n.lineTo(u.x, u.y), n.quadraticCurveTo(l.x, l.y, g.x, g.y, i);
  }
}
const D1 = new Wt();
class B1 {
  constructor(t) {
    this.shapePrimitives = [], this._currentPoly = null, this._bounds = new oi(), this._graphicsPath2D = t;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    return this.startPoly(t, e), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._ensurePoly();
    const i = this._currentPoly.points, r = i[i.length - 2], s = i[i.length - 1];
    return (r !== t || s !== e) && i.push(t, e), this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(t, e, i, r, s, o) {
    this._ensurePoly(!1);
    const a = this._currentPoly.points;
    return Vg(a, t, e, i, r, s, o), this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(t, e, i, r, s) {
    this._ensurePoly();
    const o = this._currentPoly.points;
    return P1(o, t, e, i, r, s), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, i, r, s, o, a) {
    const l = this._currentPoly.points;
    return k1(
      l,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      o,
      a,
      t,
      e,
      i,
      r,
      s
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, i, r, s, o, a) {
    this._ensurePoly();
    const l = this._currentPoly;
    return Mg(
      this._currentPoly.points,
      l.lastX,
      l.lastY,
      t,
      e,
      i,
      r,
      s,
      o,
      a
    ), this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, i, r, s) {
    this._ensurePoly();
    const o = this._currentPoly;
    return E1(
      this._currentPoly.points,
      o.lastX,
      o.lastY,
      t,
      e,
      i,
      r,
      s
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.endPoly(!0), this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e));
    for (let i = 0; i < t.instructions.length; i++) {
      const r = t.instructions[i];
      this[r.action](...r.data);
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(t = !1) {
    this.endPoly(t);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, r, s) {
    return this.drawShape(new Wt(t, e, i, r), s), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i, r) {
    return this.drawShape(new Za(t, e, i), r), this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(t, e, i) {
    const r = new vr(t);
    return r.closePath = e, this.drawShape(r, i), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, i, r, s = 0, o) {
    r = Math.max(r | 0, 3);
    const a = -1 * Math.PI / 2 + s, l = Math.PI * 2 / r, h = [];
    for (let c = 0; c < r; c++) {
      const p = c * l + a;
      h.push(
        t + i * Math.cos(p),
        e + i * Math.sin(p)
      );
    }
    return this.poly(h, !0, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, i, r, s, o = 0, a) {
    if (r = Math.max(r | 0, 3), s <= 0)
      return this.regularPoly(t, e, i, r, o);
    const l = i * Math.sin(Math.PI / r) - 1e-3;
    s = Math.min(s, l);
    const h = -1 * Math.PI / 2 + o, c = Math.PI * 2 / r, p = (r - 2) * Math.PI / r / 2;
    for (let f = 0; f < r; f++) {
      const u = f * c + h, m = t + i * Math.cos(u), g = e + i * Math.sin(u), y = u + Math.PI + p, b = u - Math.PI - p, T = m + s * Math.cos(y), C = g + s * Math.sin(y), P = m + s * Math.cos(b), S = g + s * Math.sin(b);
      f === 0 ? this.moveTo(T, C) : this.lineTo(T, C), this.quadraticCurveTo(m, g, P, S, a);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, i = !1, r) {
    return t.length < 3 ? this : (i ? V1(this, t, e, r) : M1(this, t, e), this.closePath());
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, i, r, s) {
    if (s === 0)
      return this.rect(t, e, i, r);
    const o = Math.min(i, r) / 2, a = Math.min(o, Math.max(-o, s)), l = t + i, h = e + r, c = a < 0 ? -a : 0, p = Math.abs(a);
    return this.moveTo(t, e + p).arcTo(t + c, e + c, t + p, e, p).lineTo(l - p, e).arcTo(l - c, e + c, l, e + p, p).lineTo(l, h - p).arcTo(l - c, h - c, t + i - p, h, p).lineTo(t + p, h).arcTo(t + c, h - c, t, h - p, p).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, i, r, s, o) {
    if (s <= 0)
      return this.rect(t, e, i, r);
    const a = Math.min(s, Math.min(i, r) / 2), l = t + i, h = e + r, c = [
      t + a,
      e,
      l - a,
      e,
      l,
      e + a,
      l,
      h - a,
      l - a,
      h,
      t + a,
      h,
      t,
      h - a,
      t,
      e + a
    ];
    for (let p = c.length - 1; p >= 2; p -= 2)
      c[p] === c[p - 2] && c[p - 1] === c[p - 3] && c.splice(p - 1, 2);
    return this.poly(c, !0, o);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, i, r, s) {
    return this.drawShape(new Yc(t, e, i, r), s), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, i, r, s, o) {
    return this.drawShape(new $a(t, e, i, r, s), o), this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(t, e) {
    return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(t, e) {
    let i = this._currentPoly;
    return i && this.endPoly(), i = new vr(), i.points.push(t, e), this._currentPoly = i, this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(t = !1) {
    const e = this._currentPoly;
    return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this;
  }
  _ensurePoly(t = !0) {
    if (!this._currentPoly && (this._currentPoly = new vr(), t)) {
      const e = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (e) {
        let i = e.shape.x, r = e.shape.y;
        if (e.transform && !e.transform.isIdentity()) {
          const s = e.transform, o = i;
          i = s.a * i + s.c * r + s.tx, r = s.b * o + s.d * r + s.ty;
        }
        this._currentPoly.points.push(i, r);
      } else
        this._currentPoly.points.push(0, 0);
    }
  }
  /** Builds the path. */
  buildPath() {
    const t = this._graphicsPath2D;
    this.shapePrimitives.length = 0, this._currentPoly = null;
    for (let e = 0; e < t.instructions.length; e++) {
      const i = t.instructions[e];
      this[i.action](...i.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const t = this._bounds;
    t.clear();
    const e = this.shapePrimitives;
    for (let i = 0; i < e.length; i++) {
      const r = e[i], s = r.shape.getBounds(D1);
      r.transform ? t.addRect(s, r.transform) : t.addRect(s);
    }
    return t;
  }
}
class Rr {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   */
  constructor(t) {
    this.instructions = [], this.uid = Jt("graphicsPath"), this._dirty = !0, typeof t == "string" ? hb(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    return this._shapePath || (this._shapePath = new B1(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = !0, this;
  }
  arc(...t) {
    return this.instructions.push({ action: "arc", data: t }), this._dirty = !0, this;
  }
  arcTo(...t) {
    return this.instructions.push({ action: "arcTo", data: t }), this._dirty = !0, this;
  }
  arcToSvg(...t) {
    return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = !0, this;
  }
  bezierCurveTo(...t) {
    return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(t, e, i, r, s) {
    const o = this.instructions[this.instructions.length - 1], a = this.getLastPoint(ve.shared);
    let l = 0, h = 0;
    if (!o || o.action !== "bezierCurveTo")
      l = a.x, h = a.y;
    else {
      l = o.data[2], h = o.data[3];
      const c = a.x, p = a.y;
      l = c + (c - l), h = p + (p - h);
    }
    return this.instructions.push({ action: "bezierCurveTo", data: [l, h, t, e, i, r, s] }), this._dirty = !0, this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this;
  }
  ellipse(...t) {
    return this.instructions.push({ action: "ellipse", data: t }), this._dirty = !0, this;
  }
  lineTo(...t) {
    return this.instructions.push({ action: "lineTo", data: t }), this._dirty = !0, this;
  }
  moveTo(...t) {
    return this.instructions.push({ action: "moveTo", data: t }), this;
  }
  quadraticCurveTo(...t) {
    return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(t, e, i) {
    const r = this.instructions[this.instructions.length - 1], s = this.getLastPoint(ve.shared);
    let o = 0, a = 0;
    if (!r || r.action !== "quadraticCurveTo")
      o = s.x, a = s.y;
    else {
      o = r.data[0], a = r.data[1];
      const l = s.x, h = s.y;
      o = l + (l - o), a = h + (h - a);
    }
    return this.instructions.push({ action: "quadraticCurveTo", data: [o, a, t, e, i] }), this._dirty = !0, this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, r, s) {
    return this.instructions.push({ action: "rect", data: [t, e, i, r, s] }), this._dirty = !0, this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i, r) {
    return this.instructions.push({ action: "circle", data: [t, e, i, r] }), this._dirty = !0, this;
  }
  roundRect(...t) {
    return this.instructions.push({ action: "roundRect", data: t }), this._dirty = !0, this;
  }
  poly(...t) {
    return this.instructions.push({ action: "poly", data: t }), this._dirty = !0, this;
  }
  regularPoly(...t) {
    return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = !0, this;
  }
  roundPoly(...t) {
    return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = !0, this;
  }
  roundShape(...t) {
    return this.instructions.push({ action: "roundShape", data: t }), this._dirty = !0, this;
  }
  filletRect(...t) {
    return this.instructions.push({ action: "filletRect", data: t }), this._dirty = !0, this;
  }
  chamferRect(...t) {
    return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = !0, this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(t, e, i, r, s, o, a) {
    s = s || r / 2;
    const l = -1 * Math.PI / 2 + o, h = i * 2, c = Math.PI * 2 / h, p = [];
    for (let f = 0; f < h; f++) {
      const u = f % 2 ? s : r, m = f * c + l;
      p.push(
        t + u * Math.cos(m),
        e + u * Math.sin(m)
      );
    }
    return this.poly(p, !0, a), this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(t = !1) {
    const e = new Rr();
    if (!t)
      e.instructions = this.instructions.slice();
    else
      for (let i = 0; i < this.instructions.length; i++) {
        const r = this.instructions[i];
        e.instructions.push({ action: r.action, data: r.data.slice() });
      }
    return e;
  }
  clear() {
    return this.instructions.length = 0, this._dirty = !0, this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(t) {
    if (t.isIdentity())
      return this;
    const e = t.a, i = t.b, r = t.c, s = t.d, o = t.tx, a = t.ty;
    let l = 0, h = 0, c = 0, p = 0, f = 0, u = 0, m = 0, g = 0;
    for (let y = 0; y < this.instructions.length; y++) {
      const b = this.instructions[y], T = b.data;
      switch (b.action) {
        case "moveTo":
        case "lineTo":
          l = T[0], h = T[1], T[0] = e * l + r * h + o, T[1] = i * l + s * h + a;
          break;
        case "bezierCurveTo":
          c = T[0], p = T[1], f = T[2], u = T[3], l = T[4], h = T[5], T[0] = e * c + r * p + o, T[1] = i * c + s * p + a, T[2] = e * f + r * u + o, T[3] = i * f + s * u + a, T[4] = e * l + r * h + o, T[5] = i * l + s * h + a;
          break;
        case "quadraticCurveTo":
          c = T[0], p = T[1], l = T[2], h = T[3], T[0] = e * c + r * p + o, T[1] = i * c + s * p + a, T[2] = e * l + r * h + o, T[3] = i * l + s * h + a;
          break;
        case "arcToSvg":
          l = T[5], h = T[6], m = T[0], g = T[1], T[0] = e * m + r * g, T[1] = i * m + s * g, T[5] = e * l + r * h + o, T[6] = i * l + s * h + a;
          break;
        case "circle":
          T[4] = xs(T[3], t);
          break;
        case "rect":
          T[4] = xs(T[4], t);
          break;
        case "ellipse":
          T[8] = xs(T[8], t);
          break;
        case "roundRect":
          T[5] = xs(T[5], t);
          break;
        case "addPath":
          T[0].transform(t);
          break;
        case "poly":
          T[2] = xs(T[2], t);
          break;
        default:
          jt("unknown transform action", b.action);
          break;
      }
    }
    return this._dirty = !0, this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(t) {
    let e = this.instructions.length - 1, i = this.instructions[e];
    if (!i)
      return t.x = 0, t.y = 0, t;
    for (; i.action === "closePath"; ) {
      if (e--, e < 0)
        return t.x = 0, t.y = 0, t;
      i = this.instructions[e];
    }
    switch (i.action) {
      case "moveTo":
      case "lineTo":
        t.x = i.data[0], t.y = i.data[1];
        break;
      case "quadraticCurveTo":
        t.x = i.data[2], t.y = i.data[3];
        break;
      case "bezierCurveTo":
        t.x = i.data[4], t.y = i.data[5];
        break;
      case "arc":
      case "arcToSvg":
        t.x = i.data[5], t.y = i.data[6];
        break;
      case "addPath":
        i.data[0].getLastPoint(t);
        break;
    }
    return t;
  }
}
function xs(n, t) {
  return n ? n.prepend(t) : t.clone();
}
function O1(n, t) {
  if (typeof n == "string") {
    const i = document.createElement("div");
    i.innerHTML = n.trim(), n = i.querySelector("svg");
  }
  const e = {
    context: t,
    path: new Rr()
  };
  return Dg(n, e, null, null), t;
}
function Dg(n, t, e, i) {
  const r = n.children, { fillStyle: s, strokeStyle: o } = F1(n);
  s && e ? e = { ...e, ...s } : s && (e = s), o && i ? i = { ...i, ...o } : o && (i = o), t.context.fillStyle = e, t.context.strokeStyle = i;
  let a, l, h, c, p, f, u, m, g, y, b, T, C, P, S, I, w;
  switch (n.nodeName.toLowerCase()) {
    case "path":
      P = n.getAttribute("d"), S = new Rr(P), t.context.path(S), e && t.context.fill(), i && t.context.stroke();
      break;
    case "circle":
      u = ne(n, "cx", 0), m = ne(n, "cy", 0), g = ne(n, "r", 0), t.context.ellipse(u, m, g, g), e && t.context.fill(), i && t.context.stroke();
      break;
    case "rect":
      a = ne(n, "x", 0), l = ne(n, "y", 0), I = ne(n, "width", 0), w = ne(n, "height", 0), y = ne(n, "rx", 0), b = ne(n, "ry", 0), y || b ? t.context.roundRect(a, l, I, w, y || b) : t.context.rect(a, l, I, w), e && t.context.fill(), i && t.context.stroke();
      break;
    case "ellipse":
      u = ne(n, "cx", 0), m = ne(n, "cy", 0), y = ne(n, "rx", 0), b = ne(n, "ry", 0), t.context.beginPath(), t.context.ellipse(u, m, y, b), e && t.context.fill(), i && t.context.stroke();
      break;
    case "line":
      h = ne(n, "x1", 0), c = ne(n, "y1", 0), p = ne(n, "x2", 0), f = ne(n, "y2", 0), t.context.beginPath(), t.context.moveTo(h, c), t.context.lineTo(p, f), i && t.context.stroke();
      break;
    case "polygon":
      C = n.getAttribute("points"), T = C.match(/\d+/g).map((_) => parseInt(_, 10)), t.context.poly(T, !0), e && t.context.fill(), i && t.context.stroke();
      break;
    case "polyline":
      C = n.getAttribute("points"), T = C.match(/\d+/g).map((_) => parseInt(_, 10)), t.context.poly(T, !1), i && t.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${n.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let _ = 0; _ < r.length; _++)
    Dg(r[_], t, e, i);
}
function ne(n, t, e) {
  const i = n.getAttribute(t);
  return i ? Number(i) : e;
}
function F1(n) {
  const t = n.getAttribute("style"), e = {}, i = {};
  let r = !1, s = !1;
  if (t) {
    const o = t.split(";");
    for (let a = 0; a < o.length; a++) {
      const l = o[a], [h, c] = l.split(":");
      switch (h) {
        case "stroke":
          c !== "none" && (e.color = Yt.shared.setValue(c).toNumber(), s = !0);
          break;
        case "stroke-width":
          e.width = Number(c);
          break;
        case "fill":
          c !== "none" && (r = !0, i.color = Yt.shared.setValue(c).toNumber());
          break;
        case "fill-opacity":
          i.alpha = Number(c);
          break;
        case "stroke-opacity":
          e.alpha = Number(c);
          break;
        case "opacity":
          i.alpha = Number(c), e.alpha = Number(c);
          break;
      }
    }
  } else {
    const o = n.getAttribute("stroke");
    o && o !== "none" && (s = !0, e.color = Yt.shared.setValue(o).toNumber(), e.width = ne(n, "stroke-width", 1));
    const a = n.getAttribute("fill");
    a && a !== "none" && (r = !0, i.color = Yt.shared.setValue(a).toNumber());
  }
  return {
    strokeStyle: s ? e : null,
    fillStyle: r ? i : null
  };
}
function L1(n) {
  return Yt.isColorLike(n);
}
function Np(n) {
  return n instanceof Ja;
}
function Up(n) {
  return n instanceof Xs;
}
function N1(n, t, e) {
  const i = Yt.shared.setValue(t ?? 0);
  return n.color = i.toNumber(), n.alpha = i.alpha === 1 ? e.alpha : i.alpha, n.texture = ot.WHITE, { ...e, ...n };
}
function zp(n, t, e) {
  return n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, { ...e, ...n };
}
function jp(n, t, e) {
  return t.buildLinearGradient(), n.fill = t, n.color = 16777215, n.texture = t.texture, n.matrix = t.transform, { ...e, ...n };
}
function U1(n, t) {
  var e;
  const i = { ...t, ...n };
  if (i.texture) {
    if (i.texture !== ot.WHITE) {
      const o = ((e = i.matrix) == null ? void 0 : e.invert()) || new ft();
      o.translate(i.texture.frame.x, i.texture.frame.y), o.scale(1 / i.texture.source.width, 1 / i.texture.source.height), i.matrix = o;
    }
    const s = i.texture.source.style;
    s.addressMode === "clamp-to-edge" && (s.addressMode = "repeat", s.update());
  }
  const r = Yt.shared.setValue(i.color);
  return i.alpha *= r.alpha, i.color = r.toNumber(), i.matrix = i.matrix ? i.matrix.clone() : null, i;
}
function Vi(n, t) {
  if (n == null)
    return null;
  const e = {}, i = n;
  return L1(n) ? N1(e, n, t) : Np(n) ? zp(e, n, t) : Up(n) ? jp(e, n, t) : i.fill && Np(i.fill) ? zp(i, i.fill, t) : i.fill && Up(i.fill) ? jp(i, i.fill, t) : U1(i, t);
}
function va(n, t) {
  const { width: e, alignment: i, miterLimit: r, cap: s, join: o, ...a } = t, l = Vi(n, a);
  return l ? {
    width: e,
    alignment: i,
    miterLimit: r,
    cap: s,
    join: o,
    ...l
  } : null;
}
const z1 = new ve(), Gp = new ft(), Kc = class gn extends Ae {
  constructor() {
    super(...arguments), this.uid = Jt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Rr(), this._transform = new ft(), this._fillStyle = { ...gn.defaultFillStyle }, this._strokeStyle = { ...gn.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new oi(), this._boundsDirty = !0;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const t = new gn();
    return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(t) {
    this._fillStyle = Vi(t, gn.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(t) {
    this._strokeStyle = va(t, gn.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(t) {
    return this._fillStyle = Vi(t, gn.defaultFillStyle), this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(t) {
    return this._strokeStyle = Vi(t, gn.defaultStrokeStyle), this;
  }
  texture(t, e, i, r, s, o) {
    return this.instructions.push({
      action: "texture",
      data: {
        image: t,
        dx: i || 0,
        dy: r || 0,
        dw: s || t.frame.width,
        dh: o || t.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: e ? Yt.shared.setValue(e).toNumber() : 16777215
      }
    }), this.onUpdate(), this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._activePath = new Rr(), this;
  }
  fill(t, e) {
    let i;
    const r = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && r && r.action === "stroke" ? i = r.data.path : i = this._activePath.clone(), i ? (t != null && (e !== void 0 && typeof t == "number" && (mt(gt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = Vi(t, gn.defaultFillStyle)), this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: i }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  _initNextPathLocation() {
    const { x: t, y: e } = this._activePath.getLastPoint(ve.shared);
    this._activePath.clear(), this._activePath.moveTo(t, e);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(t) {
    let e;
    const i = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && i && i.action === "fill" ? e = i.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = va(t, gn.defaultStrokeStyle)), this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: e }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let t = 0; t < 2; t++) {
      const e = this.instructions[this.instructions.length - 1 - t], i = this._activePath.clone();
      if (e && (e.action === "stroke" || e.action === "fill"))
        if (e.data.hole)
          e.data.hole.addPath(i);
        else {
          e.data.hole = i;
          break;
        }
    }
    return this._initNextPathLocation(), this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(t, e, i, r, s, o) {
    this._tick++;
    const a = this._transform;
    return this._activePath.arc(
      a.a * t + a.c * e + a.tx,
      a.b * t + a.d * e + a.ty,
      i,
      r,
      s,
      o
    ), this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(t, e, i, r, s) {
    this._tick++;
    const o = this._transform;
    return this._activePath.arcTo(
      o.a * t + o.c * e + o.tx,
      o.b * t + o.d * e + o.ty,
      o.a * i + o.c * r + o.tx,
      o.b * i + o.d * r + o.ty,
      s
    ), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, i, r, s, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.arcToSvg(
      t,
      e,
      i,
      // should we rotate this with transform??
      r,
      s,
      l.a * o + l.c * a + l.tx,
      l.b * o + l.d * a + l.ty
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, i, r, s, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.bezierCurveTo(
      l.a * t + l.c * e + l.tx,
      l.b * t + l.d * e + l.ty,
      l.a * i + l.c * r + l.tx,
      l.b * i + l.d * r + l.ty,
      l.a * s + l.c * o + l.tx,
      l.b * s + l.d * o + l.ty,
      a
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    var t;
    return this._tick++, (t = this._activePath) == null || t.closePath(), this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, i, r) {
    return this._tick++, this._activePath.ellipse(t, e, i, r, this._transform.clone()), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, i) {
    return this._tick++, this._activePath.circle(t, e, i, this._transform.clone()), this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(t) {
    return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._tick++;
    const i = this._transform;
    return this._activePath.lineTo(
      i.a * t + i.c * e + i.tx,
      i.b * t + i.d * e + i.ty
    ), this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    this._tick++;
    const i = this._transform, r = this._activePath.instructions, s = i.a * t + i.c * e + i.tx, o = i.b * t + i.d * e + i.ty;
    return r.length === 1 && r[0].action === "moveTo" ? (r[0].data[0] = s, r[0].data[1] = o, this) : (this._activePath.moveTo(
      s,
      o
    ), this);
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, i, r, s) {
    this._tick++;
    const o = this._transform;
    return this._activePath.quadraticCurveTo(
      o.a * t + o.c * e + o.tx,
      o.b * t + o.d * e + o.ty,
      o.a * i + o.c * r + o.tx,
      o.b * i + o.d * r + o.ty,
      s
    ), this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, i, r) {
    return this._tick++, this._activePath.rect(t, e, i, r, this._transform.clone()), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, i, r, s) {
    return this._tick++, this._activePath.roundRect(t, e, i, r, s, this._transform.clone()), this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(t, e) {
    return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, i, r, s = 0, o) {
    return this._tick++, this._activePath.regularPoly(t, e, i, r, s, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, i, r, s, o) {
    return this._tick++, this._activePath.roundPoly(t, e, i, r, s, o), this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, i, r) {
    return this._tick++, this._activePath.roundShape(t, e, i, r), this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, i, r, s) {
    return this._tick++, this._activePath.filletRect(t, e, i, r, s), this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, i, r, s, o) {
    return this._tick++, this._activePath.chamferRect(t, e, i, r, s, o), this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(t, e, i, r, s = 0, o = 0) {
    return this._tick++, this._activePath.star(t, e, i, r, s, o, this._transform.clone()), this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(t) {
    return this._tick++, O1(t, this), this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const t = this._stateStack.pop();
    return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    }), this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._transform.identity(), this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(t) {
    return this._transform.rotate(t), this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(t, e = t) {
    return this._transform.scale(t, e), this;
  }
  setTransform(t, e, i, r, s, o) {
    return t instanceof ft ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, i, r, s, o), this);
  }
  transform(t, e, i, r, s, o) {
    return t instanceof ft ? (this._transform.append(t), this) : (Gp.set(t, e, i, r, s, o), this._transform.append(Gp), this);
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(t, e = t) {
    return this._transform.translate(t, e), this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
  }
  onUpdate() {
    this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    const t = this._bounds;
    t.clear();
    for (let e = 0; e < this.instructions.length; e++) {
      const i = this.instructions[e], r = i.action;
      if (r === "fill") {
        const s = i.data;
        t.addBounds(s.path.bounds);
      } else if (r === "texture") {
        const s = i.data;
        t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform);
      }
      if (r === "stroke") {
        const s = i.data, o = s.style.width / 2, a = s.path.bounds;
        t.addFrame(
          a.minX - o,
          a.minY - o,
          a.maxX + o,
          a.maxY + o
        );
      }
    }
    return t;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(t) {
    var e;
    if (!this.bounds.containsPoint(t.x, t.y))
      return !1;
    const i = this.instructions;
    let r = !1;
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = o.data, l = a.path;
      if (!o.action || !l)
        continue;
      const h = a.style, c = l.shapePath.shapePrimitives;
      for (let p = 0; p < c.length; p++) {
        const f = c[p].shape;
        if (!h || !f)
          continue;
        const u = c[p].transform, m = u ? u.applyInverse(t, z1) : t;
        o.action === "fill" ? r = f.contains(m.x, m.y) : r = f.strokeContains(m.x, m.y, h.width);
        const g = a.hole;
        if (g) {
          const y = (e = g.shapePath) == null ? void 0 : e.shapePrimitives;
          if (y)
            for (let b = 0; b < y.length; b++)
              y[b].shape.contains(m.x, m.y) && (r = !1);
        }
        if (r)
          return !0;
      }
    }
    return r;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
   */
  destroy(t = !1) {
    if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._fillStyle.texture && this._fillStyle.texture.destroy(e), this._strokeStyle.texture && this._strokeStyle.texture.destroy(e);
    }
    this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
  }
};
Kc.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: ot.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
Kc.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: ot.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
let tn = Kc;
const Hp = [
  "align",
  "breakWords",
  "cssOverrides",
  "fontVariant",
  "fontWeight",
  "leading",
  "letterSpacing",
  "lineHeight",
  "padding",
  "textBaseline",
  "trim",
  "whiteSpace",
  "wordWrap",
  "wordWrapWidth",
  "fontFamily",
  "fontStyle",
  "fontSize"
];
function j1(n) {
  const t = [];
  let e = 0;
  for (let i = 0; i < Hp.length; i++) {
    const r = `_${Hp[i]}`;
    t[e++] = n[r];
  }
  return e = Bg(n._fill, t, e), e = G1(n._stroke, t, e), e = H1(n.dropShadow, t, e), t.join("-");
}
function Bg(n, t, e) {
  var i;
  return n && (t[e++] = n.color, t[e++] = n.alpha, t[e++] = (i = n.fill) == null ? void 0 : i.styleKey), e;
}
function G1(n, t, e) {
  return n && (e = Bg(n, t, e), t[e++] = n.width, t[e++] = n.alignment, t[e++] = n.cap, t[e++] = n.join, t[e++] = n.miterLimit), e;
}
function H1(n, t, e) {
  return n && (t[e++] = n.alpha, t[e++] = n.angle, t[e++] = n.blur, t[e++] = n.distance, t[e++] = Yt.shared.setValue(n.color).toNumber()), e;
}
const Qc = class hr extends Ae {
  constructor(t = {}) {
    super(), q1(t);
    const e = { ...hr.defaultTextStyle, ...t };
    for (const i in e) {
      const r = i;
      this[r] = e[i];
    }
    this.update();
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(t) {
    this._align = t, this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(t) {
    this._breakWords = t, this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(t) {
    t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({ ...hr.defaultDropShadow, ...t }) : this._dropShadow = t ? this._createProxy({ ...hr.defaultDropShadow }) : null, this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(t) {
    this._fontFamily = t, this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(t) {
    typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
  }
  /**
   * The font style.
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(t) {
    this._fontStyle = t.toLowerCase(), this.update();
  }
  /**
   * The font variant.
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(t) {
    this._fontVariant = t, this.update();
  }
  /**
   * The font weight.
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(t) {
    this._fontWeight = t, this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(t) {
    this._leading = t, this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(t) {
    this._letterSpacing = t, this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(t) {
    this._lineHeight = t, this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(t) {
    this._padding = t, this.update();
  }
  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
  get trim() {
    return this._trim;
  }
  set trim(t) {
    this._trim = t, this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(t) {
    this._textBaseline = t, this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(t) {
    this._whiteSpace = t, this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(t) {
    this._wordWrap = t, this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this._wordWrapWidth = t, this.update();
  }
  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
  get fill() {
    return this._originalFill;
  }
  set fill(t) {
    t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({ ...tn.defaultFillStyle, ...t }, () => {
      this._fill = Vi(
        { ...this._originalFill },
        tn.defaultFillStyle
      );
    })), this._fill = Vi(
      t === 0 ? "black" : t,
      tn.defaultFillStyle
    ), this.update());
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(t) {
    t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({ ...tn.defaultStrokeStyle, ...t }, () => {
      this._stroke = va(
        { ...this._originalStroke },
        tn.defaultStrokeStyle
      );
    })), this._stroke = va(t, tn.defaultStrokeStyle), this.update());
  }
  _generateKey() {
    return this._styleKey = j1(this), this._styleKey;
  }
  update() {
    this._styleKey = null, this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const t = hr.defaultTextStyle;
    for (const e in t)
      this[e] = t[e];
  }
  get styleKey() {
    return this._styleKey || this._generateKey();
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new hr({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth
    });
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
   */
  destroy(t = !1) {
    var e, i, r, s;
    if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const o = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      (e = this._fill) != null && e.texture && this._fill.texture.destroy(o), (i = this._originalFill) != null && i.texture && this._originalFill.texture.destroy(o), (r = this._stroke) != null && r.texture && this._stroke.texture.destroy(o), (s = this._originalStroke) != null && s.texture && this._originalStroke.texture.destroy(o);
    }
    this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
  }
  _createProxy(t, e) {
    return new Proxy(t, {
      set: (i, r, s) => (i[r] = s, e == null || e(r, s), this.update(), !0)
    });
  }
  _isFillStyle(t) {
    return (t ?? null) !== null && !(Yt.isColorLike(t) || t instanceof Xs || t instanceof Ja);
  }
};
Qc.defaultDropShadow = {
  /** Set alpha for the drop shadow */
  alpha: 1,
  /** Set a angle of the drop shadow */
  angle: Math.PI / 6,
  /** Set a shadow blur radius */
  blur: 0,
  /** A fill style to be used on the  e.g., 'red', '#00FF00' */
  color: "black",
  /** Set a distance of the drop shadow */
  distance: 5
};
Qc.defaultTextStyle = {
  /**
   * See {@link TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link TextStyle.breakWords} */
  breakWords: !1,
  /** See {@link TextStyle.dropShadow} */
  dropShadow: null,
  /**
   * See {@link TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link TextStyle.fontSize}
   * @type {number|string}
   */
  fontSize: 26,
  /**
   * See {@link TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link TextStyle.leading} */
  leading: 0,
  /** See {@link TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link TextStyle.lineHeight} */
  lineHeight: 0,
  /** See {@link TextStyle.padding} */
  padding: 0,
  /**
   * See {@link TextStyle.stroke}
   * @type {string|number}
   */
  stroke: null,
  /**
   * See {@link TextStyle.textBaseline}
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link TextStyle.trim} */
  trim: !1,
  /**
   * See {@link TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link TextStyle.wordWrap} */
  wordWrap: !1,
  /** See {@link TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let Hi = Qc;
function q1(n) {
  const t = n;
  if (typeof t.dropShadow == "boolean" && t.dropShadow) {
    const e = Hi.defaultDropShadow;
    n.dropShadow = {
      alpha: t.dropShadowAlpha ?? e.alpha,
      angle: t.dropShadowAngle ?? e.angle,
      blur: t.dropShadowBlur ?? e.blur,
      color: t.dropShadowColor ?? e.color,
      distance: t.dropShadowDistance ?? e.distance
    };
  }
  if (t.strokeThickness !== void 0) {
    mt(gt, "strokeThickness is now a part of stroke");
    const e = t.stroke;
    let i = {};
    if (Yt.isColorLike(e))
      i.color = e;
    else if (e instanceof Xs || e instanceof Ja)
      i.fill = e;
    else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill"))
      i = e;
    else
      throw new Error("Invalid stroke value.");
    n.stroke = {
      ...i,
      width: t.strokeThickness
    };
  }
  if (Array.isArray(t.fillGradientStops)) {
    mt(gt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let e;
    n.fontSize == null ? n.fontSize = Hi.defaultTextStyle.fontSize : typeof n.fontSize == "string" ? e = parseInt(n.fontSize, 10) : e = n.fontSize;
    const i = new Xs(0, 0, 0, e * 1.7), r = t.fillGradientStops.map((s) => Yt.shared.setValue(s).toNumber());
    r.forEach((s, o) => {
      const a = o / (r.length - 1);
      i.addColorStop(a, s);
    }), n.fill = {
      fill: i
    };
  }
}
class W1 {
  constructor(t) {
    this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(t, e) {
    const i = Bt.get().createCanvas();
    i.width = t, i.height = e;
    const r = i.getContext("2d");
    return { canvas: i, context: r };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(t, e, i = 1) {
    t = Math.ceil(t * i - 1e-6), e = Math.ceil(e * i - 1e-6), t = tp(t), e = tp(e);
    const r = (t << 17) + (e << 1);
    this._canvasPool[r] || (this._canvasPool[r] = []);
    let s = this._canvasPool[r].pop();
    return s || (s = this._createCanvasAndContext(t, e)), s;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(t) {
    const e = t.canvas, { width: i, height: r } = e, s = (i << 17) + (r << 1);
    t.context.clearRect(0, 0, i, r), this._canvasPool[s].push(t);
  }
  clear() {
    this._canvasPool = {};
  }
}
const qp = new W1(), Y1 = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function Zh(n) {
  const t = typeof n.fontSize == "number" ? `${n.fontSize}px` : n.fontSize;
  let e = n.fontFamily;
  Array.isArray(n.fontFamily) || (e = n.fontFamily.split(","));
  for (let i = e.length - 1; i >= 0; i--) {
    let r = e[i].trim();
    !/([\"\'])[^\'\"]+\1/.test(r) && !Y1.includes(r) && (r = `"${r}"`), e[i] = r;
  }
  return `${n.fontStyle} ${n.fontVariant} ${n.fontWeight} ${t} ${e.join(",")}`;
}
const uh = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, pn = class X {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let t = X._experimentalLetterSpacingSupported;
    if (t !== void 0) {
      const e = Bt.get().getCanvasRenderingContext2D().prototype;
      t = X._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
    }
    return t;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(t, e, i, r, s, o, a, l, h) {
    this.text = t, this.style = e, this.width = i, this.height = r, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = h;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(t = " ", e, i = X._canvas, r = e.wordWrap) {
    var s;
    const o = `${t}:${e.styleKey}`;
    if (X._measurementCache[o])
      return X._measurementCache[o];
    const a = Zh(e), l = X.measureFont(a);
    l.fontSize === 0 && (l.fontSize = e.fontSize, l.ascent = e.fontSize);
    const h = X.__context;
    h.font = a;
    const c = (r ? X._wordWrap(t, e, i) : t).split(/(?:\r\n|\r|\n)/), p = new Array(c.length);
    let f = 0;
    for (let b = 0; b < c.length; b++) {
      const T = X._measureText(c[b], e.letterSpacing, h);
      p[b] = T, f = Math.max(f, T);
    }
    const u = ((s = e._stroke) == null ? void 0 : s.width) || 0;
    let m = f + u;
    e.dropShadow && (m += e.dropShadow.distance);
    const g = e.lineHeight || l.fontSize;
    let y = Math.max(g, l.fontSize + u) + (c.length - 1) * (g + e.leading);
    return e.dropShadow && (y += e.dropShadow.distance), new X(
      t,
      e,
      m,
      y,
      c,
      p,
      g + e.leading,
      f,
      l
    );
  }
  static _measureText(t, e, i) {
    let r = !1;
    X.experimentalLetterSpacingSupported && (X.experimentalLetterSpacing ? (i.letterSpacing = `${e}px`, i.textLetterSpacing = `${e}px`, r = !0) : (i.letterSpacing = "0px", i.textLetterSpacing = "0px"));
    const s = i.measureText(t);
    let o = s.width;
    const a = -s.actualBoundingBoxLeft;
    let l = s.actualBoundingBoxRight - a;
    if (o > 0)
      if (r)
        o -= e, l -= e;
      else {
        const h = (X.graphemeSegmenter(t).length - 1) * e;
        o += h, l += h;
      }
    return Math.max(o, l);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(t, e, i = X._canvas) {
    const r = i.getContext("2d", uh);
    let s = 0, o = "", a = "";
    const l = /* @__PURE__ */ Object.create(null), { letterSpacing: h, whiteSpace: c } = e, p = X._collapseSpaces(c), f = X._collapseNewlines(c);
    let u = !p;
    const m = e.wordWrapWidth + h, g = X._tokenize(t);
    for (let y = 0; y < g.length; y++) {
      let b = g[y];
      if (X._isNewline(b)) {
        if (!f) {
          a += X._addLine(o), u = !p, o = "", s = 0;
          continue;
        }
        b = " ";
      }
      if (p) {
        const C = X.isBreakingSpace(b), P = X.isBreakingSpace(o[o.length - 1]);
        if (C && P)
          continue;
      }
      const T = X._getFromCache(b, h, l, r);
      if (T > m)
        if (o !== "" && (a += X._addLine(o), o = "", s = 0), X.canBreakWords(b, e.breakWords)) {
          const C = X.wordWrapSplit(b);
          for (let P = 0; P < C.length; P++) {
            let S = C[P], I = S, w = 1;
            for (; C[P + w]; ) {
              const x = C[P + w];
              if (!X.canBreakChars(I, x, b, P, e.breakWords))
                S += x;
              else
                break;
              I = x, w++;
            }
            P += w - 1;
            const _ = X._getFromCache(S, h, l, r);
            _ + s > m && (a += X._addLine(o), u = !1, o = "", s = 0), o += S, s += _;
          }
        } else {
          o.length > 0 && (a += X._addLine(o), o = "", s = 0);
          const C = y === g.length - 1;
          a += X._addLine(b, !C), u = !1, o = "", s = 0;
        }
      else
        T + s > m && (u = !1, a += X._addLine(o), o = "", s = 0), (o.length > 0 || !X.isBreakingSpace(b) || u) && (o += b, s += T);
    }
    return a += X._addLine(o, !1), a;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(t, e = !0) {
    return t = X._trimRight(t), t = e ? `${t}
` : t, t;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(t, e, i, r) {
    let s = i[t];
    return typeof s != "number" && (s = X._measureText(t, e, r) + e, i[t] = s), s;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(t) {
    return t === "normal" || t === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(t) {
    return t === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(t) {
    if (typeof t != "string")
      return "";
    for (let e = t.length - 1; e >= 0; e--) {
      const i = t[e];
      if (!X.isBreakingSpace(i))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(t) {
    return typeof t != "string" ? !1 : X._newlines.includes(t.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(t, e) {
    return typeof t != "string" ? !1 : X._breakingSpaces.includes(t.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(t) {
    const e = [];
    let i = "";
    if (typeof t != "string")
      return e;
    for (let r = 0; r < t.length; r++) {
      const s = t[r], o = t[r + 1];
      if (X.isBreakingSpace(s, o) || X._isNewline(s)) {
        i !== "" && (e.push(i), i = ""), e.push(s);
        continue;
      }
      i += s;
    }
    return i !== "" && e.push(i), e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(t, e) {
    return e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(t, e, i, r, s) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(t) {
    return X.graphemeSegmenter(t);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(t) {
    if (X._fonts[t])
      return X._fonts[t];
    const e = X._context;
    e.font = t;
    const i = e.measureText(X.METRICS_STRING + X.BASELINE_SYMBOL), r = {
      ascent: i.actualBoundingBoxAscent,
      descent: i.actualBoundingBoxDescent,
      fontSize: i.actualBoundingBoxAscent + i.actualBoundingBoxDescent
    };
    return X._fonts[t] = r, r;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(t = "") {
    t ? delete X._fonts[t] : X._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!X.__canvas) {
      let t;
      try {
        const e = new OffscreenCanvas(0, 0), i = e.getContext("2d", uh);
        if (i != null && i.measureText)
          return X.__canvas = e, e;
        t = Bt.get().createCanvas();
      } catch {
        t = Bt.get().createCanvas();
      }
      t.width = t.height = 10, X.__canvas = t;
    }
    return X.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return X.__context || (X.__context = X._canvas.getContext("2d", uh)), X.__context;
  }
};
pn.METRICS_STRING = "|ÉqÅ";
pn.BASELINE_SYMBOL = "M";
pn.BASELINE_MULTIPLIER = 1.4;
pn.HEIGHT_MULTIPLIER = 2;
pn.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
    const n = new Intl.Segmenter();
    return (t) => [...n.segment(t)].map((e) => e.segment);
  }
  return (n) => [...n];
})();
pn.experimentalLetterSpacing = !1;
pn._fonts = {};
pn._newlines = [
  10,
  // line feed
  13
  // carriage return
];
pn._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
pn._measurementCache = {};
let $h = pn;
function Wp(n, t) {
  if (n.texture === ot.WHITE && !n.fill)
    return Yt.shared.setValue(n.color).setAlpha(n.alpha ?? 1).toHexa();
  if (n.fill) {
    if (n.fill instanceof Ja) {
      const e = n.fill, i = t.createPattern(e.texture.source.resource, "repeat"), r = e.transform.copyTo(ft.shared);
      return r.scale(
        e.texture.frame.width,
        e.texture.frame.height
      ), i.setTransform(r), i;
    } else if (n.fill instanceof Xs) {
      const e = n.fill;
      if (e.type === "linear") {
        const i = t.createLinearGradient(
          e.x0,
          e.y0,
          e.x1,
          e.y1
        );
        return e.gradientStops.forEach((r) => {
          i.addColorStop(r.offset, Yt.shared.setValue(r.color).toHex());
        }), i;
      }
    }
  } else {
    const e = t.createPattern(n.texture.source.resource, "repeat"), i = n.matrix.copyTo(ft.shared);
    return i.scale(n.texture.frame.width, n.texture.frame.height), e.setTransform(i), e;
  }
  return jt("FillStyle not recognised", n), "red";
}
function Og(n) {
  if (n === "")
    return [];
  typeof n == "string" && (n = [n]);
  const t = [];
  for (let e = 0, i = n.length; e < i; e++) {
    const r = n[e];
    if (Array.isArray(r)) {
      if (r.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
      if (r[0].length === 0 || r[1].length === 0)
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      const s = r[0].charCodeAt(0), o = r[1].charCodeAt(0);
      if (o < s)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let a = s, l = o; a <= l; a++)
        t.push(String.fromCharCode(a));
    } else
      t.push(...Array.from(r));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
const Fg = class Lg extends yg {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(t) {
    super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1;
    const e = { ...Lg.defaultOptions, ...t };
    this._textureSize = e.textureSize, this._mipmap = e.mipmap;
    const i = e.style.clone();
    e.overrideFill && (i._fill.color = 16777215, i._fill.alpha = 1, i._fill.texture = ot.WHITE, i._fill.fill = null), this.applyFillAsTint = e.overrideFill;
    const r = i.fontSize;
    i.fontSize = this.baseMeasurementFontSize;
    const s = Zh(i);
    e.overrideSize ? i._stroke && (i._stroke.width *= this.baseRenderedFontSize / r) : i.fontSize = this.baseRenderedFontSize = r, this._style = i, this._skipKerning = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = $h.measureFont(s), this.lineHeight = i.lineHeight || this.fontMetrics.fontSize || i.fontSize;
  }
  ensureCharacters(t) {
    var e, i;
    const r = Og(t).filter((y) => !this._currentChars.includes(y)).filter((y, b, T) => T.indexOf(y) === b);
    if (!r.length)
      return;
    this._currentChars = [...this._currentChars, ...r];
    let s;
    this._currentPageIndex === -1 ? s = this._nextPage() : s = this.pages[this._currentPageIndex];
    let { canvas: o, context: a } = s.canvasAndContext, l = s.texture.source;
    const h = this._style;
    let c = this._currentX, p = this._currentY;
    const f = this.baseRenderedFontSize / this.baseMeasurementFontSize, u = this._padding * f;
    let m = 0, g = !1;
    for (let y = 0; y < r.length; y++) {
      const b = r[y], T = $h.measureText(b, h, o, !1), C = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * T.width);
      T.lineHeight = T.height;
      const P = T.width * f, S = T.height * f, I = C + u * 2, w = S + u * 2;
      if (g = !1, b !== `
` && b !== "\r" && b !== "	" && b !== " " && (g = !0, m = Math.ceil(Math.max(w, m))), c + I > this._textureSize && (p += m, m = w, c = 0, p + m > this._textureSize)) {
        l.update();
        const x = this._nextPage();
        o = x.canvasAndContext.canvas, a = x.canvasAndContext.context, l = x.texture.source, p = 0;
      }
      const _ = P / f - (((e = h.dropShadow) == null ? void 0 : e.distance) ?? 0) - (((i = h._stroke) == null ? void 0 : i.width) ?? 0);
      if (this.chars[b] = {
        id: b.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance: _,
        kerning: {}
      }, g) {
        this._drawGlyph(
          a,
          T,
          c + u,
          p + u,
          f,
          h
        );
        const x = l.width * f, A = l.height * f, R = new Wt(
          c / x * l.width,
          p / A * l.height,
          I / x * l.width,
          w / A * l.height
        );
        this.chars[b].texture = new ot({
          source: l,
          frame: R
        }), c += Math.ceil(I);
      }
    }
    l.update(), this._currentX = c, this._currentY = p, this._skipKerning && this._applyKerning(r, a);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    return mt(gt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  _applyKerning(t, e) {
    const i = this._measureCache;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      for (let o = 0; o < this._currentChars.length; o++) {
        const a = this._currentChars[o];
        let l = i[s];
        l || (l = i[s] = e.measureText(s).width);
        let h = i[a];
        h || (h = i[a] = e.measureText(a).width);
        let c = e.measureText(s + a).width, p = c - (l + h);
        p && (this.chars[s].kerning[a] = p), c = e.measureText(s + a).width, p = c - (l + h), p && (this.chars[a].kerning[s] = p);
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const t = this.resolution, e = qp.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      t
    );
    this._setupContext(e.context, this._style, t);
    const i = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), r = new ot({
      source: new Hr({
        resource: e.canvas,
        resolution: i,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    }), s = {
      canvasAndContext: e,
      texture: r
    };
    return this.pages[this._currentPageIndex] = s, s;
  }
  // canvas style!
  _setupContext(t, e, i) {
    e.fontSize = this.baseRenderedFontSize, t.scale(i, i), t.font = Zh(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
    const r = e._stroke, s = (r == null ? void 0 : r.width) ?? 0;
    if (r && (t.lineWidth = s, t.lineJoin = r.join, t.miterLimit = r.miterLimit, t.strokeStyle = Wp(r, t)), e._fill && (t.fillStyle = Wp(e._fill, t)), e.dropShadow) {
      const o = e.dropShadow, a = Yt.shared.setValue(o.color).toArray(), l = o.blur * i, h = o.distance * i;
      t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`, t.shadowBlur = l, t.shadowOffsetX = Math.cos(o.angle) * h, t.shadowOffsetY = Math.sin(o.angle) * h;
    } else
      t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  }
  _drawGlyph(t, e, i, r, s, o) {
    const a = e.text, l = e.fontProperties, h = o._stroke, c = ((h == null ? void 0 : h.width) ?? 0) * s, p = i + c / 2, f = r - c / 2, u = l.descent * s, m = e.lineHeight * s;
    o.stroke && c && t.strokeText(a, p, f + m - u), o._fill && t.fillText(a, p, f + m - u);
  }
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { canvasAndContext: e, texture: i } = this.pages[t];
      qp.returnCanvasAndContext(e), i.destroy(!0);
    }
    this.pages = null;
  }
};
Fg.defaultOptions = {
  textureSize: 512,
  style: new Hi(),
  mipmap: !0
};
let Yp = Fg;
function X1(n, t, e, i) {
  const r = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: t.fontSize / e.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  r.offsetY = e.baseLineOffset;
  let s = r.lines[0], o = null, a = !0;
  const l = {
    spaceWord: !1,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  }, h = (m) => {
    const g = s.width;
    for (let y = 0; y < l.index; y++) {
      const b = m.positions[y];
      s.chars.push(m.chars[y]), s.charPositions.push(b + g);
    }
    s.width += m.width, a = !1, l.width = 0, l.index = 0, l.chars.length = 0;
  }, c = () => {
    let m = s.chars.length - 1;
    if (i) {
      let g = s.chars[m];
      for (; g === " "; )
        s.width -= e.chars[g].xAdvance, g = s.chars[--m];
    }
    r.width = Math.max(r.width, s.width), s = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    }, a = !0, r.lines.push(s), r.height += e.lineHeight;
  }, p = e.baseMeasurementFontSize / t.fontSize, f = t.letterSpacing * p, u = t.wordWrapWidth * p;
  for (let m = 0; m < n.length + 1; m++) {
    let g;
    const y = m === n.length;
    y || (g = n[m]);
    const b = e.chars[g] || e.chars[" "];
    if (/(?:\s)/.test(g) || g === "\r" || g === `
` || y) {
      if (!a && t.wordWrap && s.width + l.width - f > u ? (c(), h(l), y || s.charPositions.push(0)) : (l.start = s.width, h(l), y || s.charPositions.push(0)), g === "\r" || g === `
`)
        s.width !== 0 && c();
      else if (!y) {
        const T = b.xAdvance + (b.kerning[o] || 0) + f;
        s.width += T, s.spaceWidth = T, s.spacesIndex.push(s.charPositions.length), s.chars.push(g);
      }
    } else {
      const T = b.kerning[o] || 0, C = b.xAdvance + T + f;
      l.positions[l.index++] = l.width + T, l.chars.push(g), l.width += C;
    }
    o = g;
  }
  return c(), t.align === "center" ? K1(r) : t.align === "right" ? Q1(r) : t.align === "justify" && J1(r), r;
}
function K1(n) {
  for (let t = 0; t < n.lines.length; t++) {
    const e = n.lines[t], i = n.width / 2 - e.width / 2;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += i;
  }
}
function Q1(n) {
  for (let t = 0; t < n.lines.length; t++) {
    const e = n.lines[t], i = n.width - e.width;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += i;
  }
}
function J1(n) {
  const t = n.width;
  for (let e = 0; e < n.lines.length; e++) {
    const i = n.lines[e];
    let r = 0, s = i.spacesIndex[r++], o = 0;
    const a = i.spacesIndex.length, l = (t - i.width) / a;
    for (let h = 0; h < i.charPositions.length; h++)
      h === s && (s = i.spacesIndex[r++], o += l), i.charPositions[h] += o;
  }
}
let Xo = 0;
class Z1 {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: !1
    };
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(t, e) {
    var i;
    let r = `${e.fontFamily}-bitmap`, s = !0;
    if (e._fill.fill && !e._stroke)
      r += e._fill.fill.styleKey, s = !1;
    else if (e._stroke || e.dropShadow) {
      let a = e.styleKey;
      a = a.substring(0, a.lastIndexOf("-")), r = `${a}-bitmap`, s = !1;
    }
    if (!Mt.has(r)) {
      const a = new Yp({
        style: e,
        overrideFill: s,
        overrideSize: !0,
        ...this.defaultOptions
      });
      Xo++, Xo > 50 && jt("BitmapText", `You have dynamically created ${Xo} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", () => {
        Xo--, Mt.remove(r);
      }), Mt.set(
        r,
        a
      );
    }
    const o = Mt.get(r);
    return (i = o.ensureCharacters) == null || i.call(o, t), o;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(t, e, i = !0) {
    const r = this.getFont(t, e);
    return X1([...t], e, r, i);
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(t, e, i = !0) {
    return this.getLayout(t, e, i);
  }
  // eslint-disable-next-line max-len
  install(...t) {
    var e, i, r, s;
    let o = t[0];
    typeof o == "string" && (o = {
      name: o,
      style: t[1],
      chars: (e = t[2]) == null ? void 0 : e.chars,
      resolution: (i = t[2]) == null ? void 0 : i.resolution,
      padding: (r = t[2]) == null ? void 0 : r.padding,
      skipKerning: (s = t[2]) == null ? void 0 : s.skipKerning
    }, mt(gt, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
    const a = o == null ? void 0 : o.name;
    if (!a)
      throw new Error("[BitmapFontManager] Property `name` is required.");
    o = { ...this.defaultOptions, ...o };
    const l = o.style, h = l instanceof Hi ? l : new Hi(l), c = h._fill.fill !== null && h._fill.fill !== void 0, p = new Yp({
      style: h,
      overrideFill: c,
      skipKerning: o.skipKerning,
      padding: o.padding,
      resolution: o.resolution,
      overrideSize: !1
    }), f = Og(o.chars);
    return p.ensureCharacters(f.join("")), Mt.set(`${a}-bitmap`, p), p.once("destroy", () => Mt.remove(`${a}-bitmap`)), p;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(t) {
    const e = `${t}-bitmap`, i = Mt.get(e);
    i && i.destroy();
  }
}
const tc = new Z1();
class Ng extends yg {
  constructor(t, e) {
    super();
    const { textures: i, data: r } = t;
    Object.keys(r.pages).forEach((s) => {
      const o = r.pages[parseInt(s, 10)], a = i[o.id];
      this.pages.push({ texture: a });
    }), Object.keys(r.chars).forEach((s) => {
      const o = r.chars[s], {
        frame: a,
        source: l
      } = i[o.page], h = new Wt(
        o.x + a.x,
        o.y + a.y,
        o.width,
        o.height
      ), c = new ot({
        source: l,
        frame: h
      });
      this.chars[s] = {
        id: s.codePointAt(0),
        xOffset: o.xOffset,
        yOffset: o.yOffset,
        xAdvance: o.xAdvance,
        kerning: o.kerning ?? {},
        texture: c
      };
    }), this.baseRenderedFontSize = r.fontSize, this.baseMeasurementFontSize = r.fontSize, this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: r.fontSize
    }, this.baseLineOffset = r.baseLineOffset, this.lineHeight = r.lineHeight, this.fontFamily = r.fontFamily, this.distanceField = r.distanceField ?? {
      type: "none",
      range: 0
    }, this.url = e;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { texture: e } = this.pages[t];
      e.destroy(!0);
    }
    this.pages = null;
  }
  /**
   * Generates a bitmap-font for the given style and character set
   * @param options - Setup options for font generation.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.install('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
   */
  static install(t) {
    tc.install(t);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  static uninstall(t) {
    tc.uninstall(t);
  }
}
const dh = {
  test(n) {
    return typeof n == "string" && n.startsWith("info face=");
  },
  parse(n) {
    const t = n.match(/^[a-z]+\s+.+$/gm), e = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const p in t) {
      const f = t[p].match(/^[a-z]+/gm)[0], u = t[p].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), m = {};
      for (const g in u) {
        const y = u[g].split("="), b = y[0], T = y[1].replace(/"/gm, ""), C = parseFloat(T), P = isNaN(C) ? T : C;
        m[b] = P;
      }
      e[f].push(m);
    }
    const i = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, [r] = e.info, [s] = e.common, [o] = e.distanceField ?? [];
    o && (i.distanceField = {
      range: parseInt(o.distanceRange, 10),
      type: o.fieldType
    }), i.fontSize = parseInt(r.size, 10), i.fontFamily = r.face, i.lineHeight = parseInt(s.lineHeight, 10);
    const a = e.page;
    for (let p = 0; p < a.length; p++)
      i.pages.push({
        id: parseInt(a[p].id, 10) || 0,
        file: a[p].file
      });
    const l = {};
    i.baseLineOffset = i.lineHeight - parseInt(s.base, 10);
    const h = e.char;
    for (let p = 0; p < h.length; p++) {
      const f = h[p], u = parseInt(f.id, 10);
      let m = f.letter ?? f.char ?? String.fromCharCode(u);
      m === "space" && (m = " "), l[u] = m, i.chars[m] = {
        id: u,
        // texture deets..
        page: parseInt(f.page, 10) || 0,
        x: parseInt(f.x, 10),
        y: parseInt(f.y, 10),
        width: parseInt(f.width, 10),
        height: parseInt(f.height, 10),
        xOffset: parseInt(f.xoffset, 10),
        yOffset: parseInt(f.yoffset, 10),
        xAdvance: parseInt(f.xadvance, 10),
        kerning: {}
      };
    }
    const c = e.kerning || [];
    for (let p = 0; p < c.length; p++) {
      const f = parseInt(c[p].first, 10), u = parseInt(c[p].second, 10), m = parseInt(c[p].amount, 10);
      i.chars[l[u]].kerning[l[f]] = m;
    }
    return i;
  }
}, Xp = {
  test(n) {
    const t = n;
    return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(n) {
    const t = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, e = n.getElementsByTagName("info")[0], i = n.getElementsByTagName("common")[0], r = n.getElementsByTagName("distanceField")[0];
    r && (t.distanceField = {
      type: r.getAttribute("fieldType"),
      range: parseInt(r.getAttribute("distanceRange"), 10)
    });
    const s = n.getElementsByTagName("page"), o = n.getElementsByTagName("char"), a = n.getElementsByTagName("kerning");
    t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(i.getAttribute("lineHeight"), 10);
    for (let h = 0; h < s.length; h++)
      t.pages.push({
        id: parseInt(s[h].getAttribute("id"), 10) || 0,
        file: s[h].getAttribute("file")
      });
    const l = {};
    t.baseLineOffset = t.lineHeight - parseInt(i.getAttribute("base"), 10);
    for (let h = 0; h < o.length; h++) {
      const c = o[h], p = parseInt(c.getAttribute("id"), 10);
      let f = c.getAttribute("letter") ?? c.getAttribute("char") ?? String.fromCharCode(p);
      f === "space" && (f = " "), l[p] = f, t.chars[f] = {
        id: p,
        // texture deets..
        page: parseInt(c.getAttribute("page"), 10) || 0,
        x: parseInt(c.getAttribute("x"), 10),
        y: parseInt(c.getAttribute("y"), 10),
        width: parseInt(c.getAttribute("width"), 10),
        height: parseInt(c.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(c.getAttribute("xoffset"), 10),
        yOffset: parseInt(c.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(c.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let h = 0; h < a.length; h++) {
      const c = parseInt(a[h].getAttribute("first"), 10), p = parseInt(a[h].getAttribute("second"), 10), f = parseInt(a[h].getAttribute("amount"), 10);
      t.chars[l[p]].kerning[l[c]] = f;
    }
    return t;
  }
}, Kp = {
  test(n) {
    return typeof n == "string" && n.includes("<font>") ? Xp.test(Bt.get().parseXML(n)) : !1;
  },
  parse(n) {
    return Xp.parse(Bt.get().parseXML(n));
  }
}, $1 = [".xml", ".fnt"], tw = {
  extension: {
    type: K.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (n) => n instanceof Ng,
  getCacheableAssets(n, t) {
    const e = {};
    return n.forEach((i) => {
      e[i] = t, e[`${i}-bitmap`] = t;
    }), e[`${t.fontFamily}-bitmap`] = t, e;
  }
}, ew = {
  extension: {
    type: K.LoadParser,
    priority: Hn.Normal
  },
  name: "loadBitmapFont",
  test(n) {
    return $1.includes(ue.extname(n).toLowerCase());
  },
  async testParse(n) {
    return dh.test(n) || Kp.test(n);
  },
  async parse(n, t, e) {
    const i = dh.test(n) ? dh.parse(n) : Kp.parse(n), { src: r } = t, { pages: s } = i, o = [], a = i.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: !1,
      resolution: 1
    } : {};
    for (let c = 0; c < s.length; ++c) {
      const p = s[c].file;
      let f = ue.join(ue.dirname(r), p);
      f = Nh(f, r), o.push({
        src: f,
        data: a
      });
    }
    const l = await e.load(o), h = o.map((c) => l[c.src]);
    return new Ng({
      data: i,
      textures: h
    }, r);
  },
  async load(n, t) {
    return await (await Bt.get().fetch(n)).text();
  },
  async unload(n, t, e) {
    await Promise.all(n.pages.map((i) => e.unload(i.texture.source._sourceOrigin))), n.destroy();
  }
};
class nw {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(t, e = !1) {
    this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = e;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(t) {
    t.forEach((e) => {
      this._assetList.push(e);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < e; i++)
        t.push(this._assetList.pop());
      await this._loader.load(t), this._isLoading = !1, this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(t) {
    this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
  }
}
const iw = {
  extension: {
    type: K.CacheParser,
    name: "cacheTextureArray"
  },
  test: (n) => Array.isArray(n) && n.every((t) => t instanceof ot),
  getCacheableAssets: (n, t) => {
    const e = {};
    return n.forEach((i) => {
      t.forEach((r, s) => {
        e[i + (s === 0 ? "" : s + 1)] = r;
      });
    }), e;
  }
};
async function Ug(n) {
  if ("Image" in globalThis)
    return new Promise((t) => {
      const e = new Image();
      e.onload = () => {
        t(!0);
      }, e.onerror = () => {
        t(!1);
      }, e.src = n;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const t = await (await fetch(n)).blob();
      await createImageBitmap(t);
    } catch {
      return !1;
    }
    return !0;
  }
  return !1;
}
const rw = {
  extension: {
    type: K.DetectionParser,
    priority: 1
  },
  test: async () => Ug(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (n) => [...n, "avif"],
  remove: async (n) => n.filter((t) => t !== "avif")
}, Qp = ["png", "jpg", "jpeg"], sw = {
  extension: {
    type: K.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(!0),
  add: async (n) => [...n, ...Qp],
  remove: async (n) => n.filter((t) => !Qp.includes(t))
}, ow = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function Jc(n) {
  return ow ? !1 : document.createElement("video").canPlayType(n) !== "";
}
const aw = {
  extension: {
    type: K.DetectionParser,
    priority: 0
  },
  test: async () => Jc("video/mp4"),
  add: async (n) => [...n, "mp4", "m4v"],
  remove: async (n) => n.filter((t) => t !== "mp4" && t !== "m4v")
}, lw = {
  extension: {
    type: K.DetectionParser,
    priority: 0
  },
  test: async () => Jc("video/ogg"),
  add: async (n) => [...n, "ogv"],
  remove: async (n) => n.filter((t) => t !== "ogv")
}, hw = {
  extension: {
    type: K.DetectionParser,
    priority: 0
  },
  test: async () => Jc("video/webm"),
  add: async (n) => [...n, "webm"],
  remove: async (n) => n.filter((t) => t !== "webm")
}, cw = {
  extension: {
    type: K.DetectionParser,
    priority: 0
  },
  test: async () => Ug(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (n) => [...n, "webp"],
  remove: async (n) => n.filter((t) => t !== "webp")
};
class uw {
  constructor() {
    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
      set: (t, e, i) => (this._parsersValidated = !1, t[e] = i, !0)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = !1, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(t, e) {
    const i = {
      promise: null,
      parser: null
    };
    return i.promise = (async () => {
      var r, s;
      let o = null, a = null;
      if (e.loadParser && (a = this._parserHash[e.loadParser], a || jt(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !a) {
        for (let l = 0; l < this.parsers.length; l++) {
          const h = this.parsers[l];
          if (h.load && (r = h.test) != null && r.call(h, t, e, this)) {
            a = h;
            break;
          }
        }
        if (!a)
          return jt(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      o = await a.load(t, e, this), i.parser = a;
      for (let l = 0; l < this.parsers.length; l++) {
        const h = this.parsers[l];
        h.parse && h.parse && await ((s = h.testParse) == null ? void 0 : s.call(h, o, e, this)) && (o = await h.parse(o, e, this) || o, i.parser = h);
      }
      return o;
    })(), i;
  }
  async load(t, e) {
    this._parsersValidated || this._validateParsers();
    let i = 0;
    const r = {}, s = _a(t), o = hn(t, (h) => ({
      alias: [h],
      src: h,
      data: {}
    })), a = o.length, l = o.map(async (h) => {
      const c = ue.toAbsolute(h.src);
      if (!r[h.src])
        try {
          this.promiseCache[c] || (this.promiseCache[c] = this._getLoadPromiseAndParser(c, h)), r[h.src] = await this.promiseCache[c].promise, e && e(++i / a);
        } catch (p) {
          throw delete this.promiseCache[c], delete r[h.src], new Error(`[Loader.load] Failed to load ${c}.
${p}`);
        }
    });
    return await Promise.all(l), s ? r[o[0].src] : r;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(t) {
    const e = hn(t, (i) => ({
      alias: [i],
      src: i
    })).map(async (i) => {
      var r, s;
      const o = ue.toAbsolute(i.src), a = this.promiseCache[o];
      if (a) {
        const l = await a.promise;
        delete this.promiseCache[o], await ((s = (r = a.parser) == null ? void 0 : r.unload) == null ? void 0 : s.call(r, l, i, this));
      }
    });
    await Promise.all(e);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = !0, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && jt(`[Assets] loadParser name conflict "${e.name}"`) : jt("[Assets] loadParser should have a name"), { ...t, [e.name]: e }), {});
  }
}
function Wr(n, t) {
  if (Array.isArray(t)) {
    for (const e of t)
      if (n.startsWith(`data:${e}`))
        return !0;
    return !1;
  }
  return n.startsWith(`data:${t}`);
}
function Yr(n, t) {
  const e = n.split("?")[0], i = ue.extname(e).toLowerCase();
  return Array.isArray(t) ? t.includes(i) : i === t;
}
const dw = ".json", pw = "application/json", fw = {
  extension: {
    type: K.LoadParser,
    priority: Hn.Low
  },
  name: "loadJson",
  test(n) {
    return Wr(n, pw) || Yr(n, dw);
  },
  async load(n) {
    return await (await Bt.get().fetch(n)).json();
  }
}, mw = ".txt", gw = "text/plain", yw = {
  name: "loadTxt",
  extension: {
    type: K.LoadParser,
    priority: Hn.Low,
    name: "loadTxt"
  },
  test(n) {
    return Wr(n, gw) || Yr(n, mw);
  },
  async load(n) {
    return await (await Bt.get().fetch(n)).text();
  }
}, _w = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], vw = [".ttf", ".otf", ".woff", ".woff2"], xw = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], bw = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function ww(n) {
  const t = ue.extname(n), e = ue.basename(n, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((s) => s.charAt(0).toUpperCase() + s.slice(1));
  let i = e.length > 0;
  for (const s of e)
    if (!s.match(bw)) {
      i = !1;
      break;
    }
  let r = e.join(" ");
  return i || (r = `"${r.replace(/[\\"]/g, "\\$&")}"`), r;
}
const Aw = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function Tw(n) {
  return Aw.test(n) ? n : encodeURI(n);
}
const Sw = {
  extension: {
    type: K.LoadParser,
    priority: Hn.Low
  },
  name: "loadWebFont",
  test(n) {
    return Wr(n, xw) || Yr(n, vw);
  },
  async load(n, t) {
    var e, i, r;
    const s = Bt.get().getFontFaceSet();
    if (s) {
      const o = [], a = ((e = t.data) == null ? void 0 : e.family) ?? ww(n), l = ((r = (i = t.data) == null ? void 0 : i.weights) == null ? void 0 : r.filter((c) => _w.includes(c))) ?? ["normal"], h = t.data ?? {};
      for (let c = 0; c < l.length; c++) {
        const p = l[c], f = new FontFace(a, `url(${Tw(n)})`, {
          ...h,
          weight: p
        });
        await f.load(), s.add(f), o.push(f);
      }
      return Mt.set(`${a}-and-url`, {
        url: n,
        fontFaces: o
      }), o.length === 1 ? o[0] : o;
    }
    return jt("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(n) {
    (Array.isArray(n) ? n : [n]).forEach((t) => {
      Mt.remove(t.family), Bt.get().getFontFaceSet().delete(t);
    });
  }
};
function Zc(n, t = 1) {
  var e;
  const i = (e = qr.RETINA_PREFIX) == null ? void 0 : e.exec(n);
  return i ? parseFloat(i[1]) : t;
}
function $c(n, t, e) {
  n.label = e, n._sourceOrigin = e;
  const i = new ot({
    source: n,
    label: e
  }), r = () => {
    delete t.promiseCache[e], Mt.has(e) && Mt.remove(e);
  };
  return i.source.once("destroy", () => {
    t.promiseCache[e] && (jt("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), r());
  }), i.once("destroy", () => {
    n.destroyed || (jt("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), r());
  }), i;
}
const Ew = ".svg", Cw = "image/svg+xml", Pw = {
  extension: {
    type: K.LoadParser,
    priority: Hn.Low,
    name: "loadSVG"
  },
  name: "loadSVG",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: !1
  },
  test(n) {
    return Wr(n, Cw) || Yr(n, Ew);
  },
  async load(n, t, e) {
    return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? Rw(n) : Iw(n, t, e, this.config.crossOrigin);
  },
  unload(n) {
    n.destroy(!0);
  }
};
async function Iw(n, t, e, i) {
  var r, s, o;
  const a = await (await Bt.get().fetch(n)).blob(), l = URL.createObjectURL(a), h = new Image();
  h.src = l, h.crossOrigin = i, await h.decode(), URL.revokeObjectURL(l);
  const c = document.createElement("canvas"), p = c.getContext("2d"), f = ((r = t.data) == null ? void 0 : r.resolution) || Zc(n), u = ((s = t.data) == null ? void 0 : s.width) ?? h.width, m = ((o = t.data) == null ? void 0 : o.height) ?? h.height;
  c.width = u * f, c.height = m * f, p.drawImage(h, 0, 0, u * f, m * f);
  const { parseAsGraphicsContext: g, ...y } = t.data, b = new Hr({
    resource: c,
    alphaMode: "premultiply-alpha-on-upload",
    resolution: f,
    ...y
  });
  return $c(b, e, n);
}
async function Rw(n) {
  const t = await (await Bt.get().fetch(n)).text(), e = new tn();
  return e.svg(t), e;
}
const kw = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let xr = null, ec = class {
  constructor() {
    xr || (xr = URL.createObjectURL(new Blob([kw], { type: "application/javascript" }))), this.worker = new Worker(xr);
  }
};
ec.revokeObjectURL = function() {
  xr && (URL.revokeObjectURL(xr), xr = null);
};
const Mw = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let br = null;
class zg {
  constructor() {
    br || (br = URL.createObjectURL(new Blob([Mw], { type: "application/javascript" }))), this.worker = new Worker(br);
  }
}
zg.revokeObjectURL = function() {
  br && (URL.revokeObjectURL(br), br = null);
};
let Jp = 0, ph;
class Vw {
  constructor() {
    this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
      const { worker: e } = new ec();
      e.addEventListener("message", (i) => {
        e.terminate(), ec.revokeObjectURL(), t(i.data);
      });
    }), this._isImageBitmapSupported);
  }
  loadImageBitmap(t, e) {
    var i;
    return this._run("loadImageBitmap", [t, (i = e == null ? void 0 : e.data) == null ? void 0 : i.alphaMode]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  _getWorker() {
    ph === void 0 && (ph = navigator.hardwareConcurrency || 4);
    let t = this._workerPool.pop();
    return !t && this._createdWorkers < ph && (this._createdWorkers++, t = new zg().worker, t.addEventListener("message", (e) => {
      this._complete(e.data), this._returnWorker(e.target), this._next();
    })), t;
  }
  _returnWorker(t) {
    this._workerPool.push(t);
  }
  _complete(t) {
    t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
  }
  async _run(t, e) {
    await this._initWorkers();
    const i = new Promise((r, s) => {
      this._queue.push({ id: t, arguments: e, resolve: r, reject: s });
    });
    return this._next(), i;
  }
  _next() {
    if (!this._queue.length)
      return;
    const t = this._getWorker();
    if (!t)
      return;
    const e = this._queue.pop(), i = e.id;
    this._resolveHash[Jp] = { resolve: e.resolve, reject: e.reject }, t.postMessage({
      data: e.arguments,
      uuid: Jp++,
      id: i
    });
  }
}
const Zp = new Vw(), Dw = [".jpeg", ".jpg", ".png", ".webp", ".avif"], Bw = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function Ow(n, t) {
  var e;
  const i = await Bt.get().fetch(n);
  if (!i.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${n}: ${i.status} ${i.statusText}`);
  const r = await i.blob();
  return ((e = t == null ? void 0 : t.data) == null ? void 0 : e.alphaMode) === "premultiplied-alpha" ? createImageBitmap(r, { premultiplyAlpha: "none" }) : createImageBitmap(r);
}
const jg = {
  name: "loadTextures",
  extension: {
    type: K.LoadParser,
    priority: Hn.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous"
  },
  test(n) {
    return Wr(n, Bw) || Yr(n, Dw);
  },
  async load(n, t, e) {
    var i;
    let r = null;
    globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Zp.isImageBitmapSupported() ? r = await Zp.loadImageBitmap(n, t) : r = await Ow(n, t) : r = await new Promise((o) => {
      r = new Image(), r.crossOrigin = this.config.crossOrigin, r.src = n, r.complete ? o(r) : r.onload = () => {
        o(r);
      };
    });
    const s = new Hr({
      resource: r,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: ((i = t.data) == null ? void 0 : i.resolution) || Zc(n),
      ...t.data
    });
    return $c(s, e, n);
  },
  unload(n) {
    n.destroy(!0);
  }
}, Gg = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], Fw = Gg.map((n) => `video/${n.substring(1)}`);
function Lw(n, t, e) {
  e === void 0 && !t.startsWith("data:") ? n.crossOrigin = Uw(t) : e !== !1 && (n.crossOrigin = typeof e == "string" ? e : "anonymous");
}
function Nw(n) {
  return new Promise((t, e) => {
    n.addEventListener("canplaythrough", i), n.addEventListener("error", r), n.load();
    function i() {
      s(), t();
    }
    function r(o) {
      s(), e(o);
    }
    function s() {
      n.removeEventListener("canplaythrough", i), n.removeEventListener("error", r);
    }
  });
}
function Uw(n, t = globalThis.location) {
  if (n.startsWith("data:"))
    return "";
  t = t || globalThis.location;
  const e = new URL(n, document.baseURI);
  return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
}
const zw = {
  name: "loadVideo",
  extension: {
    type: K.LoadParser,
    name: "loadVideo"
  },
  test(n) {
    const t = Wr(n, Fw), e = Yr(n, Gg);
    return t || e;
  },
  async load(n, t, e) {
    var i, r;
    const s = {
      ...ia.defaultOptions,
      resolution: ((i = t.data) == null ? void 0 : i.resolution) || Zc(n),
      alphaMode: ((r = t.data) == null ? void 0 : r.alphaMode) || await Ym(),
      ...t.data
    }, o = document.createElement("video"), a = {
      preload: s.autoLoad !== !1 ? "auto" : void 0,
      "webkit-playsinline": s.playsinline !== !1 ? "" : void 0,
      playsinline: s.playsinline !== !1 ? "" : void 0,
      muted: s.muted === !0 ? "" : void 0,
      loop: s.loop === !0 ? "" : void 0,
      autoplay: s.autoPlay !== !1 ? "" : void 0
    };
    Object.keys(a).forEach((c) => {
      const p = a[c];
      p !== void 0 && o.setAttribute(c, p);
    }), s.muted === !0 && (o.muted = !0), Lw(o, n, s.crossorigin);
    const l = document.createElement("source");
    let h;
    if (n.startsWith("data:"))
      h = n.slice(5, n.indexOf(";"));
    else if (!n.startsWith("blob:")) {
      const c = n.split("?")[0].slice(n.lastIndexOf(".") + 1).toLowerCase();
      h = ia.MIME_TYPES[c] || `video/${c}`;
    }
    return l.src = n, h && (l.type = h), new Promise((c) => {
      const p = async () => {
        const f = new ia({ ...s, resource: o });
        o.removeEventListener("canplay", p), t.data.preload && await Nw(o), c($c(f, e, n));
      };
      o.addEventListener("canplay", p), o.appendChild(l);
    });
  },
  unload(n) {
    n.destroy(!0);
  }
}, Hg = {
  extension: {
    type: K.ResolveParser,
    name: "resolveTexture"
  },
  test: jg.test,
  parse: (n) => {
    var t;
    return {
      resolution: parseFloat(((t = qr.RETINA_PREFIX.exec(n)) == null ? void 0 : t[1]) ?? "1"),
      format: n.split(".").pop(),
      src: n
    };
  }
}, jw = {
  extension: {
    type: K.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (n) => qr.RETINA_PREFIX.test(n) && n.endsWith(".json"),
  parse: Hg.parse
};
class Gw {
  constructor() {
    this._detections = [], this._initialized = !1, this.resolver = new qr(), this.loader = new uw(), this.cache = Mt, this._backgroundLoader = new nw(this.loader), this._backgroundLoader.active = !0, this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Assets class to work, only if you want to set any initial properties
   * @param options - options to initialize the Assets manager with
   */
  async init(t = {}) {
    var e, i;
    if (this._initialized) {
      jt("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
      let a = t.manifest;
      typeof a == "string" && (a = await this.load(a)), this.resolver.addManifest(a);
    }
    const r = ((e = t.texturePreference) == null ? void 0 : e.resolution) ?? 1, s = typeof r == "number" ? [r] : r, o = await this._detectFormats({
      preferredFormats: (i = t.texturePreference) == null ? void 0 : i.format,
      skipDetections: t.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: o,
        resolution: s
      }
    }), t.preferences && this.setPreferences(t.preferences);
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(t) {
    this.resolver.add(t);
  }
  async load(t, e) {
    this._initialized || await this.init();
    const i = _a(t), r = hn(t).map((a) => {
      if (typeof a != "string") {
        const l = this.resolver.getAlias(a);
        return l.some((h) => !this.resolver.hasKey(h)) && this.add(a), Array.isArray(l) ? l[0] : l;
      }
      return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a;
    }), s = this.resolver.resolve(r), o = await this._mapLoadToResolve(s, e);
    return i ? o[r[0]] : o;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    this.resolver.addBundle(t, e);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(t, e) {
    this._initialized || await this.init();
    let i = !1;
    typeof t == "string" && (i = !0, t = [t]);
    const r = this.resolver.resolveBundle(t), s = {}, o = Object.keys(r);
    let a = 0, l = 0;
    const h = () => {
      e == null || e(++a / l);
    }, c = o.map((p) => {
      const f = r[p];
      return l += Object.keys(f).length, this._mapLoadToResolve(f, h).then((u) => {
        s[p] = u;
      });
    });
    return await Promise.all(c), i ? s[t[0]] : s;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your initial load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolve(t);
    this._backgroundLoader.add(Object.values(e));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolveBundle(t);
    Object.values(e).forEach((i) => {
      this._backgroundLoader.add(Object.values(i));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
  }
  get(t) {
    if (typeof t == "string")
      return Mt.get(t);
    const e = {};
    for (let i = 0; i < t.length; i++)
      e[i] = Mt.get(t[i]);
    return e;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(t, e) {
    const i = [...new Set(Object.values(t))];
    this._backgroundLoader.active = !1;
    const r = await this.loader.load(i, e);
    this._backgroundLoader.active = !0;
    const s = {};
    return i.forEach((o) => {
      const a = r[o.src], l = [o.src];
      o.alias && l.push(...o.alias), l.forEach((h) => {
        s[h] = a;
      }), Mt.set(l, a);
    }), s;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(t) {
    this._initialized || await this.init();
    const e = hn(t).map((r) => typeof r != "string" ? r.src : r), i = this.resolver.resolve(e);
    await this._unloadFromResolved(i);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(t) {
    this._initialized || await this.init(), t = hn(t);
    const e = this.resolver.resolveBundle(t), i = Object.keys(e).map((r) => this._unloadFromResolved(e[r]));
    await Promise.all(i);
  }
  async _unloadFromResolved(t) {
    const e = Object.values(t);
    e.forEach((i) => {
      Mt.remove(i.src);
    }), await this.loader.unload(e);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(t) {
    let e = [];
    t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
    for (const i of t.detections)
      t.skipDetections || await i.test() ? e = await i.add(e) : t.skipDetections || (e = await i.remove(e));
    return e = e.filter((i, r) => e.indexOf(i) === r), e;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(t) {
    this.loader.parsers.forEach((e) => {
      e.config && Object.keys(e.config).filter((i) => i in t).forEach((i) => {
        e.config[i] = t[i];
      });
    });
  }
}
const vn = new Gw();
xe.handleByList(K.LoadParser, vn.loader.parsers).handleByList(K.ResolveParser, vn.resolver.parsers).handleByList(K.CacheParser, vn.cache.parsers).handleByList(K.DetectionParser, vn.detections);
xe.add(
  iw,
  sw,
  rw,
  cw,
  aw,
  lw,
  hw,
  fw,
  yw,
  Sw,
  Pw,
  jg,
  zw,
  ew,
  tw,
  Hg,
  jw
);
const $p = {
  loader: K.LoadParser,
  resolver: K.ResolveParser,
  cache: K.CacheParser,
  detection: K.DetectionParser
};
xe.handle(K.Asset, (n) => {
  const t = n.ref;
  Object.entries($p).filter(([e]) => !!t[e]).forEach(([e, i]) => xe.add(Object.assign(
    t[e],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: t[e].extension ?? i }
  )));
}, (n) => {
  const t = n.ref;
  Object.keys($p).filter((e) => !!t[e]).forEach((e) => xe.remove(t[e]));
});
class Di extends Wa {
  /**
   * @param options - Options for the Graphics.
   */
  constructor(t) {
    t instanceof tn && (t = { context: t });
    const { context: e, roundPixels: i, ...r } = t || {};
    super({
      label: "Graphics",
      ...r
    }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new tn(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = i ?? !1;
  }
  set context(t) {
    t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
  }
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphic.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    t.addBounds(this._context.bounds);
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    return this._context.containsPoint(t);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
   * @param {boolean} [options.context=false] - Should destroy the context
   */
  destroy(t) {
    this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === !0 || (t == null ? void 0 : t.context) === !0) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
  }
  _callContextMethod(t, e) {
    return this.context[t](...e), this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
   * pattern object, or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(...t) {
    return this._callContextMethod("setFillStyle", t);
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   * or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(...t) {
    return this._callContextMethod("setStrokeStyle", t);
  }
  fill(...t) {
    return this._callContextMethod("fill", t);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
   * complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(...t) {
    return this._callContextMethod("stroke", t);
  }
  texture(...t) {
    return this._callContextMethod("texture", t);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...t) {
    return this._callContextMethod("arc", t);
  }
  arcTo(...t) {
    return this._callContextMethod("arcTo", t);
  }
  arcToSvg(...t) {
    return this._callContextMethod("arcToSvg", t);
  }
  bezierCurveTo(...t) {
    return this._callContextMethod("bezierCurveTo", t);
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...t) {
    return this._callContextMethod("ellipse", t);
  }
  circle(...t) {
    return this._callContextMethod("circle", t);
  }
  path(...t) {
    return this._callContextMethod("path", t);
  }
  lineTo(...t) {
    return this._callContextMethod("lineTo", t);
  }
  moveTo(...t) {
    return this._callContextMethod("moveTo", t);
  }
  quadraticCurveTo(...t) {
    return this._callContextMethod("quadraticCurveTo", t);
  }
  rect(...t) {
    return this._callContextMethod("rect", t);
  }
  roundRect(...t) {
    return this._callContextMethod("roundRect", t);
  }
  poly(...t) {
    return this._callContextMethod("poly", t);
  }
  regularPoly(...t) {
    return this._callContextMethod("regularPoly", t);
  }
  roundPoly(...t) {
    return this._callContextMethod("roundPoly", t);
  }
  roundShape(...t) {
    return this._callContextMethod("roundShape", t);
  }
  filletRect(...t) {
    return this._callContextMethod("filletRect", t);
  }
  chamferRect(...t) {
    return this._callContextMethod("chamferRect", t);
  }
  star(...t) {
    return this._callContextMethod("star", t);
  }
  svg(...t) {
    return this._callContextMethod("svg", t);
  }
  restore(...t) {
    return this._callContextMethod("restore", t);
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...t) {
    return this._callContextMethod("rotate", t);
  }
  scaleTransform(...t) {
    return this._callContextMethod("scale", t);
  }
  setTransform(...t) {
    return this._callContextMethod("setTransform", t);
  }
  transform(...t) {
    return this._callContextMethod("transform", t);
  }
  translateTransform(...t) {
    return this._callContextMethod("translate", t);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * The fill style to use.
   * @type {ConvertedFillStyle}
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(t) {
    this._context.fillStyle = t;
  }
  /**
   * The stroke style to use.
   * @type {ConvertedStrokeStyle}
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(t) {
    this._context.strokeStyle = t;
  }
  /**
   * Creates a new Graphics object.
   * Note that only the context of the object is cloned, not its transform (position,scale,etc)
   * @param deep - Whether to create a deep clone of the graphics object. If false, the context
   * will be shared between the two objects (default false). If true, the context will be
   * cloned (recommended if you need to modify the context in any way).
   * @returns - A clone of the graphics object
   */
  clone(t = !1) {
    return t ? new Di(this._context.clone()) : (this._ownedContext = null, new Di(this._context));
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(t, e, i) {
    mt(gt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const r = {};
    return t && (r.width = t), e && (r.color = e), i && (r.alpha = i), this.context.strokeStyle = r, this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(t, e) {
    mt(gt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const i = {};
    return t && (i.color = t), e && (i.alpha = e), this.context.fillStyle = i, this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    mt(gt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
    const t = this.context.strokeStyle;
    return (t.width !== tn.defaultStrokeStyle.width || t.color !== tn.defaultStrokeStyle.color || t.alpha !== tn.defaultStrokeStyle.alpha) && this.context.stroke(), this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...t) {
    return mt(gt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...t) {
    return mt(gt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...t) {
    return mt(gt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...t) {
    return mt(gt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...t) {
    return mt(gt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...t) {
    return mt(gt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
  }
}
class Hw {
  /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */
  constructor({ matrix: t, observer: e } = {}) {
    this.dirty = !0, this._matrix = t ?? new ft(), this.observer = e, this.position = new Kt(this, 0, 0), this.scale = new Kt(this, 1, 1), this.pivot = new Kt(this, 0, 0), this.skew = new Kt(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
  }
  /**
   * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
   * properties into a single matrix.
   * @readonly
   */
  get matrix() {
    const t = this._matrix;
    return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = !1), t;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   * @private
   */
  _onUpdate(t) {
    var e;
    this.dirty = !0, t === this.skew && this.updateSkew(), (e = this.observer) == null || e._onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0;
  }
  toString() {
    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(t) {
    t.decompose(this), this.dirty = !0;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew));
  }
}
const qg = class oa extends Wa {
  constructor(...t) {
    let e = t[0] || {};
    e instanceof ot && (e = { texture: e }), t.length > 1 && (mt(gt, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = { ...oa.defaultOptions, ...e };
    const {
      texture: i,
      anchor: r,
      tilePosition: s,
      tileScale: o,
      tileRotation: a,
      width: l,
      height: h,
      applyAnchorToTexture: c,
      roundPixels: p,
      ...f
    } = e ?? {};
    super({
      label: "TilingSprite",
      ...f
    }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new Kt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), this._applyAnchorToTexture = c, this.texture = i, this._width = l ?? i.width, this._height = h ?? i.height, this._tileTransform = new Hw({
      observer: {
        _onUpdate: () => this.onViewUpdate()
      }
    }), r && (this.anchor = r), this.tilePosition = s, this.tileScale = o, this.tileRotation = a, this.roundPixels = p ?? !1;
  }
  /**
   * Creates a new tiling sprite.
   * @param source - The source to create the texture from.
   * @param options - The options for creating the tiling sprite.
   * @returns A new tiling sprite.
   */
  static from(t, e = {}) {
    return typeof t == "string" ? new oa({
      texture: Mt.get(t),
      ...e
    }) : new oa({
      texture: t,
      ...e
    });
  }
  /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @member {number}
   */
  get clampMargin() {
    return this._texture.textureMatrix.clampMargin;
  }
  set clampMargin(t) {
    this._texture.textureMatrix.clampMargin = t;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { TilingSprite } from 'pixi.js';
   *
   * const sprite = new TilingSprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The offset of the image that is being tiled. */
  get tilePosition() {
    return this._tileTransform.position;
  }
  set tilePosition(t) {
    this._tileTransform.position.copyFrom(t);
  }
  /** The scaling of the image that is being tiled. */
  get tileScale() {
    return this._tileTransform.scale;
  }
  set tileScale(t) {
    typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t);
  }
  set tileRotation(t) {
    this._tileTransform.rotation = t;
  }
  /** The rotation of the image that is being tiled. */
  get tileRotation() {
    return this._tileTransform.rotation;
  }
  /** The transform of the image that is being tiled. */
  get tileTransform() {
    return this._tileTransform;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  set texture(t) {
    t || (t = ot.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /** The width of the tiling area. */
  set width(t) {
    this._width = t, this.onViewUpdate();
  }
  get width() {
    return this._width;
  }
  set height(t) {
    this._height = t, this.onViewUpdate();
  }
  /** The height of the tiling area. */
  get height() {
    return this._height;
  }
  /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" && (e = t.height ?? t.width, t = t.width), this._width = t, this._height = e ?? t, this.onViewUpdate();
  }
  /**
   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the TilingSprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = this._width, t.height = this._height, t;
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, i = this._width, r = this._height;
    t.maxX = -e._x * i, t.minX = t.maxX + i, t.maxY = -e._y * r, t.minY = t.maxY + r;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this._width, i = this._height, r = -e * this._anchor._x;
    let s = 0;
    return t.x >= r && t.x <= r + e && (s = -i * this._anchor._y, t.y >= s && t.y <= s + i);
  }
  onViewUpdate() {
    this._boundsDirty = !0, super.onViewUpdate();
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(e);
    }
    this._texture = null;
  }
};
qg.defaultOptions = {
  /** The texture to use for the sprite. */
  texture: ot.EMPTY,
  /** The anchor point of the sprite */
  anchor: { x: 0, y: 0 },
  /** The offset of the image that is being tiled. */
  tilePosition: { x: 0, y: 0 },
  /** Scaling of the image that is being tiled. */
  tileScale: { x: 1, y: 1 },
  /** The rotation of the image that is being tiled. */
  tileRotation: 0,
  /** TODO */
  applyAnchorToTexture: !1
};
let qw = qg;
class Wg extends Wa {
  constructor(t, e) {
    const { text: i, resolution: r, style: s, anchor: o, width: a, height: l, roundPixels: h, ...c } = t;
    super({
      ...c
    }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = e, this.text = i ?? "", this.style = s, this.resolution = r ?? null, this.allowChildren = !1, this._anchor = new Kt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), o && (this.anchor = o), this.roundPixels = h ?? !1, a !== void 0 && (this.width = a), l !== void 0 && (this.height = l);
  }
  /**
   * The anchor sets the origin point of the text.
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Text } from 'pixi.js';
   *
   * const text = new Text('hello world');
   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  set text(t) {
    t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(t) {
    this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
   * @type {
   * text.TextStyle |
   * Partial<text.TextStyle> |
   * text.TextStyleOptions |
   * text.HTMLTextStyle |
   * Partial<text.HTMLTextStyle> |
   * text.HTMLTextStyleOptions
   * }
   */
  set style(t) {
    var e;
    t = t || {}, (e = this._style) == null || e.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
  }
  /**
   * The local bounds of the Text.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(t) {
    this._setWidth(t, this.bounds.width);
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(t) {
    this._setHeight(t, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Text.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
  }
  /**
   * Adds the bounds of this text to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the text contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds.width, i = this.bounds.height, r = -e * this.anchor.x;
    let s = 0;
    return t.x >= r && t.x <= r + e && (s = -i * this.anchor.y, t.y >= s && t.y <= s + i);
  }
  onViewUpdate() {
    this._boundsDirty = !0, this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}:${this._resolution}`;
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   * @param {boolean} [options.style=false] - Should it destroy the style of the text
   */
  destroy(t = !1) {
    super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t != null && t.style) && this._style.destroy(t), this._style = null, this._text = null;
  }
}
function Yg(n, t) {
  let e = n[0] ?? {};
  return (typeof e == "string" || n[1]) && (mt(gt, `use new ${t}({ text: "hi!", style }) instead`), e = {
    text: e,
    style: n[1]
  }), e;
}
class Ww extends Wg {
  constructor(...t) {
    const e = Yg(t, "Text");
    super(e, Hi), this.renderPipeId = "text";
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, i = $h.measureText(
      this._text,
      this._style
    ), { width: r, height: s } = i;
    t.minX = -e._x * r, t.maxX = t.minX + r, t.minY = -e._y * s, t.maxY = t.minY + s;
  }
}
class Yw extends Wg {
  constructor(...t) {
    var e;
    const i = Yg(t, "BitmapText");
    i.style ?? (i.style = i.style || {}), (e = i.style).fill ?? (e.fill = 16777215), super(i, Hi), this.renderPipeId = "bitmapText";
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, i = tc.measureText(this.text, this._style), r = i.scale, s = i.offsetY * r;
    let o = i.width * r, a = i.height * r;
    const l = this._style._stroke;
    l && (o += l.width, a += l.width), t.minX = -e._x * o, t.maxX = t.minX + o, t.minY = -e._y * (a + s), t.maxY = t.minY + a;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(t) {
    t !== null && jt(
      // eslint-disable-next-line max-len
      "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
    );
  }
  get resolution() {
    return this._resolution;
  }
}
class tu extends ot {
  static create(t) {
    return new tu({
      source: new En(t)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(t, e, i) {
    return this.source.resize(t, e, i), this;
  }
}
xe.add(yv, _v);
var Xg = {}, el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
el.MiniSignal = void 0;
const nc = Symbol("SIGNAL");
function Xw(n) {
  return typeof n == "object" && nc in n;
}
class Kw {
  constructor() {
    this._symbol = Symbol("MiniSignal"), this._refMap = /* @__PURE__ */ new WeakMap(), this._head = void 0, this._tail = void 0, this._dispatching = !1;
  }
  hasListeners() {
    return this._head != null;
  }
  /**
   * Dispatches a signal to all registered listeners.
   */
  dispatch(...t) {
    if (this._dispatching)
      throw new Error("MiniSignal#dispatch(): Signal already dispatching.");
    let e = this._head;
    if (e == null)
      return !1;
    for (this._dispatching = !0; e != null; )
      e.fn(...t), e = e.next;
    return this._dispatching = !1, !0;
  }
  /**
   * Register a new listener.
   */
  add(t) {
    if (typeof t != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return this._createRef(this._addNode({ fn: t }));
  }
  /**
   * Remove binding object.
   */
  detach(t) {
    if (!Xw(t))
      throw new Error("MiniSignal#detach(): First arg must be a MiniSignal listener reference.");
    if (t[nc] !== this._symbol)
      throw new Error("MiniSignal#detach(): MiniSignal listener does not belong to this MiniSignal.");
    const e = this._refMap.get(t);
    return e ? (this._refMap.delete(t), this._disconnectNode(e), this._destroyNode(e), this) : this;
  }
  /**
   * Detach all listeners.
   */
  detachAll() {
    let t = this._head;
    if (t == null)
      return this;
    for (this._head = this._tail = void 0, this._refMap = /* @__PURE__ */ new WeakMap(); t != null; )
      this._destroyNode(t), t = t.next;
    return this;
  }
  _destroyNode(t) {
    t.fn = void 0, t.prev = void 0;
  }
  _disconnectNode(t) {
    t === this._head ? (this._head = t.next, t.next == null && (this._tail = void 0)) : t === this._tail && (this._tail = t.prev, this._tail != null && (this._tail.next = void 0)), t.prev != null && (t.prev.next = t.next), t.next != null && (t.next.prev = t.prev);
  }
  _addNode(t) {
    return this._head == null ? (this._head = t, this._tail = t) : (this._tail.next = t, t.prev = this._tail, this._tail = t), t;
  }
  _createRef(t) {
    const e = { [nc]: this._symbol };
    return this._refMap.set(e, t), e;
  }
  _getRef(t) {
    return this._refMap.get(t);
  }
}
el.MiniSignal = Kw;
(function(n) {
  var t = ki && ki.__createBinding || (Object.create ? function(i, r, s, o) {
    o === void 0 && (o = s);
    var a = Object.getOwnPropertyDescriptor(r, s);
    (!a || ("get" in a ? !r.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return r[s];
    } }), Object.defineProperty(i, o, a);
  } : function(i, r, s, o) {
    o === void 0 && (o = s), i[o] = r[s];
  }), e = ki && ki.__exportStar || function(i, r) {
    for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(r, s) && t(r, i, s);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), e(el, n);
})(Xg);
const xa = /* @__PURE__ */ new Map(), Ss = (n, t) => {
  let e = xa.get(n);
  return e || (e = new Xg.MiniSignal(), xa.set(n, e)), { name: n, binding: e.add(t) };
}, ba = (n, t) => {
  const e = xa.get(n);
  e && e.detach(t);
}, Pe = (n, ...t) => {
  const e = xa.get(n);
  e && e.dispatch(...t);
};
function Mn(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Kg(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n, n.__proto__ = t;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Xe = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, kr = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, eu, be, Et, rn = 1e8, wt = 1 / rn, ic = Math.PI * 2, Qw = ic / 4, Jw = 0, Qg = Math.sqrt, Zw = Math.cos, $w = Math.sin, oe = function(n) {
  return typeof n == "string";
}, Lt = function(n) {
  return typeof n == "function";
}, Nn = function(n) {
  return typeof n == "number";
}, nu = function(n) {
  return typeof n > "u";
}, Tn = function(n) {
  return typeof n == "object";
}, Ve = function(n) {
  return n !== !1;
}, iu = function() {
  return typeof window < "u";
}, Ko = function(n) {
  return Lt(n) || oe(n);
}, Jg = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, we = Array.isArray, rc = /(?:-?\.?\d|\.)+/gi, Zg = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, gr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, fh = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, $g = /[+-]=-?[.\d]+/, ty = /[^,'"\[\]\s]+/gi, tA = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, kt, yn, sc, ru, Qe = {}, wa = {}, ey, ny = function(n) {
  return (wa = qi(n, Qe)) && Fe;
}, su = function(n, t) {
  return console.warn("Invalid property", n, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, Js = function(n, t) {
  return !t && console.warn(n);
}, iy = function(n, t) {
  return n && (Qe[n] = t) && wa && (wa[n] = t) || Qe;
}, Zs = function() {
  return 0;
}, eA = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, aa = {
  suppressEvents: !0,
  kill: !1
}, nA = {
  suppressEvents: !0
}, ou = {}, ti = [], oc = {}, ry, qe = {}, mh = {}, tf = 30, la = [], au = "", lu = function(n) {
  var t = n[0], e, i;
  if (Tn(t) || Lt(t) || (n = [n]), !(e = (t._gsap || {}).harness)) {
    for (i = la.length; i-- && !la[i].targetTest(t); )
      ;
    e = la[i];
  }
  for (i = n.length; i--; )
    n[i] && (n[i]._gsap || (n[i]._gsap = new Py(n[i], e))) || n.splice(i, 1);
  return n;
}, Li = function(n) {
  return n._gsap || lu(sn(n))[0]._gsap;
}, sy = function(n, t, e) {
  return (e = n[t]) && Lt(e) ? n[t]() : nu(e) && n.getAttribute && n.getAttribute(t) || e;
}, De = function(n, t) {
  return (n = n.split(",")).forEach(t) || n;
}, Ut = function(n) {
  return Math.round(n * 1e5) / 1e5 || 0;
}, se = function(n) {
  return Math.round(n * 1e7) / 1e7 || 0;
}, wr = function(n, t) {
  var e = t.charAt(0), i = parseFloat(t.substr(2));
  return n = parseFloat(n), e === "+" ? n + i : e === "-" ? n - i : e === "*" ? n * i : n / i;
}, iA = function(n, t) {
  for (var e = t.length, i = 0; n.indexOf(t[i]) < 0 && ++i < e; )
    ;
  return i < e;
}, Aa = function() {
  var n = ti.length, t = ti.slice(0), e, i;
  for (oc = {}, ti.length = 0, e = 0; e < n; e++)
    i = t[e], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, oy = function(n, t, e, i) {
  ti.length && !be && Aa(), n.render(t, e, be && t < 0 && (n._initted || n._startAt)), ti.length && !be && Aa();
}, ay = function(n) {
  var t = parseFloat(n);
  return (t || t === 0) && (n + "").match(ty).length < 2 ? t : oe(n) ? n.trim() : n;
}, ly = function(n) {
  return n;
}, on = function(n, t) {
  for (var e in t)
    e in n || (n[e] = t[e]);
  return n;
}, rA = function(n) {
  return function(t, e) {
    for (var i in e)
      i in t || i === "duration" && n || i === "ease" || (t[i] = e[i]);
  };
}, qi = function(n, t) {
  for (var e in t)
    n[e] = t[e];
  return n;
}, ef = function n(t, e) {
  for (var i in e)
    i !== "__proto__" && i !== "constructor" && i !== "prototype" && (t[i] = Tn(e[i]) ? n(t[i] || (t[i] = {}), e[i]) : e[i]);
  return t;
}, Ta = function(n, t) {
  var e = {}, i;
  for (i in n)
    i in t || (e[i] = n[i]);
  return e;
}, Os = function(n) {
  var t = n.parent || kt, e = n.keyframes ? rA(we(n.keyframes)) : on;
  if (Ve(n.inherit))
    for (; t; )
      e(n, t.vars.defaults), t = t.parent || t._dp;
  return n;
}, sA = function(n, t) {
  for (var e = n.length, i = e === t.length; i && e-- && n[e] === t[e]; )
    ;
  return e < 0;
}, hy = function(n, t, e, i, r) {
  var s = n[i], o;
  if (r)
    for (o = t[r]; s && s[r] > o; )
      s = s._prev;
  return s ? (t._next = s._next, s._next = t) : (t._next = n[e], n[e] = t), t._next ? t._next._prev = t : n[i] = t, t._prev = s, t.parent = t._dp = n, t;
}, nl = function(n, t, e, i) {
  e === void 0 && (e = "_first"), i === void 0 && (i = "_last");
  var r = t._prev, s = t._next;
  r ? r._next = s : n[e] === t && (n[e] = s), s ? s._prev = r : n[i] === t && (n[i] = r), t._next = t._prev = t.parent = null;
}, ai = function(n, t) {
  n.parent && (!t || n.parent.autoRemoveChildren) && n.parent.remove && n.parent.remove(n), n._act = 0;
}, Ni = function(n, t) {
  if (n && (!t || t._end > n._dur || t._start < 0))
    for (var e = n; e; )
      e._dirty = 1, e = e.parent;
  return n;
}, oA = function(n) {
  for (var t = n.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return n;
}, ac = function(n, t, e, i) {
  return n._startAt && (be ? n._startAt.revert(aa) : n.vars.immediateRender && !n.vars.autoRevert || n._startAt.render(t, !0, i));
}, aA = function n(t) {
  return !t || t._ts && n(t.parent);
}, nf = function(n) {
  return n._repeat ? Mr(n._tTime, n = n.duration() + n._rDelay) * n : 0;
}, Mr = function(n, t) {
  var e = Math.floor(n /= t);
  return n && e === n ? e - 1 : e;
}, Sa = function(n, t) {
  return (n - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, il = function(n) {
  return n._end = se(n._start + (n._tDur / Math.abs(n._ts || n._rts || wt) || 0));
}, rl = function(n, t) {
  var e = n._dp;
  return e && e.smoothChildTiming && n._ts && (n._start = se(e._time - (n._ts > 0 ? t / n._ts : ((n._dirty ? n.totalDuration() : n._tDur) - t) / -n._ts)), il(n), e._dirty || Ni(e, n)), n;
}, cy = function(n, t) {
  var e;
  if ((t._time || !t._dur && t._initted || t._start < n._time && (t._dur || !t.add)) && (e = Sa(n.rawTime(), t), (!t._dur || _o(0, t.totalDuration(), e) - t._tTime > wt) && t.render(e, !0)), Ni(n, t)._dp && n._initted && n._time >= n._dur && n._ts) {
    if (n._dur < n.duration())
      for (e = n; e._dp; )
        e.rawTime() >= 0 && e.totalTime(e._tTime), e = e._dp;
    n._zTime = -wt;
  }
}, _n = function(n, t, e, i) {
  return t.parent && ai(t), t._start = se((Nn(e) ? e : e || n !== kt ? $e(n, e, t) : n._time) + t._delay), t._end = se(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), hy(n, t, "_first", "_last", n._sort ? "_start" : 0), lc(t) || (n._recent = t), i || cy(n, t), n._ts < 0 && rl(n, n._tTime), n;
}, uy = function(n, t) {
  return (Qe.ScrollTrigger || su("scrollTrigger", t)) && Qe.ScrollTrigger.create(t, n);
}, dy = function(n, t, e, i, r) {
  if (cu(n, t, r), !n._initted)
    return 1;
  if (!e && n._pt && !be && (n._dur && n.vars.lazy !== !1 || !n._dur && n.vars.lazy) && ry !== We.frame)
    return ti.push(n), n._lazy = [r, i], 1;
}, lA = function n(t) {
  var e = t.parent;
  return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || n(e));
}, lc = function(n) {
  var t = n.data;
  return t === "isFromStart" || t === "isStart";
}, hA = function(n, t, e, i) {
  var r = n.ratio, s = t < 0 || !t && (!n._start && lA(n) && !(!n._initted && lc(n)) || (n._ts < 0 || n._dp._ts < 0) && !lc(n)) ? 0 : 1, o = n._rDelay, a = 0, l, h, c;
  if (o && n._repeat && (a = _o(0, n._tDur, t), h = Mr(a, o), n._yoyo && h & 1 && (s = 1 - s), h !== Mr(n._tTime, o) && (r = 1 - s, n.vars.repeatRefresh && n._initted && n.invalidate())), s !== r || be || i || n._zTime === wt || !t && n._zTime) {
    if (!n._initted && dy(n, t, i, e, a))
      return;
    for (c = n._zTime, n._zTime = t || (e ? wt : 0), e || (e = t && !c), n.ratio = s, n._from && (s = 1 - s), n._time = 0, n._tTime = a, l = n._pt; l; )
      l.r(s, l.d), l = l._next;
    t < 0 && ac(n, t, e, !0), n._onUpdate && !e && Ye(n, "onUpdate"), a && n._repeat && !e && n.parent && Ye(n, "onRepeat"), (t >= n._tDur || t < 0) && n.ratio === s && (s && ai(n, 1), !e && !be && (Ye(n, s ? "onComplete" : "onReverseComplete", !0), n._prom && n._prom()));
  } else n._zTime || (n._zTime = t);
}, cA = function(n, t, e) {
  var i;
  if (e > t)
    for (i = n._first; i && i._start <= e; ) {
      if (i.data === "isPause" && i._start > t)
        return i;
      i = i._next;
    }
  else
    for (i = n._last; i && i._start >= e; ) {
      if (i.data === "isPause" && i._start < t)
        return i;
      i = i._prev;
    }
}, Vr = function(n, t, e, i) {
  var r = n._repeat, s = se(t) || 0, o = n._tTime / n._tDur;
  return o && !i && (n._time *= s / n._dur), n._dur = s, n._tDur = r ? r < 0 ? 1e10 : se(s * (r + 1) + n._rDelay * r) : s, o > 0 && !i && rl(n, n._tTime = n._tDur * o), n.parent && il(n), e || Ni(n.parent, n), n;
}, rf = function(n) {
  return n instanceof Ce ? Ni(n) : Vr(n, n._dur);
}, uA = {
  _start: 0,
  endTime: Zs,
  totalDuration: Zs
}, $e = function n(t, e, i) {
  var r = t.labels, s = t._recent || uA, o = t.duration() >= rn ? s.endTime(!1) : t._dur, a, l, h;
  return oe(e) && (isNaN(e) || e in r) ? (l = e.charAt(0), h = e.substr(-1) === "%", a = e.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (e = e.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(e.substr(1)) || 0) * (h ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (e in r || (r[e] = o), r[e]) : (l = parseFloat(e.charAt(a - 1) + e.substr(a + 1)), h && i && (l = l / 100 * (we(i) ? i[0] : i).totalDuration()), a > 1 ? n(t, e.substr(0, a - 1), i) + l : o + l)) : e == null ? o : +e;
}, Fs = function(n, t, e) {
  var i = Nn(t[1]), r = (i ? 2 : 1) + (n < 2 ? 0 : 1), s = t[r], o, a;
  if (i && (s.duration = t[1]), s.parent = e, n) {
    for (o = s, a = e; a && !("immediateRender" in o); )
      o = a.vars.defaults || {}, a = Ve(a.vars.inherit) && a.parent;
    s.immediateRender = Ve(o.immediateRender), n < 2 ? s.runBackwards = 1 : s.startAt = t[r - 1];
  }
  return new Ht(t[0], s, t[r + 1]);
}, fi = function(n, t) {
  return n || n === 0 ? t(n) : t;
}, _o = function(n, t, e) {
  return e < n ? n : e > t ? t : e;
}, _e = function(n, t) {
  return !oe(n) || !(t = tA.exec(n)) ? "" : t[1];
}, dA = function(n, t, e) {
  return fi(e, function(i) {
    return _o(n, t, i);
  });
}, hc = [].slice, py = function(n, t) {
  return n && Tn(n) && "length" in n && (!t && !n.length || n.length - 1 in n && Tn(n[0])) && !n.nodeType && n !== yn;
}, pA = function(n, t, e) {
  return e === void 0 && (e = []), n.forEach(function(i) {
    var r;
    return oe(i) && !t || py(i, 1) ? (r = e).push.apply(r, sn(i)) : e.push(i);
  }) || e;
}, sn = function(n, t, e) {
  return Et && !t && Et.selector ? Et.selector(n) : oe(n) && !e && (sc || !Dr()) ? hc.call((t || ru).querySelectorAll(n), 0) : we(n) ? pA(n, e) : py(n) ? hc.call(n, 0) : n ? [n] : [];
}, cc = function(n) {
  return n = sn(n)[0] || Js("Invalid scope") || {}, function(t) {
    var e = n.current || n.nativeElement || n;
    return sn(t, e.querySelectorAll ? e : e === n ? Js("Invalid scope") || ru.createElement("div") : n);
  };
}, fy = function(n) {
  return n.sort(function() {
    return 0.5 - Math.random();
  });
}, my = function(n) {
  if (Lt(n))
    return n;
  var t = Tn(n) ? n : {
    each: n
  }, e = Ui(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, s = {}, o = i > 0 && i < 1, a = isNaN(i) || o, l = t.axis, h = i, c = i;
  return oe(i) ? h = c = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !o && a && (h = i[0], c = i[1]), function(p, f, u) {
    var m = (u || t).length, g = s[m], y, b, T, C, P, S, I, w, _;
    if (!g) {
      if (_ = t.grid === "auto" ? 0 : (t.grid || [1, rn])[1], !_) {
        for (I = -rn; I < (I = u[_++].getBoundingClientRect().left) && _ < m; )
          ;
        _ < m && _--;
      }
      for (g = s[m] = [], y = a ? Math.min(_, m) * h - 0.5 : i % _, b = _ === rn ? 0 : a ? m * c / _ - 0.5 : i / _ | 0, I = 0, w = rn, S = 0; S < m; S++)
        T = S % _ - y, C = b - (S / _ | 0), g[S] = P = l ? Math.abs(l === "y" ? C : T) : Qg(T * T + C * C), P > I && (I = P), P < w && (w = P);
      i === "random" && fy(g), g.max = I - w, g.min = w, g.v = m = (parseFloat(t.amount) || parseFloat(t.each) * (_ > m ? m - 1 : l ? l === "y" ? m / _ : _ : Math.max(_, m / _)) || 0) * (i === "edges" ? -1 : 1), g.b = m < 0 ? r - m : r, g.u = _e(t.amount || t.each) || 0, e = e && m < 0 ? Sy(e) : e;
    }
    return m = (g[p] - g.min) / g.max || 0, se(g.b + (e ? e(m) : m) * g.v) + g.u;
  };
}, uc = function(n) {
  var t = Math.pow(10, ((n + "").split(".")[1] || "").length);
  return function(e) {
    var i = se(Math.round(parseFloat(e) / n) * n * t);
    return (i - i % 1) / t + (Nn(e) ? 0 : _e(e));
  };
}, gy = function(n, t) {
  var e = we(n), i, r;
  return !e && Tn(n) && (i = e = n.radius || rn, n.values ? (n = sn(n.values), (r = !Nn(n[0])) && (i *= i)) : n = uc(n.increment)), fi(t, e ? Lt(n) ? function(s) {
    return r = n(s), Math.abs(r - s) <= i ? r : s;
  } : function(s) {
    for (var o = parseFloat(r ? s.x : s), a = parseFloat(r ? s.y : 0), l = rn, h = 0, c = n.length, p, f; c--; )
      r ? (p = n[c].x - o, f = n[c].y - a, p = p * p + f * f) : p = Math.abs(n[c] - o), p < l && (l = p, h = c);
    return h = !i || l <= i ? n[h] : s, r || h === s || Nn(s) ? h : h + _e(s);
  } : uc(n));
}, yy = function(n, t, e, i) {
  return fi(we(n) ? !t : e === !0 ? !!(e = 0) : !i, function() {
    return we(n) ? n[~~(Math.random() * n.length)] : (e = e || 1e-5) && (i = e < 1 ? Math.pow(10, (e + "").length - 2) : 1) && Math.floor(Math.round((n - e / 2 + Math.random() * (t - n + e * 0.99)) / e) * e * i) / i;
  });
}, fA = function() {
  for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)
    t[e] = arguments[e];
  return function(i) {
    return t.reduce(function(r, s) {
      return s(r);
    }, i);
  };
}, mA = function(n, t) {
  return function(e) {
    return n(parseFloat(e)) + (t || _e(e));
  };
}, gA = function(n, t, e) {
  return vy(n, t, 0, 1, e);
}, _y = function(n, t, e) {
  return fi(e, function(i) {
    return n[~~t(i)];
  });
}, yA = function n(t, e, i) {
  var r = e - t;
  return we(t) ? _y(t, n(0, t.length), e) : fi(i, function(s) {
    return (r + (s - t) % r) % r + t;
  });
}, _A = function n(t, e, i) {
  var r = e - t, s = r * 2;
  return we(t) ? _y(t, n(0, t.length - 1), e) : fi(i, function(o) {
    return o = (s + (o - t) % s) % s || 0, t + (o > r ? s - o : o);
  });
}, $s = function(n) {
  for (var t = 0, e = "", i, r, s, o; ~(i = n.indexOf("random(", t)); )
    s = n.indexOf(")", i), o = n.charAt(i + 7) === "[", r = n.substr(i + 7, s - i - 7).match(o ? ty : rc), e += n.substr(t, i - t) + yy(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5), t = s + 1;
  return e + n.substr(t, n.length - t);
}, vy = function(n, t, e, i, r) {
  var s = t - n, o = i - e;
  return fi(r, function(a) {
    return e + ((a - n) / s * o || 0);
  });
}, vA = function n(t, e, i, r) {
  var s = isNaN(t + e) ? 0 : function(u) {
    return (1 - u) * t + u * e;
  };
  if (!s) {
    var o = oe(t), a = {}, l, h, c, p, f;
    if (i === !0 && (r = 1) && (i = null), o)
      t = {
        p: t
      }, e = {
        p: e
      };
    else if (we(t) && !we(e)) {
      for (c = [], p = t.length, f = p - 2, h = 1; h < p; h++)
        c.push(n(t[h - 1], t[h]));
      p--, s = function(u) {
        u *= p;
        var m = Math.min(f, ~~u);
        return c[m](u - m);
      }, i = e;
    } else r || (t = qi(we(t) ? [] : {}, t));
    if (!c) {
      for (l in e)
        hu.call(a, t, l, "get", e[l]);
      s = function(u) {
        return pu(u, a) || (o ? t.p : t);
      };
    }
  }
  return fi(i, s);
}, sf = function(n, t, e) {
  var i = n.labels, r = rn, s, o, a;
  for (s in i)
    o = i[s] - t, o < 0 == !!e && o && r > (o = Math.abs(o)) && (a = s, r = o);
  return a;
}, Ye = function(n, t, e) {
  var i = n.vars, r = i[t], s = Et, o = n._ctx, a, l, h;
  if (r)
    return a = i[t + "Params"], l = i.callbackScope || n, e && ti.length && Aa(), o && (Et = o), h = a ? r.apply(l, a) : r.call(l), Et = s, h;
}, Es = function(n) {
  return ai(n), n.scrollTrigger && n.scrollTrigger.kill(!!be), n.progress() < 1 && Ye(n, "onInterrupt"), n;
}, yr, xy = [], by = function(n) {
  if (n)
    if (n = !n.name && n.default || n, iu() || n.headless) {
      var t = n.name, e = Lt(n), i = t && !e && n.init ? function() {
        this._props = [];
      } : n, r = {
        init: Zs,
        render: pu,
        add: hu,
        kill: BA,
        modifier: DA,
        rawVars: 0
      }, s = {
        targetTest: 0,
        get: 0,
        getSetter: du,
        aliases: {},
        register: 0
      };
      if (Dr(), n !== i) {
        if (qe[t])
          return;
        on(i, on(Ta(n, r), s)), qi(i.prototype, qi(r, Ta(n, s))), qe[i.prop = t] = i, n.targetTest && (la.push(i), ou[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      iy(t, i), n.register && n.register(Fe, i, Be);
    } else
      xy.push(n);
}, bt = 255, Cs = {
  aqua: [0, bt, bt],
  lime: [0, bt, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, bt],
  navy: [0, 0, 128],
  white: [bt, bt, bt],
  olive: [128, 128, 0],
  yellow: [bt, bt, 0],
  orange: [bt, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [bt, 0, 0],
  pink: [bt, 192, 203],
  cyan: [0, bt, bt],
  transparent: [bt, bt, bt, 0]
}, gh = function(n, t, e) {
  return n += n < 0 ? 1 : n > 1 ? -1 : 0, (n * 6 < 1 ? t + (e - t) * n * 6 : n < 0.5 ? e : n * 3 < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t) * bt + 0.5 | 0;
}, wy = function(n, t, e) {
  var i = n ? Nn(n) ? [n >> 16, n >> 8 & bt, n & bt] : 0 : Cs.black, r, s, o, a, l, h, c, p, f, u;
  if (!i) {
    if (n.substr(-1) === "," && (n = n.substr(0, n.length - 1)), Cs[n])
      i = Cs[n];
    else if (n.charAt(0) === "#") {
      if (n.length < 6 && (r = n.charAt(1), s = n.charAt(2), o = n.charAt(3), n = "#" + r + r + s + s + o + o + (n.length === 5 ? n.charAt(4) + n.charAt(4) : "")), n.length === 9)
        return i = parseInt(n.substr(1, 6), 16), [i >> 16, i >> 8 & bt, i & bt, parseInt(n.substr(7), 16) / 255];
      n = parseInt(n.substr(1), 16), i = [n >> 16, n >> 8 & bt, n & bt];
    } else if (n.substr(0, 3) === "hsl") {
      if (i = u = n.match(rc), !t)
        a = +i[0] % 360 / 360, l = +i[1] / 100, h = +i[2] / 100, s = h <= 0.5 ? h * (l + 1) : h + l - h * l, r = h * 2 - s, i.length > 3 && (i[3] *= 1), i[0] = gh(a + 1 / 3, r, s), i[1] = gh(a, r, s), i[2] = gh(a - 1 / 3, r, s);
      else if (~n.indexOf("="))
        return i = n.match(Zg), e && i.length < 4 && (i[3] = 1), i;
    } else
      i = n.match(rc) || Cs.transparent;
    i = i.map(Number);
  }
  return t && !u && (r = i[0] / bt, s = i[1] / bt, o = i[2] / bt, c = Math.max(r, s, o), p = Math.min(r, s, o), h = (c + p) / 2, c === p ? a = l = 0 : (f = c - p, l = h > 0.5 ? f / (2 - c - p) : f / (c + p), a = c === r ? (s - o) / f + (s < o ? 6 : 0) : c === s ? (o - r) / f + 2 : (r - s) / f + 4, a *= 60), i[0] = ~~(a + 0.5), i[1] = ~~(l * 100 + 0.5), i[2] = ~~(h * 100 + 0.5)), e && i.length < 4 && (i[3] = 1), i;
}, Ay = function(n) {
  var t = [], e = [], i = -1;
  return n.split(ei).forEach(function(r) {
    var s = r.match(gr) || [];
    t.push.apply(t, s), e.push(i += s.length + 1);
  }), t.c = e, t;
}, of = function(n, t, e) {
  var i = "", r = (n + i).match(ei), s = t ? "hsla(" : "rgba(", o = 0, a, l, h, c;
  if (!r)
    return n;
  if (r = r.map(function(p) {
    return (p = wy(p, t, 1)) && s + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")";
  }), e && (h = Ay(n), a = e.c, a.join(i) !== h.c.join(i)))
    for (l = n.replace(ei, "1").split(gr), c = l.length - 1; o < c; o++)
      i += l[o] + (~a.indexOf(o) ? r.shift() || s + "0,0,0,0)" : (h.length ? h : r.length ? r : e).shift());
  if (!l)
    for (l = n.split(ei), c = l.length - 1; o < c; o++)
      i += l[o] + r[o];
  return i + l[c];
}, ei = function() {
  var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
  for (t in Cs)
    n += "|" + t + "\\b";
  return new RegExp(n + ")", "gi");
}(), xA = /hsl[a]?\(/, Ty = function(n) {
  var t = n.join(" "), e;
  if (ei.lastIndex = 0, ei.test(t))
    return e = xA.test(t), n[1] = of(n[1], e), n[0] = of(n[0], e, Ay(n[1])), !0;
}, to, We = function() {
  var n = Date.now, t = 500, e = 33, i = n(), r = i, s = 1e3 / 240, o = s, a = [], l, h, c, p, f, u, m = function g(y) {
    var b = n() - r, T = y === !0, C, P, S, I;
    if ((b > t || b < 0) && (i += b - e), r += b, S = r - i, C = S - o, (C > 0 || T) && (I = ++p.frame, f = S - p.time * 1e3, p.time = S = S / 1e3, o += C + (C >= s ? 4 : s - C), P = 1), T || (l = h(g)), P)
      for (u = 0; u < a.length; u++)
        a[u](S, f, I, y);
  };
  return p = {
    time: 0,
    frame: 0,
    tick: function() {
      m(!0);
    },
    deltaRatio: function(g) {
      return f / (1e3 / (g || 60));
    },
    wake: function() {
      ey && (!sc && iu() && (yn = sc = window, ru = yn.document || {}, Qe.gsap = Fe, (yn.gsapVersions || (yn.gsapVersions = [])).push(Fe.version), ny(wa || yn.GreenSockGlobals || !yn.gsap && yn || {}), xy.forEach(by)), c = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && p.sleep(), h = c || function(g) {
        return setTimeout(g, o - p.time * 1e3 + 1 | 0);
      }, to = 1, m(2));
    },
    sleep: function() {
      (c ? cancelAnimationFrame : clearTimeout)(l), to = 0, h = Zs;
    },
    lagSmoothing: function(g, y) {
      t = g || 1 / 0, e = Math.min(y || 33, t);
    },
    fps: function(g) {
      s = 1e3 / (g || 240), o = p.time * 1e3 + s;
    },
    add: function(g, y, b) {
      var T = y ? function(C, P, S, I) {
        g(C, P, S, I), p.remove(T);
      } : g;
      return p.remove(g), a[b ? "unshift" : "push"](T), Dr(), T;
    },
    remove: function(g, y) {
      ~(y = a.indexOf(g)) && a.splice(y, 1) && u >= y && u--;
    },
    _listeners: a
  }, p;
}(), Dr = function() {
  return !to && We.wake();
}, ht = {}, bA = /^[\d.\-M][\d.\-,\s]/, wA = /["']/g, AA = function(n) {
  for (var t = {}, e = n.substr(1, n.length - 3).split(":"), i = e[0], r = 1, s = e.length, o, a, l; r < s; r++)
    a = e[r], o = r !== s - 1 ? a.lastIndexOf(",") : a.length, l = a.substr(0, o), t[i] = isNaN(l) ? l.replace(wA, "").trim() : +l, i = a.substr(o + 1).trim();
  return t;
}, TA = function(n) {
  var t = n.indexOf("(") + 1, e = n.indexOf(")"), i = n.indexOf("(", t);
  return n.substring(t, ~i && i < e ? n.indexOf(")", e + 1) : e);
}, SA = function(n) {
  var t = (n + "").split("("), e = ht[t[0]];
  return e && t.length > 1 && e.config ? e.config.apply(null, ~n.indexOf("{") ? [AA(t[1])] : TA(n).split(",").map(ay)) : ht._CE && bA.test(n) ? ht._CE("", n) : e;
}, Sy = function(n) {
  return function(t) {
    return 1 - n(1 - t);
  };
}, Ey = function n(t, e) {
  for (var i = t._first, r; i; )
    i instanceof Ce ? n(i, e) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== e && (i.timeline ? n(i.timeline, e) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = e)), i = i._next;
}, Ui = function(n, t) {
  return n && (Lt(n) ? n : ht[n] || SA(n)) || t;
}, Xi = function(n, t, e, i) {
  e === void 0 && (e = function(o) {
    return 1 - t(1 - o);
  }), i === void 0 && (i = function(o) {
    return o < 0.5 ? t(o * 2) / 2 : 1 - t((1 - o) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: e,
    easeInOut: i
  }, s;
  return De(n, function(o) {
    ht[o] = Qe[o] = r, ht[s = o.toLowerCase()] = e;
    for (var a in r)
      ht[s + (a === "easeIn" ? ".in" : a === "easeOut" ? ".out" : ".inOut")] = ht[o + "." + a] = r[a];
  }), r;
}, Cy = function(n) {
  return function(t) {
    return t < 0.5 ? (1 - n(1 - t * 2)) / 2 : 0.5 + n((t - 0.5) * 2) / 2;
  };
}, yh = function n(t, e, i) {
  var r = e >= 1 ? e : 1, s = (i || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1), o = s / ic * (Math.asin(1 / r) || 0), a = function(h) {
    return h === 1 ? 1 : r * Math.pow(2, -10 * h) * $w((h - o) * s) + 1;
  }, l = t === "out" ? a : t === "in" ? function(h) {
    return 1 - a(1 - h);
  } : Cy(a);
  return s = ic / s, l.config = function(h, c) {
    return n(t, h, c);
  }, l;
}, _h = function n(t, e) {
  e === void 0 && (e = 1.70158);
  var i = function(s) {
    return s ? --s * s * ((e + 1) * s + e) + 1 : 0;
  }, r = t === "out" ? i : t === "in" ? function(s) {
    return 1 - i(1 - s);
  } : Cy(i);
  return r.config = function(s) {
    return n(t, s);
  }, r;
};
De("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, t) {
  var e = t < 5 ? t + 1 : t;
  Xi(n + ",Power" + (e - 1), t ? function(i) {
    return Math.pow(i, e);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, e);
  }, function(i) {
    return i < 0.5 ? Math.pow(i * 2, e) / 2 : 1 - Math.pow((1 - i) * 2, e) / 2;
  });
});
ht.Linear.easeNone = ht.none = ht.Linear.easeIn;
Xi("Elastic", yh("in"), yh("out"), yh());
(function(n, t) {
  var e = 1 / t, i = 2 * e, r = 2.5 * e, s = function(o) {
    return o < e ? n * o * o : o < i ? n * Math.pow(o - 1.5 / t, 2) + 0.75 : o < r ? n * (o -= 2.25 / t) * o + 0.9375 : n * Math.pow(o - 2.625 / t, 2) + 0.984375;
  };
  Xi("Bounce", function(o) {
    return 1 - s(1 - o);
  }, s);
})(7.5625, 2.75);
Xi("Expo", function(n) {
  return n ? Math.pow(2, 10 * (n - 1)) : 0;
});
Xi("Circ", function(n) {
  return -(Qg(1 - n * n) - 1);
});
Xi("Sine", function(n) {
  return n === 1 ? 1 : -Zw(n * Qw) + 1;
});
Xi("Back", _h("in"), _h("out"), _h());
ht.SteppedEase = ht.steps = Qe.SteppedEase = {
  config: function(n, t) {
    n === void 0 && (n = 1);
    var e = 1 / n, i = n + (t ? 0 : 1), r = t ? 1 : 0, s = 1 - wt;
    return function(o) {
      return ((i * _o(0, s, o) | 0) + r) * e;
    };
  }
};
kr.ease = ht["quad.out"];
De("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
  return au += n + "," + n + "Params,";
});
var Py = function(n, t) {
  this.id = Jw++, n._gsap = this, this.target = n, this.harness = t, this.get = t ? t.get : sy, this.set = t ? t.getSetter : du;
}, eo = /* @__PURE__ */ function() {
  function n(e) {
    this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, Vr(this, +e.duration, 1, 1), this.data = e.data, Et && (this._ctx = Et, Et.data.push(this)), to || We.wake();
  }
  var t = n.prototype;
  return t.delay = function(e) {
    return e || e === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay;
  }, t.duration = function(e) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur;
  }, t.totalDuration = function(e) {
    return arguments.length ? (this._dirty = 0, Vr(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, t.totalTime = function(e, i) {
    if (Dr(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (rl(this, e), !r._dp || r.parent || cy(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && _n(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== e || !this._dur && !i || this._initted && Math.abs(this._zTime) === wt || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), oy(this, e, i)), this;
  }, t.time = function(e, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + nf(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), i) : this._time;
  }, t.totalProgress = function(e, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * e, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, t.progress = function(e, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - e : e) + nf(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, t.iteration = function(e, i) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (e - 1) * r, i) : this._repeat ? Mr(this._tTime, r) + 1 : 1;
  }, t.timeScale = function(e, i) {
    if (!arguments.length)
      return this._rts === -wt ? 0 : this._rts;
    if (this._rts === e)
      return this;
    var r = this.parent && this._ts ? Sa(this.parent._time, this) : this._tTime;
    return this._rts = +e || 0, this._ts = this._ps || e === -wt ? 0 : this._rts, this.totalTime(_o(-Math.abs(this._delay), this._tDur, r), i !== !1), il(this), oA(this);
  }, t.paused = function(e) {
    return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Dr(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== wt && (this._tTime -= wt)))), this) : this._ps;
  }, t.startTime = function(e) {
    if (arguments.length) {
      this._start = e;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && _n(i, this, e - this._delay), this;
    }
    return this._start;
  }, t.endTime = function(e) {
    return this._start + (Ve(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, t.rawTime = function(e) {
    var i = this.parent || this._dp;
    return i ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Sa(i.rawTime(e), this) : this._tTime : this._tTime;
  }, t.revert = function(e) {
    e === void 0 && (e = nA);
    var i = be;
    return be = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-0.01, e.suppressEvents)), this.data !== "nested" && e.kill !== !1 && this.kill(), be = i, this;
  }, t.globalTime = function(e) {
    for (var i = this, r = arguments.length ? e : i.rawTime(); i; )
      r = i._start + r / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(e) : r;
  }, t.repeat = function(e) {
    return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, rf(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, t.repeatDelay = function(e) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = e, rf(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, t.yoyo = function(e) {
    return arguments.length ? (this._yoyo = e, this) : this._yoyo;
  }, t.seek = function(e, i) {
    return this.totalTime($e(this, e), Ve(i));
  }, t.restart = function(e, i) {
    return this.play().totalTime(e ? -this._delay : 0, Ve(i));
  }, t.play = function(e, i) {
    return e != null && this.seek(e, i), this.reversed(!1).paused(!1);
  }, t.reverse = function(e, i) {
    return e != null && this.seek(e || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, t.pause = function(e, i) {
    return e != null && this.seek(e, i), this.paused(!0);
  }, t.resume = function() {
    return this.paused(!1);
  }, t.reversed = function(e) {
    return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -wt : 0)), this) : this._rts < 0;
  }, t.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -wt, this;
  }, t.isActive = function() {
    var e = this.parent || this._dp, i = this._start, r;
    return !!(!e || this._ts && this._initted && e.isActive() && (r = e.rawTime(!0)) >= i && r < this.endTime(!0) - wt);
  }, t.eventCallback = function(e, i, r) {
    var s = this.vars;
    return arguments.length > 1 ? (i ? (s[e] = i, r && (s[e + "Params"] = r), e === "onUpdate" && (this._onUpdate = i)) : delete s[e], this) : s[e];
  }, t.then = function(e) {
    var i = this;
    return new Promise(function(r) {
      var s = Lt(e) ? e : ly, o = function() {
        var a = i.then;
        i.then = null, Lt(s) && (s = s(i)) && (s.then || s === i) && (i.then = a), r(s), i.then = a;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o;
    });
  }, t.kill = function() {
    Es(this);
  }, n;
}();
on(eo.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -wt,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Ce = /* @__PURE__ */ function(n) {
  Kg(t, n);
  function t(i, r) {
    var s;
    return i === void 0 && (i = {}), s = n.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = Ve(i.sortChildren), kt && _n(i.parent || kt, Mn(s), r), i.reversed && s.reverse(), i.paused && s.paused(!0), i.scrollTrigger && uy(Mn(s), i.scrollTrigger), s;
  }
  var e = t.prototype;
  return e.to = function(i, r, s) {
    return Fs(0, arguments, this), this;
  }, e.from = function(i, r, s) {
    return Fs(1, arguments, this), this;
  }, e.fromTo = function(i, r, s, o) {
    return Fs(2, arguments, this), this;
  }, e.set = function(i, r, s) {
    return r.duration = 0, r.parent = this, Os(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Ht(i, r, $e(this, s), 1), this;
  }, e.call = function(i, r, s) {
    return _n(this, Ht.delayedCall(0, i, r), s);
  }, e.staggerTo = function(i, r, s, o, a, l, h) {
    return s.duration = r, s.stagger = s.stagger || o, s.onComplete = l, s.onCompleteParams = h, s.parent = this, new Ht(i, s, $e(this, a)), this;
  }, e.staggerFrom = function(i, r, s, o, a, l, h) {
    return s.runBackwards = 1, Os(s).immediateRender = Ve(s.immediateRender), this.staggerTo(i, r, s, o, a, l, h);
  }, e.staggerFromTo = function(i, r, s, o, a, l, h, c) {
    return o.startAt = s, Os(o).immediateRender = Ve(o.immediateRender), this.staggerTo(i, r, o, a, l, h, c);
  }, e.render = function(i, r, s) {
    var o = this._time, a = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, h = i <= 0 ? 0 : se(i), c = this._zTime < 0 != i < 0 && (this._initted || !l), p, f, u, m, g, y, b, T, C, P, S, I;
    if (this !== kt && h > a && i >= 0 && (h = a), h !== this._tTime || s || c) {
      if (o !== this._time && l && (h += this._time - o, i += this._time - o), p = h, C = this._start, T = this._ts, y = !T, c && (l || (o = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
        if (S = this._yoyo, g = l + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(g * 100 + i, r, s);
        if (p = se(h % g), h === a ? (m = this._repeat, p = l) : (m = ~~(h / g), m && m === h / g && (p = l, m--), p > l && (p = l)), P = Mr(this._tTime, g), !o && this._tTime && P !== m && this._tTime - P * g - this._dur <= 0 && (P = m), S && m & 1 && (p = l - p, I = 1), m !== P && !this._lock) {
          var w = S && P & 1, _ = w === (S && m & 1);
          if (m < P && (w = !w), o = w ? 0 : h % l ? l : h, this._lock = 1, this.render(o || (I ? 0 : se(m * g)), r, !l)._lock = 0, this._tTime = h, !r && this.parent && Ye(this, "onRepeat"), this.vars.repeatRefresh && !I && (this.invalidate()._lock = 1), o && o !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (l = this._dur, a = this._tDur, _ && (this._lock = 2, o = w ? l : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !I && this.invalidate()), this._lock = 0, !this._ts && !y)
            return this;
          Ey(this, I);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (b = cA(this, se(o), se(p)), b && (h -= p - (p = b._start))), this._tTime = h, this._time = p, this._act = !T, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && p && !r && !m && (Ye(this, "onStart"), this._tTime !== h))
        return this;
      if (p >= o && i >= 0)
        for (f = this._first; f; ) {
          if (u = f._next, (f._act || p >= f._start) && f._ts && b !== f) {
            if (f.parent !== this)
              return this.render(i, r, s);
            if (f.render(f._ts > 0 ? (p - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (p - f._start) * f._ts, r, s), p !== this._time || !this._ts && !y) {
              b = 0, u && (h += this._zTime = -wt);
              break;
            }
          }
          f = u;
        }
      else {
        f = this._last;
        for (var x = i < 0 ? i : p; f; ) {
          if (u = f._prev, (f._act || x <= f._end) && f._ts && b !== f) {
            if (f.parent !== this)
              return this.render(i, r, s);
            if (f.render(f._ts > 0 ? (x - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (x - f._start) * f._ts, r, s || be && (f._initted || f._startAt)), p !== this._time || !this._ts && !y) {
              b = 0, u && (h += this._zTime = x ? -wt : wt);
              break;
            }
          }
          f = u;
        }
      }
      if (b && !r && (this.pause(), b.render(p >= o ? 0 : -wt)._zTime = p >= o ? 1 : -1, this._ts))
        return this._start = C, il(this), this.render(i, r, s);
      this._onUpdate && !r && Ye(this, "onUpdate", !0), (h === a && this._tTime >= this.totalDuration() || !h && o) && (C === this._start || Math.abs(T) !== Math.abs(this._ts)) && (this._lock || ((i || !l) && (h === a && this._ts > 0 || !h && this._ts < 0) && ai(this, 1), !r && !(i < 0 && !o) && (h || o || !a) && (Ye(this, h === a && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < a && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, e.add = function(i, r) {
    var s = this;
    if (Nn(r) || (r = $e(this, r, i)), !(i instanceof eo)) {
      if (we(i))
        return i.forEach(function(o) {
          return s.add(o, r);
        }), this;
      if (oe(i))
        return this.addLabel(i, r);
      if (Lt(i))
        i = Ht.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? _n(this, i, r) : this;
  }, e.getChildren = function(i, r, s, o) {
    i === void 0 && (i = !0), r === void 0 && (r = !0), s === void 0 && (s = !0), o === void 0 && (o = -rn);
    for (var a = [], l = this._first; l; )
      l._start >= o && (l instanceof Ht ? r && a.push(l) : (s && a.push(l), i && a.push.apply(a, l.getChildren(!0, r, s)))), l = l._next;
    return a;
  }, e.getById = function(i) {
    for (var r = this.getChildren(1, 1, 1), s = r.length; s--; )
      if (r[s].vars.id === i)
        return r[s];
  }, e.remove = function(i) {
    return oe(i) ? this.removeLabel(i) : Lt(i) ? this.killTweensOf(i) : (nl(this, i), i === this._recent && (this._recent = this._last), Ni(this));
  }, e.totalTime = function(i, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = se(We.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), n.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime;
  }, e.addLabel = function(i, r) {
    return this.labels[i] = $e(this, r), this;
  }, e.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, e.addPause = function(i, r, s) {
    var o = Ht.delayedCall(0, r || Zs, s);
    return o.data = "isPause", this._hasPause = 1, _n(this, o, $e(this, i));
  }, e.removePause = function(i) {
    var r = this._first;
    for (i = $e(this, i); r; )
      r._start === i && r.data === "isPause" && ai(r), r = r._next;
  }, e.killTweensOf = function(i, r, s) {
    for (var o = this.getTweensOf(i, s), a = o.length; a--; )
      Qn !== o[a] && o[a].kill(i, r);
    return this;
  }, e.getTweensOf = function(i, r) {
    for (var s = [], o = sn(i), a = this._first, l = Nn(r), h; a; )
      a instanceof Ht ? iA(a._targets, o) && (l ? (!Qn || a._initted && a._ts) && a.globalTime(0) <= r && a.globalTime(a.totalDuration()) > r : !r || a.isActive()) && s.push(a) : (h = a.getTweensOf(o, r)).length && s.push.apply(s, h), a = a._next;
    return s;
  }, e.tweenTo = function(i, r) {
    r = r || {};
    var s = this, o = $e(s, i), a = r, l = a.startAt, h = a.onStart, c = a.onStartParams, p = a.immediateRender, f, u = Ht.to(s, on({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: o,
      overwrite: "auto",
      duration: r.duration || Math.abs((o - (l && "time" in l ? l.time : s._time)) / s.timeScale()) || wt,
      onStart: function() {
        if (s.pause(), !f) {
          var m = r.duration || Math.abs((o - (l && "time" in l ? l.time : s._time)) / s.timeScale());
          u._dur !== m && Vr(u, m, 0, 1).render(u._time, !0, !0), f = 1;
        }
        h && h.apply(u, c || []);
      }
    }, r));
    return p ? u.render(0) : u;
  }, e.tweenFromTo = function(i, r, s) {
    return this.tweenTo(r, on({
      startAt: {
        time: $e(this, i)
      }
    }, s));
  }, e.recent = function() {
    return this._recent;
  }, e.nextLabel = function(i) {
    return i === void 0 && (i = this._time), sf(this, $e(this, i));
  }, e.previousLabel = function(i) {
    return i === void 0 && (i = this._time), sf(this, $e(this, i), 1);
  }, e.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + wt);
  }, e.shiftChildren = function(i, r, s) {
    s === void 0 && (s = 0);
    for (var o = this._first, a = this.labels, l; o; )
      o._start >= s && (o._start += i, o._end += i), o = o._next;
    if (r)
      for (l in a)
        a[l] >= s && (a[l] += i);
    return Ni(this);
  }, e.invalidate = function(i) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(i), r = r._next;
    return n.prototype.invalidate.call(this, i);
  }, e.clear = function(i) {
    i === void 0 && (i = !0);
    for (var r = this._first, s; r; )
      s = r._next, this.remove(r), r = s;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Ni(this);
  }, e.totalDuration = function(i) {
    var r = 0, s = this, o = s._last, a = rn, l, h, c;
    if (arguments.length)
      return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
    if (s._dirty) {
      for (c = s.parent; o; )
        l = o._prev, o._dirty && o.totalDuration(), h = o._start, h > a && s._sort && o._ts && !s._lock ? (s._lock = 1, _n(s, o, h - o._delay, 1)._lock = 0) : a = h, h < 0 && o._ts && (r -= h, (!c && !s._dp || c && c.smoothChildTiming) && (s._start += h / s._ts, s._time -= h, s._tTime -= h), s.shiftChildren(-h, !1, -1 / 0), a = 0), o._end > r && o._ts && (r = o._end), o = l;
      Vr(s, s === kt && s._time > r ? s._time : r, 1, 1), s._dirty = 0;
    }
    return s._tDur;
  }, t.updateRoot = function(i) {
    if (kt._ts && (oy(kt, Sa(i, kt)), ry = We.frame), We.frame >= tf) {
      tf += Xe.autoSleep || 120;
      var r = kt._first;
      if ((!r || !r._ts) && Xe.autoSleep && We._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || We.sleep();
      }
    }
  }, t;
}(eo);
on(Ce.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var EA = function(n, t, e, i, r, s, o) {
  var a = new Be(this._pt, n, t, 0, 1, Dy, null, r), l = 0, h = 0, c, p, f, u, m, g, y, b;
  for (a.b = e, a.e = i, e += "", i += "", (y = ~i.indexOf("random(")) && (i = $s(i)), s && (b = [e, i], s(b, n, t), e = b[0], i = b[1]), p = e.match(fh) || []; c = fh.exec(i); )
    u = c[0], m = i.substring(l, c.index), f ? f = (f + 1) % 5 : m.substr(-5) === "rgba(" && (f = 1), u !== p[h++] && (g = parseFloat(p[h - 1]) || 0, a._pt = {
      _next: a._pt,
      p: m || h === 1 ? m : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: g,
      c: u.charAt(1) === "=" ? wr(g, u) - g : parseFloat(u) - g,
      m: f && f < 4 ? Math.round : 0
    }, l = fh.lastIndex);
  return a.c = l < i.length ? i.substring(l, i.length) : "", a.fp = o, ($g.test(i) || y) && (a.e = 0), this._pt = a, a;
}, hu = function(n, t, e, i, r, s, o, a, l, h) {
  Lt(i) && (i = i(r || 0, n, s));
  var c = n[t], p = e !== "get" ? e : Lt(c) ? l ? n[t.indexOf("set") || !Lt(n["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : n[t]() : c, f = Lt(c) ? l ? kA : My : uu, u;
  if (oe(i) && (~i.indexOf("random(") && (i = $s(i)), i.charAt(1) === "=" && (u = wr(p, i) + (_e(p) || 0), (u || u === 0) && (i = u))), !h || p !== i || dc)
    return !isNaN(p * i) && i !== "" ? (u = new Be(this._pt, n, t, +p || 0, i - (p || 0), typeof c == "boolean" ? VA : Vy, 0, f), l && (u.fp = l), o && u.modifier(o, this, n), this._pt = u) : (!c && !(t in n) && su(t, i), EA.call(this, n, t, p, i, f, a || Xe.stringFilter, l));
}, CA = function(n, t, e, i, r) {
  if (Lt(n) && (n = Ls(n, r, t, e, i)), !Tn(n) || n.style && n.nodeType || we(n) || Jg(n))
    return oe(n) ? Ls(n, r, t, e, i) : n;
  var s = {}, o;
  for (o in n)
    s[o] = Ls(n[o], r, t, e, i);
  return s;
}, Iy = function(n, t, e, i, r, s) {
  var o, a, l, h;
  if (qe[n] && (o = new qe[n]()).init(r, o.rawVars ? t[n] : CA(t[n], i, r, s, e), e, i, s) !== !1 && (e._pt = a = new Be(e._pt, r, n, 0, 1, o.render, o, 0, o.priority), e !== yr))
    for (l = e._ptLookup[e._targets.indexOf(r)], h = o._props.length; h--; )
      l[o._props[h]] = a;
  return o;
}, Qn, dc, cu = function n(t, e, i) {
  var r = t.vars, s = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, h = r.onUpdate, c = r.runBackwards, p = r.yoyoEase, f = r.keyframes, u = r.autoRevert, m = t._dur, g = t._startAt, y = t._targets, b = t.parent, T = b && b.data === "nested" ? b.vars.targets : y, C = t._overwrite === "auto" && !eu, P = t.timeline, S, I, w, _, x, A, R, M, k, B, O, U, z;
  if (P && (!f || !s) && (s = "none"), t._ease = Ui(s, kr.ease), t._yEase = p ? Sy(Ui(p === !0 ? s : p, kr.ease)) : 0, p && t._yoyo && !t._repeat && (p = t._yEase, t._yEase = t._ease, t._ease = p), t._from = !P && !!r.runBackwards, !P || f && !r.stagger) {
    if (M = y[0] ? Li(y[0]).harness : 0, U = M && r[M.prop], S = Ta(r, ou), g && (g._zTime < 0 && g.progress(1), e < 0 && c && a && !u ? g.render(-1, !0) : g.revert(c && m ? aa : eA), g._lazy = 0), o) {
      if (ai(t._startAt = Ht.set(y, on({
        data: "isStart",
        overwrite: !1,
        parent: b,
        immediateRender: !0,
        lazy: !g && Ve(l),
        startAt: null,
        delay: 0,
        onUpdate: h && function() {
          return Ye(t, "onUpdate");
        },
        stagger: 0
      }, o))), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (be || !a && !u) && t._startAt.revert(aa), a && m && e <= 0 && i <= 0) {
        e && (t._zTime = e);
        return;
      }
    } else if (c && m && !g) {
      if (e && (a = !1), w = on({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: a && !g && Ve(l),
        immediateRender: a,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: b
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, S), U && (w[M.prop] = U), ai(t._startAt = Ht.set(y, w)), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (be ? t._startAt.revert(aa) : t._startAt.render(-1, !0)), t._zTime = e, !a)
        n(t._startAt, wt, wt);
      else if (!e)
        return;
    }
    for (t._pt = t._ptCache = 0, l = m && Ve(l) || l && !m, I = 0; I < y.length; I++) {
      if (x = y[I], R = x._gsap || lu(y)[I]._gsap, t._ptLookup[I] = B = {}, oc[R.id] && ti.length && Aa(), O = T === y ? I : T.indexOf(x), M && (k = new M()).init(x, U || S, t, O, T) !== !1 && (t._pt = _ = new Be(t._pt, x, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function(Q) {
        B[Q] = _;
      }), k.priority && (A = 1)), !M || U)
        for (w in S)
          qe[w] && (k = Iy(w, S, t, O, x, T)) ? k.priority && (A = 1) : B[w] = _ = hu.call(t, x, w, "get", S[w], O, T, 0, r.stringFilter);
      t._op && t._op[I] && t.kill(x, t._op[I]), C && t._pt && (Qn = t, kt.killTweensOf(x, B, t.globalTime(e)), z = !t.parent, Qn = 0), t._pt && l && (oc[R.id] = 1);
    }
    A && By(t), t._onInit && t._onInit(t);
  }
  t._onUpdate = h, t._initted = (!t._op || t._pt) && !z, f && e <= 0 && P.render(rn, !0, !0);
}, PA = function(n, t, e, i, r, s, o, a) {
  var l = (n._pt && n._ptCache || (n._ptCache = {}))[t], h, c, p, f;
  if (!l)
    for (l = n._ptCache[t] = [], p = n._ptLookup, f = n._targets.length; f--; ) {
      if (h = p[f][t], h && h.d && h.d._pt)
        for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
          h = h._next;
      if (!h)
        return dc = 1, n.vars[t] = "+=0", cu(n, o), dc = 0, a ? Js(t + " not eligible for reset") : 1;
      l.push(h);
    }
  for (f = l.length; f--; )
    c = l[f], h = c._pt || c, h.s = (i || i === 0) && !r ? i : h.s + (i || 0) + s * h.c, h.c = e - h.s, c.e && (c.e = Ut(e) + _e(c.e)), c.b && (c.b = h.s + _e(c.b));
}, IA = function(n, t) {
  var e = n[0] ? Li(n[0]).harness : 0, i = e && e.aliases, r, s, o, a;
  if (!i)
    return t;
  r = qi({}, t);
  for (s in i)
    if (s in r)
      for (a = i[s].split(","), o = a.length; o--; )
        r[a[o]] = r[s];
  return r;
}, RA = function(n, t, e, i) {
  var r = t.ease || i || "power1.inOut", s, o;
  if (we(t))
    o = e[n] || (e[n] = []), t.forEach(function(a, l) {
      return o.push({
        t: l / (t.length - 1) * 100,
        v: a,
        e: r
      });
    });
  else
    for (s in t)
      o = e[s] || (e[s] = []), s === "ease" || o.push({
        t: parseFloat(n),
        v: t[s],
        e: r
      });
}, Ls = function(n, t, e, i, r) {
  return Lt(n) ? n.call(t, e, i, r) : oe(n) && ~n.indexOf("random(") ? $s(n) : n;
}, Ry = au + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ky = {};
De(Ry + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
  return ky[n] = 1;
});
var Ht = /* @__PURE__ */ function(n) {
  Kg(t, n);
  function t(i, r, s, o) {
    var a;
    typeof r == "number" && (s.duration = r, r = s, s = null), a = n.call(this, o ? r : Os(r)) || this;
    var l = a.vars, h = l.duration, c = l.delay, p = l.immediateRender, f = l.stagger, u = l.overwrite, m = l.keyframes, g = l.defaults, y = l.scrollTrigger, b = l.yoyoEase, T = r.parent || kt, C = (we(i) || Jg(i) ? Nn(i[0]) : "length" in r) ? [i] : sn(i), P, S, I, w, _, x, A, R;
    if (a._targets = C.length ? lu(C) : Js("GSAP target " + i + " not found. https://gsap.com", !Xe.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = u, m || f || Ko(h) || Ko(c)) {
      if (r = a.vars, P = a.timeline = new Ce({
        data: "nested",
        defaults: g || {},
        targets: T && T.data === "nested" ? T.vars.targets : C
      }), P.kill(), P.parent = P._dp = Mn(a), P._start = 0, f || Ko(h) || Ko(c)) {
        if (w = C.length, A = f && my(f), Tn(f))
          for (_ in f)
            ~Ry.indexOf(_) && (R || (R = {}), R[_] = f[_]);
        for (S = 0; S < w; S++)
          I = Ta(r, ky), I.stagger = 0, b && (I.yoyoEase = b), R && qi(I, R), x = C[S], I.duration = +Ls(h, Mn(a), S, x, C), I.delay = (+Ls(c, Mn(a), S, x, C) || 0) - a._delay, !f && w === 1 && I.delay && (a._delay = c = I.delay, a._start += c, I.delay = 0), P.to(x, I, A ? A(S, x, C) : 0), P._ease = ht.none;
        P.duration() ? h = c = 0 : a.timeline = 0;
      } else if (m) {
        Os(on(P.vars.defaults, {
          ease: "none"
        })), P._ease = Ui(m.ease || r.ease || "none");
        var M = 0, k, B, O;
        if (we(m))
          m.forEach(function(U) {
            return P.to(C, U, ">");
          }), P.duration();
        else {
          I = {};
          for (_ in m)
            _ === "ease" || _ === "easeEach" || RA(_, m[_], I, m.easeEach);
          for (_ in I)
            for (k = I[_].sort(function(U, z) {
              return U.t - z.t;
            }), M = 0, S = 0; S < k.length; S++)
              B = k[S], O = {
                ease: B.e,
                duration: (B.t - (S ? k[S - 1].t : 0)) / 100 * h
              }, O[_] = B.v, P.to(C, O, M), M += O.duration;
          P.duration() < h && P.to({}, {
            duration: h - P.duration()
          });
        }
      }
      h || a.duration(h = P.duration());
    } else
      a.timeline = 0;
    return u === !0 && !eu && (Qn = Mn(a), kt.killTweensOf(C), Qn = 0), _n(T, Mn(a), s), r.reversed && a.reverse(), r.paused && a.paused(!0), (p || !h && !m && a._start === se(T._time) && Ve(p) && aA(Mn(a)) && T.data !== "nested") && (a._tTime = -wt, a.render(Math.max(0, -c) || 0)), y && uy(Mn(a), y), a;
  }
  var e = t.prototype;
  return e.render = function(i, r, s) {
    var o = this._time, a = this._tDur, l = this._dur, h = i < 0, c = i > a - wt && !h ? a : i < wt ? 0 : i, p, f, u, m, g, y, b, T, C;
    if (!l)
      hA(this, i, r, s);
    else if (c !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
      if (p = c, T = this.timeline, this._repeat) {
        if (m = l + this._rDelay, this._repeat < -1 && h)
          return this.totalTime(m * 100 + i, r, s);
        if (p = se(c % m), c === a ? (u = this._repeat, p = l) : (u = ~~(c / m), u && u === se(c / m) && (p = l, u--), p > l && (p = l)), y = this._yoyo && u & 1, y && (C = this._yEase, p = l - p), g = Mr(this._tTime, m), p === o && !s && this._initted && u === g)
          return this._tTime = c, this;
        u !== g && (T && this._yEase && Ey(T, y), this.vars.repeatRefresh && !y && !this._lock && this._time !== m && this._initted && (this._lock = s = 1, this.render(se(m * u), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (dy(this, h ? i : p, s, r, c))
          return this._tTime = 0, this;
        if (o !== this._time && !(s && this.vars.repeatRefresh && u !== g))
          return this;
        if (l !== this._dur)
          return this.render(i, r, s);
      }
      if (this._tTime = c, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = b = (C || this._ease)(p / l), this._from && (this.ratio = b = 1 - b), p && !o && !r && !u && (Ye(this, "onStart"), this._tTime !== c))
        return this;
      for (f = this._pt; f; )
        f.r(b, f.d), f = f._next;
      T && T.render(i < 0 ? i : T._dur * T._ease(p / this._dur), r, s) || this._startAt && (this._zTime = i), this._onUpdate && !r && (h && ac(this, i, r, s), Ye(this, "onUpdate")), this._repeat && u !== g && this.vars.onRepeat && !r && this.parent && Ye(this, "onRepeat"), (c === this._tDur || !c) && this._tTime === c && (h && !this._onUpdate && ac(this, i, !0, !0), (i || !l) && (c === this._tDur && this._ts > 0 || !c && this._ts < 0) && ai(this, 1), !r && !(h && !o) && (c || o || y) && (Ye(this, c === a ? "onComplete" : "onReverseComplete", !0), this._prom && !(c < a && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, e.targets = function() {
    return this._targets;
  }, e.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), n.prototype.invalidate.call(this, i);
  }, e.resetTo = function(i, r, s, o, a) {
    to || We.wake(), this._ts || this.play();
    var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || cu(this, l), h = this._ease(l / this._dur), PA(this, i, r, s, o, h, l, a) ? this.resetTo(i, r, s, o, 1) : (rl(this, 0), this.parent || hy(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, e.kill = function(i, r) {
    if (r === void 0 && (r = "all"), !i && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? Es(this) : this;
    if (this.timeline) {
      var s = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, r, Qn && Qn.vars.overwrite !== !0)._first || Es(this), this.parent && s !== this.timeline.totalDuration() && Vr(this, this._dur * this.timeline._tDur / s, 0, 1), this;
    }
    var o = this._targets, a = i ? sn(i) : o, l = this._ptLookup, h = this._pt, c, p, f, u, m, g, y;
    if ((!r || r === "all") && sA(o, a))
      return r === "all" && (this._pt = 0), Es(this);
    for (c = this._op = this._op || [], r !== "all" && (oe(r) && (m = {}, De(r, function(b) {
      return m[b] = 1;
    }), r = m), r = IA(o, r)), y = o.length; y--; )
      if (~a.indexOf(o[y])) {
        p = l[y], r === "all" ? (c[y] = r, u = p, f = {}) : (f = c[y] = c[y] || {}, u = r);
        for (m in u)
          g = p && p[m], g && ((!("kill" in g.d) || g.d.kill(m) === !0) && nl(this, g, "_pt"), delete p[m]), f !== "all" && (f[m] = 1);
      }
    return this._initted && !this._pt && h && Es(this), this;
  }, t.to = function(i, r) {
    return new t(i, r, arguments[2]);
  }, t.from = function(i, r) {
    return Fs(1, arguments);
  }, t.delayedCall = function(i, r, s, o) {
    return new t(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: s,
      onReverseCompleteParams: s,
      callbackScope: o
    });
  }, t.fromTo = function(i, r, s) {
    return Fs(2, arguments);
  }, t.set = function(i, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new t(i, r);
  }, t.killTweensOf = function(i, r, s) {
    return kt.killTweensOf(i, r, s);
  }, t;
}(eo);
on(Ht.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
De("staggerTo,staggerFrom,staggerFromTo", function(n) {
  Ht[n] = function() {
    var t = new Ce(), e = hc.call(arguments, 0);
    return e.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), t[n].apply(t, e);
  };
});
var uu = function(n, t, e) {
  return n[t] = e;
}, My = function(n, t, e) {
  return n[t](e);
}, kA = function(n, t, e, i) {
  return n[t](i.fp, e);
}, MA = function(n, t, e) {
  return n.setAttribute(t, e);
}, du = function(n, t) {
  return Lt(n[t]) ? My : nu(n[t]) && n.setAttribute ? MA : uu;
}, Vy = function(n, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * n) * 1e6) / 1e6, t);
}, VA = function(n, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * n), t);
}, Dy = function(n, t) {
  var e = t._pt, i = "";
  if (!n && t.b)
    i = t.b;
  else if (n === 1 && t.e)
    i = t.e;
  else {
    for (; e; )
      i = e.p + (e.m ? e.m(e.s + e.c * n) : Math.round((e.s + e.c * n) * 1e4) / 1e4) + i, e = e._next;
    i += t.c;
  }
  t.set(t.t, t.p, i, t);
}, pu = function(n, t) {
  for (var e = t._pt; e; )
    e.r(n, e.d), e = e._next;
}, DA = function(n, t, e, i) {
  for (var r = this._pt, s; r; )
    s = r._next, r.p === i && r.modifier(n, t, e), r = s;
}, BA = function(n) {
  for (var t = this._pt, e, i; t; )
    i = t._next, t.p === n && !t.op || t.op === n ? nl(this, t, "_pt") : t.dep || (e = 1), t = i;
  return !e;
}, OA = function(n, t, e, i) {
  i.mSet(n, t, i.m.call(i.tween, e, i.mt), i);
}, By = function(n) {
  for (var t = n._pt, e, i, r, s; t; ) {
    for (e = t._next, i = r; i && i.pr > t.pr; )
      i = i._next;
    (t._prev = i ? i._prev : s) ? t._prev._next = t : r = t, (t._next = i) ? i._prev = t : s = t, t = e;
  }
  n._pt = r;
}, Be = /* @__PURE__ */ function() {
  function n(e, i, r, s, o, a, l, h, c) {
    this.t = i, this.s = s, this.c = o, this.p = r, this.r = a || Vy, this.d = l || this, this.set = h || uu, this.pr = c || 0, this._next = e, e && (e._prev = this);
  }
  var t = n.prototype;
  return t.modifier = function(e, i, r) {
    this.mSet = this.mSet || this.set, this.set = OA, this.m = e, this.mt = r, this.tween = i;
  }, n;
}();
De(au + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
  return ou[n] = 1;
});
Qe.TweenMax = Qe.TweenLite = Ht;
Qe.TimelineLite = Qe.TimelineMax = Ce;
kt = new Ce({
  sortChildren: !1,
  defaults: kr,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
Xe.stringFilter = Ty;
var zi = [], ha = {}, FA = [], af = 0, LA = 0, vh = function(n) {
  return (ha[n] || FA).map(function(t) {
    return t();
  });
}, pc = function() {
  var n = Date.now(), t = [];
  n - af > 2 && (vh("matchMediaInit"), zi.forEach(function(e) {
    var i = e.queries, r = e.conditions, s, o, a, l;
    for (o in i)
      s = yn.matchMedia(i[o]).matches, s && (a = 1), s !== r[o] && (r[o] = s, l = 1);
    l && (e.revert(), a && t.push(e));
  }), vh("matchMediaRevert"), t.forEach(function(e) {
    return e.onMatch(e, function(i) {
      return e.add(null, i);
    });
  }), af = n, vh("matchMedia"));
}, Oy = /* @__PURE__ */ function() {
  function n(e, i) {
    this.selector = i && cc(i), this.data = [], this._r = [], this.isReverted = !1, this.id = LA++, e && this.add(e);
  }
  var t = n.prototype;
  return t.add = function(e, i, r) {
    Lt(e) && (r = i, i = e, e = Lt);
    var s = this, o = function() {
      var a = Et, l = s.selector, h;
      return a && a !== s && a.data.push(s), r && (s.selector = cc(r)), Et = s, h = i.apply(s, arguments), Lt(h) && s._r.push(h), Et = a, s.selector = l, s.isReverted = !1, h;
    };
    return s.last = o, e === Lt ? o(s, function(a) {
      return s.add(null, a);
    }) : e ? s[e] = o : o;
  }, t.ignore = function(e) {
    var i = Et;
    Et = null, e(this), Et = i;
  }, t.getTweens = function() {
    var e = [];
    return this.data.forEach(function(i) {
      return i instanceof n ? e.push.apply(e, i.getTweens()) : i instanceof Ht && !(i.parent && i.parent.data === "nested") && e.push(i);
    }), e;
  }, t.clear = function() {
    this._r.length = this.data.length = 0;
  }, t.kill = function(e, i) {
    var r = this;
    if (e ? function() {
      for (var o = r.getTweens(), a = r.data.length, l; a--; )
        l = r.data[a], l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function(h) {
          return o.splice(o.indexOf(h), 1);
        }));
      for (o.map(function(h) {
        return {
          g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
          t: h
        };
      }).sort(function(h, c) {
        return c.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(e);
      }), a = r.data.length; a--; )
        l = r.data[a], l instanceof Ce ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof Ht) && l.revert && l.revert(e);
      r._r.forEach(function(h) {
        return h(e, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(o) {
      return o.kill && o.kill();
    }), this.clear(), i)
      for (var s = zi.length; s--; )
        zi[s].id === this.id && zi.splice(s, 1);
  }, t.revert = function(e) {
    this.kill(e || {});
  }, n;
}(), NA = /* @__PURE__ */ function() {
  function n(e) {
    this.contexts = [], this.scope = e, Et && Et.data.push(this);
  }
  var t = n.prototype;
  return t.add = function(e, i, r) {
    Tn(e) || (e = {
      matches: e
    });
    var s = new Oy(0, r || this.scope), o = s.conditions = {}, a, l, h;
    Et && !s.selector && (s.selector = Et.selector), this.contexts.push(s), i = s.add("onMatch", i), s.queries = e;
    for (l in e)
      l === "all" ? h = 1 : (a = yn.matchMedia(e[l]), a && (zi.indexOf(s) < 0 && zi.push(s), (o[l] = a.matches) && (h = 1), a.addListener ? a.addListener(pc) : a.addEventListener("change", pc)));
    return h && i(s, function(c) {
      return s.add(null, c);
    }), this;
  }, t.revert = function(e) {
    this.kill(e || {});
  }, t.kill = function(e) {
    this.contexts.forEach(function(i) {
      return i.kill(e, !0);
    });
  }, n;
}(), Ea = {
  registerPlugin: function() {
    for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)
      t[e] = arguments[e];
    t.forEach(function(i) {
      return by(i);
    });
  },
  timeline: function(n) {
    return new Ce(n);
  },
  getTweensOf: function(n, t) {
    return kt.getTweensOf(n, t);
  },
  getProperty: function(n, t, e, i) {
    oe(n) && (n = sn(n)[0]);
    var r = Li(n || {}).get, s = e ? ly : ay;
    return e === "native" && (e = ""), n && (t ? s((qe[t] && qe[t].get || r)(n, t, e, i)) : function(o, a, l) {
      return s((qe[o] && qe[o].get || r)(n, o, a, l));
    });
  },
  quickSetter: function(n, t, e) {
    if (n = sn(n), n.length > 1) {
      var i = n.map(function(h) {
        return Fe.quickSetter(h, t, e);
      }), r = i.length;
      return function(h) {
        for (var c = r; c--; )
          i[c](h);
      };
    }
    n = n[0] || {};
    var s = qe[t], o = Li(n), a = o.harness && (o.harness.aliases || {})[t] || t, l = s ? function(h) {
      var c = new s();
      yr._pt = 0, c.init(n, e ? h + e : h, yr, 0, [n]), c.render(1, c), yr._pt && pu(1, yr);
    } : o.set(n, a);
    return s ? l : function(h) {
      return l(n, a, e ? h + e : h, o, 1);
    };
  },
  quickTo: function(n, t, e) {
    var i, r = Fe.to(n, qi((i = {}, i[t] = "+=0.1", i.paused = !0, i), e || {})), s = function(o, a, l) {
      return r.resetTo(t, o, a, l);
    };
    return s.tween = r, s;
  },
  isTweening: function(n) {
    return kt.getTweensOf(n, !0).length > 0;
  },
  defaults: function(n) {
    return n && n.ease && (n.ease = Ui(n.ease, kr.ease)), ef(kr, n || {});
  },
  config: function(n) {
    return ef(Xe, n || {});
  },
  registerEffect: function(n) {
    var t = n.name, e = n.effect, i = n.plugins, r = n.defaults, s = n.extendTimeline;
    (i || "").split(",").forEach(function(o) {
      return o && !qe[o] && !Qe[o] && Js(t + " effect requires " + o + " plugin.");
    }), mh[t] = function(o, a, l) {
      return e(sn(o), on(a || {}, r), l);
    }, s && (Ce.prototype[t] = function(o, a, l) {
      return this.add(mh[t](o, Tn(a) ? a : (l = a) && {}, this), l);
    });
  },
  registerEase: function(n, t) {
    ht[n] = Ui(t);
  },
  parseEase: function(n, t) {
    return arguments.length ? Ui(n, t) : ht;
  },
  getById: function(n) {
    return kt.getById(n);
  },
  exportRoot: function(n, t) {
    n === void 0 && (n = {});
    var e = new Ce(n), i, r;
    for (e.smoothChildTiming = Ve(n.smoothChildTiming), kt.remove(e), e._dp = 0, e._time = e._tTime = kt._time, i = kt._first; i; )
      r = i._next, (t || !(!i._dur && i instanceof Ht && i.vars.onComplete === i._targets[0])) && _n(e, i, i._start - i._delay), i = r;
    return _n(kt, e, 0), e;
  },
  context: function(n, t) {
    return n ? new Oy(n, t) : Et;
  },
  matchMedia: function(n) {
    return new NA(n);
  },
  matchMediaRefresh: function() {
    return zi.forEach(function(n) {
      var t = n.conditions, e, i;
      for (i in t)
        t[i] && (t[i] = !1, e = 1);
      e && n.revert();
    }) || pc();
  },
  addEventListener: function(n, t) {
    var e = ha[n] || (ha[n] = []);
    ~e.indexOf(t) || e.push(t);
  },
  removeEventListener: function(n, t) {
    var e = ha[n], i = e && e.indexOf(t);
    i >= 0 && e.splice(i, 1);
  },
  utils: {
    wrap: yA,
    wrapYoyo: _A,
    distribute: my,
    random: yy,
    snap: gy,
    normalize: gA,
    getUnit: _e,
    clamp: dA,
    splitColor: wy,
    toArray: sn,
    selector: cc,
    mapRange: vy,
    pipe: fA,
    unitize: mA,
    interpolate: vA,
    shuffle: fy
  },
  install: ny,
  effects: mh,
  ticker: We,
  updateRoot: Ce.updateRoot,
  plugins: qe,
  globalTimeline: kt,
  core: {
    PropTween: Be,
    globals: iy,
    Tween: Ht,
    Timeline: Ce,
    Animation: eo,
    getCache: Li,
    _removeLinkedListItem: nl,
    reverting: function() {
      return be;
    },
    context: function(n) {
      return n && Et && (Et.data.push(n), n._ctx = Et), Et;
    },
    suppressOverwrites: function(n) {
      return eu = n;
    }
  }
};
De("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
  return Ea[n] = Ht[n];
});
We.add(Ce.updateRoot);
yr = Ea.to({}, {
  duration: 0
});
var UA = function(n, t) {
  for (var e = n._pt; e && e.p !== t && e.op !== t && e.fp !== t; )
    e = e._next;
  return e;
}, zA = function(n, t) {
  var e = n._targets, i, r, s;
  for (i in t)
    for (r = e.length; r--; )
      s = n._ptLookup[r][i], s && (s = s.d) && (s._pt && (s = UA(s, i)), s && s.modifier && s.modifier(t[i], n, e[r], i));
}, xh = function(n, t) {
  return {
    name: n,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(e, i, r) {
      r._onInit = function(s) {
        var o, a;
        if (oe(i) && (o = {}, De(i, function(l) {
          return o[l] = 1;
        }), i = o), t) {
          o = {};
          for (a in i)
            o[a] = t(i[a]);
          i = o;
        }
        zA(s, i);
      };
    }
  };
}, Fe = Ea.registerPlugin({
  name: "attr",
  init: function(n, t, e, i, r) {
    var s, o, a;
    this.tween = e;
    for (s in t)
      a = n.getAttribute(s) || "", o = this.add(n, "setAttribute", (a || 0) + "", t[s], i, r, 0, 0, s), o.op = s, o.b = a, this._props.push(s);
  },
  render: function(n, t) {
    for (var e = t._pt; e; )
      be ? e.set(e.t, e.p, e.b, e) : e.r(n, e.d), e = e._next;
  }
}, {
  name: "endArray",
  init: function(n, t) {
    for (var e = t.length; e--; )
      this.add(n, e, n[e] || 0, t[e], 0, 0, 0, 0, 0, 1);
  }
}, xh("roundProps", uc), xh("modifiers"), xh("snap", gy)) || Ea;
Ht.version = Ce.version = Fe.version = "3.12.5";
ey = 1;
iu() && Dr();
ht.Power0;
ht.Power1;
ht.Power2;
ht.Power3;
ht.Power4;
ht.Linear;
ht.Quad;
ht.Cubic;
ht.Quart;
ht.Quint;
ht.Strong;
ht.Elastic;
ht.Back;
ht.SteppedEase;
ht.Bounce;
ht.Sine;
ht.Expo;
ht.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var lf, Jn, Ar, fu, Bi, hf, mu, jA = function() {
  return typeof window < "u";
}, Un = {}, Ii = 180 / Math.PI, Tr = Math.PI / 180, lr = Math.atan2, cf = 1e8, gu = /([A-Z])/g, GA = /(left|right|width|margin|padding|x)/i, HA = /[\s,\(]\S/, xn = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, fc = function(n, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * n) * 1e4) / 1e4 + t.u, t);
}, qA = function(n, t) {
  return t.set(t.t, t.p, n === 1 ? t.e : Math.round((t.s + t.c * n) * 1e4) / 1e4 + t.u, t);
}, WA = function(n, t) {
  return t.set(t.t, t.p, n ? Math.round((t.s + t.c * n) * 1e4) / 1e4 + t.u : t.b, t);
}, YA = function(n, t) {
  var e = t.s + t.c * n;
  t.set(t.t, t.p, ~~(e + (e < 0 ? -0.5 : 0.5)) + t.u, t);
}, Fy = function(n, t) {
  return t.set(t.t, t.p, n ? t.e : t.b, t);
}, Ly = function(n, t) {
  return t.set(t.t, t.p, n !== 1 ? t.b : t.e, t);
}, XA = function(n, t, e) {
  return n.style[t] = e;
}, KA = function(n, t, e) {
  return n.style.setProperty(t, e);
}, QA = function(n, t, e) {
  return n._gsap[t] = e;
}, JA = function(n, t, e) {
  return n._gsap.scaleX = n._gsap.scaleY = e;
}, ZA = function(n, t, e, i, r) {
  var s = n._gsap;
  s.scaleX = s.scaleY = e, s.renderTransform(r, s);
}, $A = function(n, t, e, i, r) {
  var s = n._gsap;
  s[t] = e, s.renderTransform(r, s);
}, Dt = "transform", Oe = Dt + "Origin", tT = function n(t, e) {
  var i = this, r = this.target, s = r.style, o = r._gsap;
  if (t in Un && s) {
    if (this.tfm = this.tfm || {}, t !== "transform")
      t = xn[t] || t, ~t.indexOf(",") ? t.split(",").forEach(function(a) {
        return i.tfm[a] = Vn(r, a);
      }) : this.tfm[t] = o.x ? o[t] : Vn(r, t), t === Oe && (this.tfm.zOrigin = o.zOrigin);
    else
      return xn.transform.split(",").forEach(function(a) {
        return n.call(i, a, e);
      });
    if (this.props.indexOf(Dt) >= 0)
      return;
    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Oe, e, "")), t = Dt;
  }
  (s || e) && this.props.push(t, e, s[t]);
}, Ny = function(n) {
  n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"));
}, eT = function() {
  var n = this.props, t = this.target, e = t.style, i = t._gsap, r, s;
  for (r = 0; r < n.length; r += 3)
    n[r + 1] ? t[n[r]] = n[r + 2] : n[r + 2] ? e[n[r]] = n[r + 2] : e.removeProperty(n[r].substr(0, 2) === "--" ? n[r] : n[r].replace(gu, "-$1").toLowerCase());
  if (this.tfm) {
    for (s in this.tfm)
      i[s] = this.tfm[s];
    i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = mu(), (!r || !r.isStart) && !e[Dt] && (Ny(e), i.zOrigin && e[Oe] && (e[Oe] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, Uy = function(n, t) {
  var e = {
    target: n,
    props: [],
    revert: eT,
    save: tT
  };
  return n._gsap || Fe.core.getCache(n), t && t.split(",").forEach(function(i) {
    return e.save(i);
  }), e;
}, zy, mc = function(n, t) {
  var e = Jn.createElementNS ? Jn.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), n) : Jn.createElement(n);
  return e && e.style ? e : Jn.createElement(n);
}, bn = function n(t, e, i) {
  var r = getComputedStyle(t);
  return r[e] || r.getPropertyValue(e.replace(gu, "-$1").toLowerCase()) || r.getPropertyValue(e) || !i && n(t, Br(e) || e, 1) || "";
}, uf = "O,Moz,ms,Ms,Webkit".split(","), Br = function(n, t, e) {
  var i = t || Bi, r = i.style, s = 5;
  if (n in r && !e)
    return n;
  for (n = n.charAt(0).toUpperCase() + n.substr(1); s-- && !(uf[s] + n in r); )
    ;
  return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? uf[s] : "") + n;
}, gc = function() {
  jA() && window.document && (lf = window, Jn = lf.document, Ar = Jn.documentElement, Bi = mc("div") || {
    style: {}
  }, mc("div"), Dt = Br(Dt), Oe = Dt + "Origin", Bi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", zy = !!Br("perspective"), mu = Fe.core.reverting, fu = 1);
}, bh = function n(t) {
  var e = mc("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, s = this.style.cssText, o;
  if (Ar.appendChild(e), e.appendChild(this), this.style.display = "block", t)
    try {
      o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n;
    } catch {
    }
  else this._gsapBBox && (o = this._gsapBBox());
  return i && (r ? i.insertBefore(this, r) : i.appendChild(this)), Ar.removeChild(e), this.style.cssText = s, o;
}, df = function(n, t) {
  for (var e = t.length; e--; )
    if (n.hasAttribute(t[e]))
      return n.getAttribute(t[e]);
}, jy = function(n) {
  var t;
  try {
    t = n.getBBox();
  } catch {
    t = bh.call(n, !0);
  }
  return t && (t.width || t.height) || n.getBBox === bh || (t = bh.call(n, !0)), t && !t.width && !t.x && !t.y ? {
    x: +df(n, ["x", "cx", "x1"]) || 0,
    y: +df(n, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, Gy = function(n) {
  return !!(n.getCTM && (!n.parentNode || n.ownerSVGElement) && jy(n));
}, Wi = function(n, t) {
  if (t) {
    var e = n.style, i;
    t in Un && t !== Oe && (t = Dt), e.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), e.removeProperty(i === "--" ? t : t.replace(gu, "-$1").toLowerCase())) : e.removeAttribute(t);
  }
}, Zn = function(n, t, e, i, r, s) {
  var o = new Be(n._pt, t, e, 0, 1, s ? Ly : Fy);
  return n._pt = o, o.b = i, o.e = r, n._props.push(e), o;
}, pf = {
  deg: 1,
  rad: 1,
  turn: 1
}, nT = {
  grid: 1,
  flex: 1
}, li = function n(t, e, i, r) {
  var s = parseFloat(i) || 0, o = (i + "").trim().substr((s + "").length) || "px", a = Bi.style, l = GA.test(e), h = t.tagName.toLowerCase() === "svg", c = (h ? "client" : "offset") + (l ? "Width" : "Height"), p = 100, f = r === "px", u = r === "%", m, g, y, b;
  if (r === o || !s || pf[r] || pf[o])
    return s;
  if (o !== "px" && !f && (s = n(t, e, i, "px")), b = t.getCTM && Gy(t), (u || o === "%") && (Un[e] || ~e.indexOf("adius")))
    return m = b ? t.getBBox()[l ? "width" : "height"] : t[c], Ut(u ? s / m * p : s / 100 * m);
  if (a[l ? "width" : "height"] = p + (f ? o : r), g = ~e.indexOf("adius") || r === "em" && t.appendChild && !h ? t : t.parentNode, b && (g = (t.ownerSVGElement || {}).parentNode), (!g || g === Jn || !g.appendChild) && (g = Jn.body), y = g._gsap, y && u && y.width && l && y.time === We.time && !y.uncache)
    return Ut(s / y.width * p);
  if (u && (e === "height" || e === "width")) {
    var T = t.style[e];
    t.style[e] = p + r, m = t[c], T ? t.style[e] = T : Wi(t, e);
  } else
    (u || o === "%") && !nT[bn(g, "display")] && (a.position = bn(t, "position")), g === t && (a.position = "static"), g.appendChild(Bi), m = Bi[c], g.removeChild(Bi), a.position = "absolute";
  return l && u && (y = Li(g), y.time = We.time, y.width = g[c]), Ut(f ? m * s / p : m && s ? p / m * s : 0);
}, Vn = function(n, t, e, i) {
  var r;
  return fu || gc(), t in xn && t !== "transform" && (t = xn[t], ~t.indexOf(",") && (t = t.split(",")[0])), Un[t] && t !== "transform" ? (r = io(n, i), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Pa(bn(n, Oe)) + " " + r.zOrigin + "px") : (r = n.style[t], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = Ca[t] && Ca[t](n, t, e) || bn(n, t) || sy(n, t) || (t === "opacity" ? 1 : 0))), e && !~(r + "").trim().indexOf(" ") ? li(n, t, r, e) + e : r;
}, iT = function(n, t, e, i) {
  if (!e || e === "none") {
    var r = Br(t, n, 1), s = r && bn(n, r, 1);
    s && s !== e ? (t = r, e = s) : t === "borderColor" && (e = bn(n, "borderTopColor"));
  }
  var o = new Be(this._pt, n.style, t, 0, 1, Dy), a = 0, l = 0, h, c, p, f, u, m, g, y, b, T, C, P;
  if (o.b = e, o.e = i, e += "", i += "", i === "auto" && (m = n.style[t], n.style[t] = i, i = bn(n, t) || i, m ? n.style[t] = m : Wi(n, t)), h = [e, i], Ty(h), e = h[0], i = h[1], p = e.match(gr) || [], P = i.match(gr) || [], P.length) {
    for (; c = gr.exec(i); )
      g = c[0], b = i.substring(a, c.index), u ? u = (u + 1) % 5 : (b.substr(-5) === "rgba(" || b.substr(-5) === "hsla(") && (u = 1), g !== (m = p[l++] || "") && (f = parseFloat(m) || 0, C = m.substr((f + "").length), g.charAt(1) === "=" && (g = wr(f, g) + C), y = parseFloat(g), T = g.substr((y + "").length), a = gr.lastIndex - T.length, T || (T = T || Xe.units[t] || C, a === i.length && (i += T, o.e += T)), C !== T && (f = li(n, t, m, T) || 0), o._pt = {
        _next: o._pt,
        p: b || l === 1 ? b : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: f,
        c: y - f,
        m: u && u < 4 || t === "zIndex" ? Math.round : 0
      });
    o.c = a < i.length ? i.substring(a, i.length) : "";
  } else
    o.r = t === "display" && i === "none" ? Ly : Fy;
  return $g.test(i) && (o.e = 0), this._pt = o, o;
}, ff = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, rT = function(n) {
  var t = n.split(" "), e = t[0], i = t[1] || "50%";
  return (e === "top" || e === "bottom" || i === "left" || i === "right") && (n = e, e = i, i = n), t[0] = ff[e] || e, t[1] = ff[i] || i, t.join(" ");
}, sT = function(n, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var e = t.t, i = e.style, r = t.u, s = e._gsap, o, a, l;
    if (r === "all" || r === !0)
      i.cssText = "", a = 1;
    else
      for (r = r.split(","), l = r.length; --l > -1; )
        o = r[l], Un[o] && (a = 1, o = o === "transformOrigin" ? Oe : Dt), Wi(e, o);
    a && (Wi(e, Dt), s && (s.svg && e.removeAttribute("transform"), io(e, 1), s.uncache = 1, Ny(i)));
  }
}, Ca = {
  clearProps: function(n, t, e, i, r) {
    if (r.data !== "isFromStart") {
      var s = n._pt = new Be(n._pt, t, e, 0, 0, sT);
      return s.u = i, s.pr = -10, s.tween = r, n._props.push(e), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, no = [1, 0, 0, 1, 0, 0], Hy = {}, qy = function(n) {
  return n === "matrix(1, 0, 0, 1, 0, 0)" || n === "none" || !n;
}, mf = function(n) {
  var t = bn(n, Dt);
  return qy(t) ? no : t.substr(7).match(Zg).map(Ut);
}, yu = function(n, t) {
  var e = n._gsap || Li(n), i = n.style, r = mf(n), s, o, a, l;
  return e.svg && n.getAttribute("transform") ? (a = n.transform.baseVal.consolidate().matrix, r = [a.a, a.b, a.c, a.d, a.e, a.f], r.join(",") === "1,0,0,1,0,0" ? no : r) : (r === no && !n.offsetParent && n !== Ar && !e.svg && (a = i.display, i.display = "block", s = n.parentNode, (!s || !n.offsetParent) && (l = 1, o = n.nextElementSibling, Ar.appendChild(n)), r = mf(n), a ? i.display = a : Wi(n, "display"), l && (o ? s.insertBefore(n, o) : s ? s.appendChild(n) : Ar.removeChild(n))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, yc = function(n, t, e, i, r, s) {
  var o = n._gsap, a = r || yu(n, !0), l = o.xOrigin || 0, h = o.yOrigin || 0, c = o.xOffset || 0, p = o.yOffset || 0, f = a[0], u = a[1], m = a[2], g = a[3], y = a[4], b = a[5], T = t.split(" "), C = parseFloat(T[0]) || 0, P = parseFloat(T[1]) || 0, S, I, w, _;
  e ? a !== no && (I = f * g - u * m) && (w = C * (g / I) + P * (-m / I) + (m * b - g * y) / I, _ = C * (-u / I) + P * (f / I) - (f * b - u * y) / I, C = w, P = _) : (S = jy(n), C = S.x + (~T[0].indexOf("%") ? C / 100 * S.width : C), P = S.y + (~(T[1] || T[0]).indexOf("%") ? P / 100 * S.height : P)), i || i !== !1 && o.smooth ? (y = C - l, b = P - h, o.xOffset = c + (y * f + b * m) - y, o.yOffset = p + (y * u + b * g) - b) : o.xOffset = o.yOffset = 0, o.xOrigin = C, o.yOrigin = P, o.smooth = !!i, o.origin = t, o.originIsAbsolute = !!e, n.style[Oe] = "0px 0px", s && (Zn(s, o, "xOrigin", l, C), Zn(s, o, "yOrigin", h, P), Zn(s, o, "xOffset", c, o.xOffset), Zn(s, o, "yOffset", p, o.yOffset)), n.setAttribute("data-svg-origin", C + " " + P);
}, io = function(n, t) {
  var e = n._gsap || new Py(n);
  if ("x" in e && !t && !e.uncache)
    return e;
  var i = n.style, r = e.scaleX < 0, s = "px", o = "deg", a = getComputedStyle(n), l = bn(n, Oe) || "0", h, c, p, f, u, m, g, y, b, T, C, P, S, I, w, _, x, A, R, M, k, B, O, U, z, Q, j, H, _t, J, $, St;
  return h = c = p = m = g = y = b = T = C = 0, f = u = 1, e.svg = !!(n.getCTM && Gy(n)), a.translate && ((a.translate !== "none" || a.scale !== "none" || a.rotate !== "none") && (i[Dt] = (a.translate !== "none" ? "translate3d(" + (a.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (a.rotate !== "none" ? "rotate(" + a.rotate + ") " : "") + (a.scale !== "none" ? "scale(" + a.scale.split(" ").join(",") + ") " : "") + (a[Dt] !== "none" ? a[Dt] : "")), i.scale = i.rotate = i.translate = "none"), I = yu(n, e.svg), e.svg && (e.uncache ? (z = n.getBBox(), l = e.xOrigin - z.x + "px " + (e.yOrigin - z.y) + "px", U = "") : U = !t && n.getAttribute("data-svg-origin"), yc(n, U || l, !!U || e.originIsAbsolute, e.smooth !== !1, I)), P = e.xOrigin || 0, S = e.yOrigin || 0, I !== no && (A = I[0], R = I[1], M = I[2], k = I[3], h = B = I[4], c = O = I[5], I.length === 6 ? (f = Math.sqrt(A * A + R * R), u = Math.sqrt(k * k + M * M), m = A || R ? lr(R, A) * Ii : 0, b = M || k ? lr(M, k) * Ii + m : 0, b && (u *= Math.abs(Math.cos(b * Tr))), e.svg && (h -= P - (P * A + S * M), c -= S - (P * R + S * k))) : (St = I[6], J = I[7], j = I[8], H = I[9], _t = I[10], $ = I[11], h = I[12], c = I[13], p = I[14], w = lr(St, _t), g = w * Ii, w && (_ = Math.cos(-w), x = Math.sin(-w), U = B * _ + j * x, z = O * _ + H * x, Q = St * _ + _t * x, j = B * -x + j * _, H = O * -x + H * _, _t = St * -x + _t * _, $ = J * -x + $ * _, B = U, O = z, St = Q), w = lr(-M, _t), y = w * Ii, w && (_ = Math.cos(-w), x = Math.sin(-w), U = A * _ - j * x, z = R * _ - H * x, Q = M * _ - _t * x, $ = k * x + $ * _, A = U, R = z, M = Q), w = lr(R, A), m = w * Ii, w && (_ = Math.cos(w), x = Math.sin(w), U = A * _ + R * x, z = B * _ + O * x, R = R * _ - A * x, O = O * _ - B * x, A = U, B = z), g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0, y = 180 - y), f = Ut(Math.sqrt(A * A + R * R + M * M)), u = Ut(Math.sqrt(O * O + St * St)), w = lr(B, O), b = Math.abs(w) > 2e-4 ? w * Ii : 0, C = $ ? 1 / ($ < 0 ? -$ : $) : 0), e.svg && (U = n.getAttribute("transform"), e.forceCSS = n.setAttribute("transform", "") || !qy(bn(n, Dt)), U && n.setAttribute("transform", U))), Math.abs(b) > 90 && Math.abs(b) < 270 && (r ? (f *= -1, b += m <= 0 ? 180 : -180, m += m <= 0 ? 180 : -180) : (u *= -1, b += b <= 0 ? 180 : -180)), t = t || e.uncache, e.x = h - ((e.xPercent = h && (!t && e.xPercent || (Math.round(n.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? n.offsetWidth * e.xPercent / 100 : 0) + s, e.y = c - ((e.yPercent = c && (!t && e.yPercent || (Math.round(n.offsetHeight / 2) === Math.round(-c) ? -50 : 0))) ? n.offsetHeight * e.yPercent / 100 : 0) + s, e.z = p + s, e.scaleX = Ut(f), e.scaleY = Ut(u), e.rotation = Ut(m) + o, e.rotationX = Ut(g) + o, e.rotationY = Ut(y) + o, e.skewX = b + o, e.skewY = T + o, e.transformPerspective = C + s, (e.zOrigin = parseFloat(l.split(" ")[2]) || !t && e.zOrigin || 0) && (i[Oe] = Pa(l)), e.xOffset = e.yOffset = 0, e.force3D = Xe.force3D, e.renderTransform = e.svg ? aT : zy ? Wy : oT, e.uncache = 0, e;
}, Pa = function(n) {
  return (n = n.split(" "))[0] + " " + n[1];
}, wh = function(n, t, e) {
  var i = _e(t);
  return Ut(parseFloat(t) + parseFloat(li(n, "x", e + "px", i))) + i;
}, oT = function(n, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Wy(n, t);
}, Ai = "0deg", bs = "0px", Ti = ") ", Wy = function(n, t) {
  var e = t || this, i = e.xPercent, r = e.yPercent, s = e.x, o = e.y, a = e.z, l = e.rotation, h = e.rotationY, c = e.rotationX, p = e.skewX, f = e.skewY, u = e.scaleX, m = e.scaleY, g = e.transformPerspective, y = e.force3D, b = e.target, T = e.zOrigin, C = "", P = y === "auto" && n && n !== 1 || y === !0;
  if (T && (c !== Ai || h !== Ai)) {
    var S = parseFloat(h) * Tr, I = Math.sin(S), w = Math.cos(S), _;
    S = parseFloat(c) * Tr, _ = Math.cos(S), s = wh(b, s, I * _ * -T), o = wh(b, o, -Math.sin(S) * -T), a = wh(b, a, w * _ * -T + T);
  }
  g !== bs && (C += "perspective(" + g + Ti), (i || r) && (C += "translate(" + i + "%, " + r + "%) "), (P || s !== bs || o !== bs || a !== bs) && (C += a !== bs || P ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + Ti), l !== Ai && (C += "rotate(" + l + Ti), h !== Ai && (C += "rotateY(" + h + Ti), c !== Ai && (C += "rotateX(" + c + Ti), (p !== Ai || f !== Ai) && (C += "skew(" + p + ", " + f + Ti), (u !== 1 || m !== 1) && (C += "scale(" + u + ", " + m + Ti), b.style[Dt] = C || "translate(0, 0)";
}, aT = function(n, t) {
  var e = t || this, i = e.xPercent, r = e.yPercent, s = e.x, o = e.y, a = e.rotation, l = e.skewX, h = e.skewY, c = e.scaleX, p = e.scaleY, f = e.target, u = e.xOrigin, m = e.yOrigin, g = e.xOffset, y = e.yOffset, b = e.forceCSS, T = parseFloat(s), C = parseFloat(o), P, S, I, w, _;
  a = parseFloat(a), l = parseFloat(l), h = parseFloat(h), h && (h = parseFloat(h), l += h, a += h), a || l ? (a *= Tr, l *= Tr, P = Math.cos(a) * c, S = Math.sin(a) * c, I = Math.sin(a - l) * -p, w = Math.cos(a - l) * p, l && (h *= Tr, _ = Math.tan(l - h), _ = Math.sqrt(1 + _ * _), I *= _, w *= _, h && (_ = Math.tan(h), _ = Math.sqrt(1 + _ * _), P *= _, S *= _)), P = Ut(P), S = Ut(S), I = Ut(I), w = Ut(w)) : (P = c, w = p, S = I = 0), (T && !~(s + "").indexOf("px") || C && !~(o + "").indexOf("px")) && (T = li(f, "x", s, "px"), C = li(f, "y", o, "px")), (u || m || g || y) && (T = Ut(T + u - (u * P + m * I) + g), C = Ut(C + m - (u * S + m * w) + y)), (i || r) && (_ = f.getBBox(), T = Ut(T + i / 100 * _.width), C = Ut(C + r / 100 * _.height)), _ = "matrix(" + P + "," + S + "," + I + "," + w + "," + T + "," + C + ")", f.setAttribute("transform", _), b && (f.style[Dt] = _);
}, lT = function(n, t, e, i, r) {
  var s = 360, o = oe(r), a = parseFloat(r) * (o && ~r.indexOf("rad") ? Ii : 1), l = a - i, h = i + l + "deg", c, p;
  return o && (c = r.split("_")[1], c === "short" && (l %= s, l !== l % (s / 2) && (l += l < 0 ? s : -s)), c === "cw" && l < 0 ? l = (l + s * cf) % s - ~~(l / s) * s : c === "ccw" && l > 0 && (l = (l - s * cf) % s - ~~(l / s) * s)), n._pt = p = new Be(n._pt, t, e, i, l, qA), p.e = h, p.u = "deg", n._props.push(e), p;
}, gf = function(n, t) {
  for (var e in t)
    n[e] = t[e];
  return n;
}, hT = function(n, t, e) {
  var i = gf({}, e._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", s = e.style, o, a, l, h, c, p, f, u;
  i.svg ? (l = e.getAttribute("transform"), e.setAttribute("transform", ""), s[Dt] = t, o = io(e, 1), Wi(e, Dt), e.setAttribute("transform", l)) : (l = getComputedStyle(e)[Dt], s[Dt] = t, o = io(e, 1), s[Dt] = l);
  for (a in Un)
    l = i[a], h = o[a], l !== h && r.indexOf(a) < 0 && (f = _e(l), u = _e(h), c = f !== u ? li(e, a, l, u) : parseFloat(l), p = parseFloat(h), n._pt = new Be(n._pt, o, a, c, p - c, fc), n._pt.u = u || 0, n._props.push(a));
  gf(o, i);
};
De("padding,margin,Width,Radius", function(n, t) {
  var e = "Top", i = "Right", r = "Bottom", s = "Left", o = (t < 3 ? [e, i, r, s] : [e + s, e + i, r + i, r + s]).map(function(a) {
    return t < 2 ? n + a : "border" + a + n;
  });
  Ca[t > 1 ? "border" + n : n] = function(a, l, h, c, p) {
    var f, u;
    if (arguments.length < 4)
      return f = o.map(function(m) {
        return Vn(a, m, h);
      }), u = f.join(" "), u.split(f[0]).length === 5 ? f[0] : u;
    f = (c + "").split(" "), u = {}, o.forEach(function(m, g) {
      return u[m] = f[g] = f[g] || f[(g - 1) / 2 | 0];
    }), a.init(l, u, p);
  };
});
var Yy = {
  name: "css",
  register: gc,
  targetTest: function(n) {
    return n.style && n.nodeType;
  },
  init: function(n, t, e, i, r) {
    var s = this._props, o = n.style, a = e.vars.startAt, l, h, c, p, f, u, m, g, y, b, T, C, P, S, I, w;
    fu || gc(), this.styles = this.styles || Uy(n), w = this.styles.props, this.tween = e;
    for (m in t)
      if (m !== "autoRound" && (h = t[m], !(qe[m] && Iy(m, t, e, i, n, r)))) {
        if (f = typeof h, u = Ca[m], f === "function" && (h = h.call(e, i, n, r), f = typeof h), f === "string" && ~h.indexOf("random(") && (h = $s(h)), u)
          u(this, n, m, h, e) && (I = 1);
        else if (m.substr(0, 2) === "--")
          l = (getComputedStyle(n).getPropertyValue(m) + "").trim(), h += "", ei.lastIndex = 0, ei.test(l) || (g = _e(l), y = _e(h)), y ? g !== y && (l = li(n, m, l, y) + y) : g && (h += g), this.add(o, "setProperty", l, h, i, r, 0, 0, m), s.push(m), w.push(m, 0, o[m]);
        else if (f !== "undefined") {
          if (a && m in a ? (l = typeof a[m] == "function" ? a[m].call(e, i, n, r) : a[m], oe(l) && ~l.indexOf("random(") && (l = $s(l)), _e(l + "") || l === "auto" || (l += Xe.units[m] || _e(Vn(n, m)) || ""), (l + "").charAt(1) === "=" && (l = Vn(n, m))) : l = Vn(n, m), p = parseFloat(l), b = f === "string" && h.charAt(1) === "=" && h.substr(0, 2), b && (h = h.substr(2)), c = parseFloat(h), m in xn && (m === "autoAlpha" && (p === 1 && Vn(n, "visibility") === "hidden" && c && (p = 0), w.push("visibility", 0, o.visibility), Zn(this, o, "visibility", p ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)), m !== "scale" && m !== "transform" && (m = xn[m], ~m.indexOf(",") && (m = m.split(",")[0]))), T = m in Un, T) {
            if (this.styles.save(m), C || (P = n._gsap, P.renderTransform && !t.parseTransform || io(n, t.parseTransform), S = t.smoothOrigin !== !1 && P.smooth, C = this._pt = new Be(this._pt, o, Dt, 0, 1, P.renderTransform, P, 0, -1), C.dep = 1), m === "scale")
              this._pt = new Be(this._pt, P, "scaleY", P.scaleY, (b ? wr(P.scaleY, b + c) : c) - P.scaleY || 0, fc), this._pt.u = 0, s.push("scaleY", m), m += "X";
            else if (m === "transformOrigin") {
              w.push(Oe, 0, o[Oe]), h = rT(h), P.svg ? yc(n, h, 0, S, 0, this) : (y = parseFloat(h.split(" ")[2]) || 0, y !== P.zOrigin && Zn(this, P, "zOrigin", P.zOrigin, y), Zn(this, o, m, Pa(l), Pa(h)));
              continue;
            } else if (m === "svgOrigin") {
              yc(n, h, 1, S, 0, this);
              continue;
            } else if (m in Hy) {
              lT(this, P, m, p, b ? wr(p, b + h) : h);
              continue;
            } else if (m === "smoothOrigin") {
              Zn(this, P, "smooth", P.smooth, h);
              continue;
            } else if (m === "force3D") {
              P[m] = h;
              continue;
            } else if (m === "transform") {
              hT(this, h, n);
              continue;
            }
          } else m in o || (m = Br(m) || m);
          if (T || (c || c === 0) && (p || p === 0) && !HA.test(h) && m in o)
            g = (l + "").substr((p + "").length), c || (c = 0), y = _e(h) || (m in Xe.units ? Xe.units[m] : g), g !== y && (p = li(n, m, l, y)), this._pt = new Be(this._pt, T ? P : o, m, p, (b ? wr(p, b + c) : c) - p, !T && (y === "px" || m === "zIndex") && t.autoRound !== !1 ? YA : fc), this._pt.u = y || 0, g !== y && y !== "%" && (this._pt.b = l, this._pt.r = WA);
          else if (m in o)
            iT.call(this, n, m, l, b ? b + h : h);
          else if (m in n)
            this.add(n, m, l || n[m], b ? b + h : h, i, r);
          else if (m !== "parseTransform") {
            su(m, h);
            continue;
          }
          T || (m in o ? w.push(m, 0, o[m]) : w.push(m, 1, l || n[m])), s.push(m);
        }
      }
    I && By(this);
  },
  render: function(n, t) {
    if (t.tween._time || !mu())
      for (var e = t._pt; e; )
        e.r(n, e.d), e = e._next;
    else
      t.styles.revert();
  },
  get: Vn,
  aliases: xn,
  getSetter: function(n, t, e) {
    var i = xn[t];
    return i && i.indexOf(",") < 0 && (t = i), t in Un && t !== Oe && (n._gsap.x || Vn(n, "x")) ? e && hf === e ? t === "scale" ? JA : QA : (hf = e || {}) && (t === "scale" ? ZA : $A) : n.style && !nu(n.style[t]) ? XA : ~t.indexOf("-") ? KA : du(n, t);
  },
  core: {
    _removeProperty: Wi,
    _getMatrix: yu
  }
};
Fe.utils.checkPrefix = Br;
Fe.core.getStyleSaver = Uy;
(function(n, t, e, i) {
  var r = De(n + "," + t + "," + e, function(s) {
    Un[s] = 1;
  });
  De(t, function(s) {
    Xe.units[s] = "deg", Hy[s] = 1;
  }), xn[r[13]] = n + "," + t, De(i, function(s) {
    var o = s.split(":");
    xn[o[1]] = r[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
De("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
  Xe.units[n] = "px";
});
Fe.registerPlugin(Yy);
var Ps = Fe.registerPlugin(Yy) || Fe;
Ps.core.Tween;
class Xr {
  constructor(t) {
    Ee(this, "_options"), Ee(this, "_tween", null), this._options = t;
  }
  get options() {
    return this._options;
  }
  get name() {
    return this._options.name;
  }
  start(t) {
    return new Promise((e) => {
      this._tween = Ps.fromTo(t, this.options.from, {
        ...this.options.to,
        onComplete: () => e(),
        duration: this.options.duration,
        repeat: this.options.repeat,
        yoyo: this.options.revert,
        ease: this.options.ease,
        delay: this.options.delay,
        repeatDelay: this.options.repeatDelay
      }), this._tween.play();
    });
  }
  stop() {
    var t;
    (t = this._tween) == null || t.kill();
  }
  pause() {
    var t;
    (t = this._tween) == null || t.pause();
  }
  resume() {
    var t;
    (t = this._tween) == null || t.resume();
  }
  finish() {
    var t;
    (t = this._tween) == null || t.progress(1);
  }
  static initEngine() {
    Ps.ticker.remove(Ps.updateRoot);
  }
  static updateEngine(t) {
    this._rootTimeMs += t, Ps.updateRoot(this._rootTimeMs / 1e3);
  }
}
Ee(Xr, "_rootTimeMs", 0);
var Xy = { exports: {} };
/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(n, t) {
  (function(e, i) {
    n.exports = i();
  })(ki, function() {
    return (
      /******/
      function(e) {
        var i = {};
        function r(s) {
          if (i[s])
            return i[s].exports;
          var o = i[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return e[s].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
        }
        return r.m = e, r.c = i, r.d = function(s, o, a) {
          r.o(s, o) || Object.defineProperty(s, o, { enumerable: !0, get: a });
        }, r.r = function(s) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: !0 });
        }, r.t = function(s, o) {
          if (o & 1 && (s = r(s)), o & 8 || o & 4 && typeof s == "object" && s && s.__esModule) return s;
          var a = /* @__PURE__ */ Object.create(null);
          if (r.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: s }), o & 2 && typeof s != "string") for (var l in s) r.d(a, l, (function(h) {
            return s[h];
          }).bind(null, l));
          return a;
        }, r.n = function(s) {
          var o = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return r.d(o, "a", o), o;
        }, r.o = function(s, o) {
          return Object.prototype.hasOwnProperty.call(s, o);
        }, r.p = "", r(r.s = 20);
      }([
        /* 0 */
        /***/
        function(e, i) {
          var r = {};
          e.exports = r, function() {
            r._baseDelta = 1e3 / 60, r._nextId = 0, r._seed = 0, r._nowStartTime = +/* @__PURE__ */ new Date(), r._warnedOnce = {}, r._decomp = null, r.extend = function(o, a) {
              var l, h;
              typeof a == "boolean" ? (l = 2, h = a) : (l = 1, h = !0);
              for (var c = l; c < arguments.length; c++) {
                var p = arguments[c];
                if (p)
                  for (var f in p)
                    h && p[f] && p[f].constructor === Object && (!o[f] || o[f].constructor === Object) ? (o[f] = o[f] || {}, r.extend(o[f], h, p[f])) : o[f] = p[f];
              }
              return o;
            }, r.clone = function(o, a) {
              return r.extend({}, a, o);
            }, r.keys = function(o) {
              if (Object.keys)
                return Object.keys(o);
              var a = [];
              for (var l in o)
                a.push(l);
              return a;
            }, r.values = function(o) {
              var a = [];
              if (Object.keys) {
                for (var l = Object.keys(o), h = 0; h < l.length; h++)
                  a.push(o[l[h]]);
                return a;
              }
              for (var c in o)
                a.push(o[c]);
              return a;
            }, r.get = function(o, a, l, h) {
              a = a.split(".").slice(l, h);
              for (var c = 0; c < a.length; c += 1)
                o = o[a[c]];
              return o;
            }, r.set = function(o, a, l, h, c) {
              var p = a.split(".").slice(h, c);
              return r.get(o, a, 0, -1)[p[p.length - 1]] = l, l;
            }, r.shuffle = function(o) {
              for (var a = o.length - 1; a > 0; a--) {
                var l = Math.floor(r.random() * (a + 1)), h = o[a];
                o[a] = o[l], o[l] = h;
              }
              return o;
            }, r.choose = function(o) {
              return o[Math.floor(r.random() * o.length)];
            }, r.isElement = function(o) {
              return typeof HTMLElement < "u" ? o instanceof HTMLElement : !!(o && o.nodeType && o.nodeName);
            }, r.isArray = function(o) {
              return Object.prototype.toString.call(o) === "[object Array]";
            }, r.isFunction = function(o) {
              return typeof o == "function";
            }, r.isPlainObject = function(o) {
              return typeof o == "object" && o.constructor === Object;
            }, r.isString = function(o) {
              return toString.call(o) === "[object String]";
            }, r.clamp = function(o, a, l) {
              return o < a ? a : o > l ? l : o;
            }, r.sign = function(o) {
              return o < 0 ? -1 : 1;
            }, r.now = function() {
              if (typeof window < "u" && window.performance) {
                if (window.performance.now)
                  return window.performance.now();
                if (window.performance.webkitNow)
                  return window.performance.webkitNow();
              }
              return Date.now ? Date.now() : /* @__PURE__ */ new Date() - r._nowStartTime;
            }, r.random = function(o, a) {
              return o = typeof o < "u" ? o : 0, a = typeof a < "u" ? a : 1, o + s() * (a - o);
            };
            var s = function() {
              return r._seed = (r._seed * 9301 + 49297) % 233280, r._seed / 233280;
            };
            r.colorToNumber = function(o) {
              return o = o.replace("#", ""), o.length == 3 && (o = o.charAt(0) + o.charAt(0) + o.charAt(1) + o.charAt(1) + o.charAt(2) + o.charAt(2)), parseInt(o, 16);
            }, r.logLevel = 1, r.log = function() {
              console && r.logLevel > 0 && r.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.info = function() {
              console && r.logLevel > 0 && r.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.warn = function() {
              console && r.logLevel > 0 && r.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.warnOnce = function() {
              var o = Array.prototype.slice.call(arguments).join(" ");
              r._warnedOnce[o] || (r.warn(o), r._warnedOnce[o] = !0);
            }, r.deprecated = function(o, a, l) {
              o[a] = r.chain(function() {
                r.warnOnce("🔅 deprecated 🔅", l);
              }, o[a]);
            }, r.nextId = function() {
              return r._nextId++;
            }, r.indexOf = function(o, a) {
              if (o.indexOf)
                return o.indexOf(a);
              for (var l = 0; l < o.length; l++)
                if (o[l] === a)
                  return l;
              return -1;
            }, r.map = function(o, a) {
              if (o.map)
                return o.map(a);
              for (var l = [], h = 0; h < o.length; h += 1)
                l.push(a(o[h]));
              return l;
            }, r.topologicalSort = function(o) {
              var a = [], l = [], h = [];
              for (var c in o)
                !l[c] && !h[c] && r._topologicalSort(c, l, h, o, a);
              return a;
            }, r._topologicalSort = function(o, a, l, h, c) {
              var p = h[o] || [];
              l[o] = !0;
              for (var f = 0; f < p.length; f += 1) {
                var u = p[f];
                l[u] || a[u] || r._topologicalSort(u, a, l, h, c);
              }
              l[o] = !1, a[o] = !0, c.push(o);
            }, r.chain = function() {
              for (var o = [], a = 0; a < arguments.length; a += 1) {
                var l = arguments[a];
                l._chained ? o.push.apply(o, l._chained) : o.push(l);
              }
              var h = function() {
                for (var c, p = new Array(arguments.length), f = 0, u = arguments.length; f < u; f++)
                  p[f] = arguments[f];
                for (f = 0; f < o.length; f += 1) {
                  var m = o[f].apply(c, p);
                  typeof m < "u" && (c = m);
                }
                return c;
              };
              return h._chained = o, h;
            }, r.chainPathBefore = function(o, a, l) {
              return r.set(o, a, r.chain(
                l,
                r.get(o, a)
              ));
            }, r.chainPathAfter = function(o, a, l) {
              return r.set(o, a, r.chain(
                r.get(o, a),
                l
              ));
            }, r.setDecomp = function(o) {
              r._decomp = o;
            }, r.getDecomp = function() {
              var o = r._decomp;
              try {
                !o && typeof window < "u" && (o = window.decomp), !o && typeof ki < "u" && (o = ki.decomp);
              } catch {
                o = null;
              }
              return o;
            };
          }();
        },
        /* 1 */
        /***/
        function(e, i) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s) {
              var o = {
                min: { x: 0, y: 0 },
                max: { x: 0, y: 0 }
              };
              return s && r.update(o, s), o;
            }, r.update = function(s, o, a) {
              s.min.x = 1 / 0, s.max.x = -1 / 0, s.min.y = 1 / 0, s.max.y = -1 / 0;
              for (var l = 0; l < o.length; l++) {
                var h = o[l];
                h.x > s.max.x && (s.max.x = h.x), h.x < s.min.x && (s.min.x = h.x), h.y > s.max.y && (s.max.y = h.y), h.y < s.min.y && (s.min.y = h.y);
              }
              a && (a.x > 0 ? s.max.x += a.x : s.min.x += a.x, a.y > 0 ? s.max.y += a.y : s.min.y += a.y);
            }, r.contains = function(s, o) {
              return o.x >= s.min.x && o.x <= s.max.x && o.y >= s.min.y && o.y <= s.max.y;
            }, r.overlaps = function(s, o) {
              return s.min.x <= o.max.x && s.max.x >= o.min.x && s.max.y >= o.min.y && s.min.y <= o.max.y;
            }, r.translate = function(s, o) {
              s.min.x += o.x, s.max.x += o.x, s.min.y += o.y, s.max.y += o.y;
            }, r.shift = function(s, o) {
              var a = s.max.x - s.min.x, l = s.max.y - s.min.y;
              s.min.x = o.x, s.max.x = o.x + a, s.min.y = o.y, s.max.y = o.y + l;
            };
          }();
        },
        /* 2 */
        /***/
        function(e, i) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s, o) {
              return { x: s || 0, y: o || 0 };
            }, r.clone = function(s) {
              return { x: s.x, y: s.y };
            }, r.magnitude = function(s) {
              return Math.sqrt(s.x * s.x + s.y * s.y);
            }, r.magnitudeSquared = function(s) {
              return s.x * s.x + s.y * s.y;
            }, r.rotate = function(s, o, a) {
              var l = Math.cos(o), h = Math.sin(o);
              a || (a = {});
              var c = s.x * l - s.y * h;
              return a.y = s.x * h + s.y * l, a.x = c, a;
            }, r.rotateAbout = function(s, o, a, l) {
              var h = Math.cos(o), c = Math.sin(o);
              l || (l = {});
              var p = a.x + ((s.x - a.x) * h - (s.y - a.y) * c);
              return l.y = a.y + ((s.x - a.x) * c + (s.y - a.y) * h), l.x = p, l;
            }, r.normalise = function(s) {
              var o = r.magnitude(s);
              return o === 0 ? { x: 0, y: 0 } : { x: s.x / o, y: s.y / o };
            }, r.dot = function(s, o) {
              return s.x * o.x + s.y * o.y;
            }, r.cross = function(s, o) {
              return s.x * o.y - s.y * o.x;
            }, r.cross3 = function(s, o, a) {
              return (o.x - s.x) * (a.y - s.y) - (o.y - s.y) * (a.x - s.x);
            }, r.add = function(s, o, a) {
              return a || (a = {}), a.x = s.x + o.x, a.y = s.y + o.y, a;
            }, r.sub = function(s, o, a) {
              return a || (a = {}), a.x = s.x - o.x, a.y = s.y - o.y, a;
            }, r.mult = function(s, o) {
              return { x: s.x * o, y: s.y * o };
            }, r.div = function(s, o) {
              return { x: s.x / o, y: s.y / o };
            }, r.perp = function(s, o) {
              return o = o === !0 ? -1 : 1, { x: o * -s.y, y: o * s.x };
            }, r.neg = function(s) {
              return { x: -s.x, y: -s.y };
            }, r.angle = function(s, o) {
              return Math.atan2(o.y - s.y, o.x - s.x);
            }, r._temp = [
              r.create(),
              r.create(),
              r.create(),
              r.create(),
              r.create(),
              r.create()
            ];
          }();
        },
        /* 3 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(0);
          (function() {
            s.create = function(l, h) {
              for (var c = [], p = 0; p < l.length; p++) {
                var f = l[p], u = {
                  x: f.x,
                  y: f.y,
                  index: p,
                  body: h,
                  isInternal: !1
                };
                c.push(u);
              }
              return c;
            }, s.fromPath = function(l, h) {
              var c = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, p = [];
              return l.replace(c, function(f, u, m) {
                p.push({ x: parseFloat(u), y: parseFloat(m) });
              }), s.create(p, h);
            }, s.centre = function(l) {
              for (var h = s.area(l, !0), c = { x: 0, y: 0 }, p, f, u, m = 0; m < l.length; m++)
                u = (m + 1) % l.length, p = o.cross(l[m], l[u]), f = o.mult(o.add(l[m], l[u]), p), c = o.add(c, f);
              return o.div(c, 6 * h);
            }, s.mean = function(l) {
              for (var h = { x: 0, y: 0 }, c = 0; c < l.length; c++)
                h.x += l[c].x, h.y += l[c].y;
              return o.div(h, l.length);
            }, s.area = function(l, h) {
              for (var c = 0, p = l.length - 1, f = 0; f < l.length; f++)
                c += (l[p].x - l[f].x) * (l[p].y + l[f].y), p = f;
              return h ? c / 2 : Math.abs(c) / 2;
            }, s.inertia = function(l, h) {
              for (var c = 0, p = 0, f = l, u, m, g = 0; g < f.length; g++)
                m = (g + 1) % f.length, u = Math.abs(o.cross(f[m], f[g])), c += u * (o.dot(f[m], f[m]) + o.dot(f[m], f[g]) + o.dot(f[g], f[g])), p += u;
              return h / 6 * (c / p);
            }, s.translate = function(l, h, c) {
              c = typeof c < "u" ? c : 1;
              var p = l.length, f = h.x * c, u = h.y * c, m;
              for (m = 0; m < p; m++)
                l[m].x += f, l[m].y += u;
              return l;
            }, s.rotate = function(l, h, c) {
              if (h !== 0) {
                var p = Math.cos(h), f = Math.sin(h), u = c.x, m = c.y, g = l.length, y, b, T, C;
                for (C = 0; C < g; C++)
                  y = l[C], b = y.x - u, T = y.y - m, y.x = u + (b * p - T * f), y.y = m + (b * f + T * p);
                return l;
              }
            }, s.contains = function(l, h) {
              for (var c = h.x, p = h.y, f = l.length, u = l[f - 1], m, g = 0; g < f; g++) {
                if (m = l[g], (c - u.x) * (m.y - u.y) + (p - u.y) * (u.x - m.x) > 0)
                  return !1;
                u = m;
              }
              return !0;
            }, s.scale = function(l, h, c, p) {
              if (h === 1 && c === 1)
                return l;
              p = p || s.centre(l);
              for (var f, u, m = 0; m < l.length; m++)
                f = l[m], u = o.sub(f, p), l[m].x = p.x + u.x * h, l[m].y = p.y + u.y * c;
              return l;
            }, s.chamfer = function(l, h, c, p, f) {
              typeof h == "number" ? h = [h] : h = h || [8], c = typeof c < "u" ? c : -1, p = p || 2, f = f || 14;
              for (var u = [], m = 0; m < l.length; m++) {
                var g = l[m - 1 >= 0 ? m - 1 : l.length - 1], y = l[m], b = l[(m + 1) % l.length], T = h[m < h.length ? m : h.length - 1];
                if (T === 0) {
                  u.push(y);
                  continue;
                }
                var C = o.normalise({
                  x: y.y - g.y,
                  y: g.x - y.x
                }), P = o.normalise({
                  x: b.y - y.y,
                  y: y.x - b.x
                }), S = Math.sqrt(2 * Math.pow(T, 2)), I = o.mult(a.clone(C), T), w = o.normalise(o.mult(o.add(C, P), 0.5)), _ = o.sub(y, o.mult(w, S)), x = c;
                c === -1 && (x = Math.pow(T, 0.32) * 1.75), x = a.clamp(x, p, f), x % 2 === 1 && (x += 1);
                for (var A = Math.acos(o.dot(C, P)), R = A / x, M = 0; M < x; M++)
                  u.push(o.add(o.rotate(I, R * M), _));
              }
              return u;
            }, s.clockwiseSort = function(l) {
              var h = s.mean(l);
              return l.sort(function(c, p) {
                return o.angle(h, c) - o.angle(h, p);
              }), l;
            }, s.isConvex = function(l) {
              var h = 0, c = l.length, p, f, u, m;
              if (c < 3)
                return null;
              for (p = 0; p < c; p++)
                if (f = (p + 1) % c, u = (p + 2) % c, m = (l[f].x - l[p].x) * (l[u].y - l[f].y), m -= (l[f].y - l[p].y) * (l[u].x - l[f].x), m < 0 ? h |= 1 : m > 0 && (h |= 2), h === 3)
                  return !1;
              return h !== 0 ? !0 : null;
            }, s.hull = function(l) {
              var h = [], c = [], p, f;
              for (l = l.slice(0), l.sort(function(u, m) {
                var g = u.x - m.x;
                return g !== 0 ? g : u.y - m.y;
              }), f = 0; f < l.length; f += 1) {
                for (p = l[f]; c.length >= 2 && o.cross3(c[c.length - 2], c[c.length - 1], p) <= 0; )
                  c.pop();
                c.push(p);
              }
              for (f = l.length - 1; f >= 0; f -= 1) {
                for (p = l[f]; h.length >= 2 && o.cross3(h[h.length - 2], h[h.length - 1], p) <= 0; )
                  h.pop();
                h.push(p);
              }
              return h.pop(), c.pop(), h.concat(c);
            };
          })();
        },
        /* 4 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(2), l = r(7), h = r(0), c = r(1), p = r(11);
          (function() {
            s._timeCorrection = !0, s._inertiaScale = 4, s._nextCollidingGroupId = 1, s._nextNonCollidingGroupId = -1, s._nextCategory = 1, s._baseDelta = 1e3 / 60, s.create = function(u) {
              var m = {
                id: h.nextId(),
                type: "body",
                label: "Body",
                parts: [],
                plugin: {},
                angle: 0,
                vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                position: { x: 0, y: 0 },
                force: { x: 0, y: 0 },
                torque: 0,
                positionImpulse: { x: 0, y: 0 },
                constraintImpulse: { x: 0, y: 0, angle: 0 },
                totalContacts: 0,
                speed: 0,
                angularSpeed: 0,
                velocity: { x: 0, y: 0 },
                angularVelocity: 0,
                isSensor: !1,
                isStatic: !1,
                isSleeping: !1,
                motion: 0,
                sleepThreshold: 60,
                density: 1e-3,
                restitution: 0,
                friction: 0.1,
                frictionStatic: 0.5,
                frictionAir: 0.01,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                },
                slop: 0.05,
                timeScale: 1,
                render: {
                  visible: !0,
                  opacity: 1,
                  strokeStyle: null,
                  fillStyle: null,
                  lineWidth: null,
                  sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                  }
                },
                events: null,
                bounds: null,
                chamfer: null,
                circleRadius: 0,
                positionPrev: null,
                anglePrev: 0,
                parent: null,
                axes: null,
                area: 0,
                mass: 0,
                inertia: 0,
                deltaTime: 16.666666666666668,
                _original: null
              }, g = h.extend(m, u);
              return f(g, u), g;
            }, s.nextGroup = function(u) {
              return u ? s._nextNonCollidingGroupId-- : s._nextCollidingGroupId++;
            }, s.nextCategory = function() {
              return s._nextCategory = s._nextCategory << 1, s._nextCategory;
            };
            var f = function(u, m) {
              m = m || {}, s.set(u, {
                bounds: u.bounds || c.create(u.vertices),
                positionPrev: u.positionPrev || a.clone(u.position),
                anglePrev: u.anglePrev || u.angle,
                vertices: u.vertices,
                parts: u.parts || [u],
                isStatic: u.isStatic,
                isSleeping: u.isSleeping,
                parent: u.parent || u
              }), o.rotate(u.vertices, u.angle, u.position), p.rotate(u.axes, u.angle), c.update(u.bounds, u.vertices, u.velocity), s.set(u, {
                axes: m.axes || u.axes,
                area: m.area || u.area,
                mass: m.mass || u.mass,
                inertia: m.inertia || u.inertia
              });
              var g = u.isStatic ? "#14151f" : h.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), y = u.isStatic ? "#555" : "#ccc", b = u.isStatic && u.render.fillStyle === null ? 1 : 0;
              u.render.fillStyle = u.render.fillStyle || g, u.render.strokeStyle = u.render.strokeStyle || y, u.render.lineWidth = u.render.lineWidth || b, u.render.sprite.xOffset += -(u.bounds.min.x - u.position.x) / (u.bounds.max.x - u.bounds.min.x), u.render.sprite.yOffset += -(u.bounds.min.y - u.position.y) / (u.bounds.max.y - u.bounds.min.y);
            };
            s.set = function(u, m, g) {
              var y;
              typeof m == "string" && (y = m, m = {}, m[y] = g);
              for (y in m)
                if (Object.prototype.hasOwnProperty.call(m, y))
                  switch (g = m[y], y) {
                    case "isStatic":
                      s.setStatic(u, g);
                      break;
                    case "isSleeping":
                      l.set(u, g);
                      break;
                    case "mass":
                      s.setMass(u, g);
                      break;
                    case "density":
                      s.setDensity(u, g);
                      break;
                    case "inertia":
                      s.setInertia(u, g);
                      break;
                    case "vertices":
                      s.setVertices(u, g);
                      break;
                    case "position":
                      s.setPosition(u, g);
                      break;
                    case "angle":
                      s.setAngle(u, g);
                      break;
                    case "velocity":
                      s.setVelocity(u, g);
                      break;
                    case "angularVelocity":
                      s.setAngularVelocity(u, g);
                      break;
                    case "speed":
                      s.setSpeed(u, g);
                      break;
                    case "angularSpeed":
                      s.setAngularSpeed(u, g);
                      break;
                    case "parts":
                      s.setParts(u, g);
                      break;
                    case "centre":
                      s.setCentre(u, g);
                      break;
                    default:
                      u[y] = g;
                  }
            }, s.setStatic = function(u, m) {
              for (var g = 0; g < u.parts.length; g++) {
                var y = u.parts[g];
                m ? (y.isStatic || (y._original = {
                  restitution: y.restitution,
                  friction: y.friction,
                  mass: y.mass,
                  inertia: y.inertia,
                  density: y.density,
                  inverseMass: y.inverseMass,
                  inverseInertia: y.inverseInertia
                }), y.restitution = 0, y.friction = 1, y.mass = y.inertia = y.density = 1 / 0, y.inverseMass = y.inverseInertia = 0, y.positionPrev.x = y.position.x, y.positionPrev.y = y.position.y, y.anglePrev = y.angle, y.angularVelocity = 0, y.speed = 0, y.angularSpeed = 0, y.motion = 0) : y._original && (y.restitution = y._original.restitution, y.friction = y._original.friction, y.mass = y._original.mass, y.inertia = y._original.inertia, y.density = y._original.density, y.inverseMass = y._original.inverseMass, y.inverseInertia = y._original.inverseInertia, y._original = null), y.isStatic = m;
              }
            }, s.setMass = function(u, m) {
              var g = u.inertia / (u.mass / 6);
              u.inertia = g * (m / 6), u.inverseInertia = 1 / u.inertia, u.mass = m, u.inverseMass = 1 / u.mass, u.density = u.mass / u.area;
            }, s.setDensity = function(u, m) {
              s.setMass(u, m * u.area), u.density = m;
            }, s.setInertia = function(u, m) {
              u.inertia = m, u.inverseInertia = 1 / u.inertia;
            }, s.setVertices = function(u, m) {
              m[0].body === u ? u.vertices = m : u.vertices = o.create(m, u), u.axes = p.fromVertices(u.vertices), u.area = o.area(u.vertices), s.setMass(u, u.density * u.area);
              var g = o.centre(u.vertices);
              o.translate(u.vertices, g, -1), s.setInertia(u, s._inertiaScale * o.inertia(u.vertices, u.mass)), o.translate(u.vertices, u.position), c.update(u.bounds, u.vertices, u.velocity);
            }, s.setParts = function(u, m, g) {
              var y;
              for (m = m.slice(0), u.parts.length = 0, u.parts.push(u), u.parent = u, y = 0; y < m.length; y++) {
                var b = m[y];
                b !== u && (b.parent = u, u.parts.push(b));
              }
              if (u.parts.length !== 1) {
                if (g = typeof g < "u" ? g : !0, g) {
                  var T = [];
                  for (y = 0; y < m.length; y++)
                    T = T.concat(m[y].vertices);
                  o.clockwiseSort(T);
                  var C = o.hull(T), P = o.centre(C);
                  s.setVertices(u, C), o.translate(u.vertices, P);
                }
                var S = s._totalProperties(u);
                u.area = S.area, u.parent = u, u.position.x = S.centre.x, u.position.y = S.centre.y, u.positionPrev.x = S.centre.x, u.positionPrev.y = S.centre.y, s.setMass(u, S.mass), s.setInertia(u, S.inertia), s.setPosition(u, S.centre);
              }
            }, s.setCentre = function(u, m, g) {
              g ? (u.positionPrev.x += m.x, u.positionPrev.y += m.y, u.position.x += m.x, u.position.y += m.y) : (u.positionPrev.x = m.x - (u.position.x - u.positionPrev.x), u.positionPrev.y = m.y - (u.position.y - u.positionPrev.y), u.position.x = m.x, u.position.y = m.y);
            }, s.setPosition = function(u, m, g) {
              var y = a.sub(m, u.position);
              g ? (u.positionPrev.x = u.position.x, u.positionPrev.y = u.position.y, u.velocity.x = y.x, u.velocity.y = y.y, u.speed = a.magnitude(y)) : (u.positionPrev.x += y.x, u.positionPrev.y += y.y);
              for (var b = 0; b < u.parts.length; b++) {
                var T = u.parts[b];
                T.position.x += y.x, T.position.y += y.y, o.translate(T.vertices, y), c.update(T.bounds, T.vertices, u.velocity);
              }
            }, s.setAngle = function(u, m, g) {
              var y = m - u.angle;
              g ? (u.anglePrev = u.angle, u.angularVelocity = y, u.angularSpeed = Math.abs(y)) : u.anglePrev += y;
              for (var b = 0; b < u.parts.length; b++) {
                var T = u.parts[b];
                T.angle += y, o.rotate(T.vertices, y, u.position), p.rotate(T.axes, y), c.update(T.bounds, T.vertices, u.velocity), b > 0 && a.rotateAbout(T.position, y, u.position, T.position);
              }
            }, s.setVelocity = function(u, m) {
              var g = u.deltaTime / s._baseDelta;
              u.positionPrev.x = u.position.x - m.x * g, u.positionPrev.y = u.position.y - m.y * g, u.velocity.x = (u.position.x - u.positionPrev.x) / g, u.velocity.y = (u.position.y - u.positionPrev.y) / g, u.speed = a.magnitude(u.velocity);
            }, s.getVelocity = function(u) {
              var m = s._baseDelta / u.deltaTime;
              return {
                x: (u.position.x - u.positionPrev.x) * m,
                y: (u.position.y - u.positionPrev.y) * m
              };
            }, s.getSpeed = function(u) {
              return a.magnitude(s.getVelocity(u));
            }, s.setSpeed = function(u, m) {
              s.setVelocity(u, a.mult(a.normalise(s.getVelocity(u)), m));
            }, s.setAngularVelocity = function(u, m) {
              var g = u.deltaTime / s._baseDelta;
              u.anglePrev = u.angle - m * g, u.angularVelocity = (u.angle - u.anglePrev) / g, u.angularSpeed = Math.abs(u.angularVelocity);
            }, s.getAngularVelocity = function(u) {
              return (u.angle - u.anglePrev) * s._baseDelta / u.deltaTime;
            }, s.getAngularSpeed = function(u) {
              return Math.abs(s.getAngularVelocity(u));
            }, s.setAngularSpeed = function(u, m) {
              s.setAngularVelocity(u, h.sign(s.getAngularVelocity(u)) * m);
            }, s.translate = function(u, m, g) {
              s.setPosition(u, a.add(u.position, m), g);
            }, s.rotate = function(u, m, g, y) {
              if (!g)
                s.setAngle(u, u.angle + m, y);
              else {
                var b = Math.cos(m), T = Math.sin(m), C = u.position.x - g.x, P = u.position.y - g.y;
                s.setPosition(u, {
                  x: g.x + (C * b - P * T),
                  y: g.y + (C * T + P * b)
                }, y), s.setAngle(u, u.angle + m, y);
              }
            }, s.scale = function(u, m, g, y) {
              var b = 0, T = 0;
              y = y || u.position;
              for (var C = 0; C < u.parts.length; C++) {
                var P = u.parts[C];
                o.scale(P.vertices, m, g, y), P.axes = p.fromVertices(P.vertices), P.area = o.area(P.vertices), s.setMass(P, u.density * P.area), o.translate(P.vertices, { x: -P.position.x, y: -P.position.y }), s.setInertia(P, s._inertiaScale * o.inertia(P.vertices, P.mass)), o.translate(P.vertices, { x: P.position.x, y: P.position.y }), C > 0 && (b += P.area, T += P.inertia), P.position.x = y.x + (P.position.x - y.x) * m, P.position.y = y.y + (P.position.y - y.y) * g, c.update(P.bounds, P.vertices, u.velocity);
              }
              u.parts.length > 1 && (u.area = b, u.isStatic || (s.setMass(u, u.density * b), s.setInertia(u, T))), u.circleRadius && (m === g ? u.circleRadius *= m : u.circleRadius = null);
            }, s.update = function(u, m) {
              m = (typeof m < "u" ? m : 1e3 / 60) * u.timeScale;
              var g = m * m, y = s._timeCorrection ? m / (u.deltaTime || m) : 1, b = 1 - u.frictionAir * (m / h._baseDelta), T = (u.position.x - u.positionPrev.x) * y, C = (u.position.y - u.positionPrev.y) * y;
              u.velocity.x = T * b + u.force.x / u.mass * g, u.velocity.y = C * b + u.force.y / u.mass * g, u.positionPrev.x = u.position.x, u.positionPrev.y = u.position.y, u.position.x += u.velocity.x, u.position.y += u.velocity.y, u.deltaTime = m, u.angularVelocity = (u.angle - u.anglePrev) * b * y + u.torque / u.inertia * g, u.anglePrev = u.angle, u.angle += u.angularVelocity;
              for (var P = 0; P < u.parts.length; P++) {
                var S = u.parts[P];
                o.translate(S.vertices, u.velocity), P > 0 && (S.position.x += u.velocity.x, S.position.y += u.velocity.y), u.angularVelocity !== 0 && (o.rotate(S.vertices, u.angularVelocity, u.position), p.rotate(S.axes, u.angularVelocity), P > 0 && a.rotateAbout(S.position, u.angularVelocity, u.position, S.position)), c.update(S.bounds, S.vertices, u.velocity);
              }
            }, s.updateVelocities = function(u) {
              var m = s._baseDelta / u.deltaTime, g = u.velocity;
              g.x = (u.position.x - u.positionPrev.x) * m, g.y = (u.position.y - u.positionPrev.y) * m, u.speed = Math.sqrt(g.x * g.x + g.y * g.y), u.angularVelocity = (u.angle - u.anglePrev) * m, u.angularSpeed = Math.abs(u.angularVelocity);
            }, s.applyForce = function(u, m, g) {
              var y = { x: m.x - u.position.x, y: m.y - u.position.y };
              u.force.x += g.x, u.force.y += g.y, u.torque += y.x * g.y - y.y * g.x;
            }, s._totalProperties = function(u) {
              for (var m = {
                mass: 0,
                area: 0,
                inertia: 0,
                centre: { x: 0, y: 0 }
              }, g = u.parts.length === 1 ? 0 : 1; g < u.parts.length; g++) {
                var y = u.parts[g], b = y.mass !== 1 / 0 ? y.mass : 1;
                m.mass += b, m.area += y.area, m.inertia += y.inertia, m.centre = a.add(m.centre, a.mult(y.position, b));
              }
              return m.centre = a.div(m.centre, m.mass), m;
            };
          })();
        },
        /* 5 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s.on = function(a, l, h) {
              for (var c = l.split(" "), p, f = 0; f < c.length; f++)
                p = c[f], a.events = a.events || {}, a.events[p] = a.events[p] || [], a.events[p].push(h);
              return h;
            }, s.off = function(a, l, h) {
              if (!l) {
                a.events = {};
                return;
              }
              typeof l == "function" && (h = l, l = o.keys(a.events).join(" "));
              for (var c = l.split(" "), p = 0; p < c.length; p++) {
                var f = a.events[c[p]], u = [];
                if (h && f)
                  for (var m = 0; m < f.length; m++)
                    f[m] !== h && u.push(f[m]);
                a.events[c[p]] = u;
              }
            }, s.trigger = function(a, l, h) {
              var c, p, f, u, m = a.events;
              if (m && o.keys(m).length > 0) {
                h || (h = {}), c = l.split(" ");
                for (var g = 0; g < c.length; g++)
                  if (p = c[g], f = m[p], f) {
                    u = o.clone(h, !1), u.name = p, u.source = a;
                    for (var y = 0; y < f.length; y++)
                      f[y].apply(a, [u]);
                  }
              }
            };
          })();
        },
        /* 6 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(5), a = r(0), l = r(1), h = r(4);
          (function() {
            s.create = function(c) {
              return a.extend({
                id: a.nextId(),
                type: "composite",
                parent: null,
                isModified: !1,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {},
                cache: {
                  allBodies: null,
                  allConstraints: null,
                  allComposites: null
                }
              }, c);
            }, s.setModified = function(c, p, f, u) {
              if (c.isModified = p, p && c.cache && (c.cache.allBodies = null, c.cache.allConstraints = null, c.cache.allComposites = null), f && c.parent && s.setModified(c.parent, p, f, u), u)
                for (var m = 0; m < c.composites.length; m++) {
                  var g = c.composites[m];
                  s.setModified(g, p, f, u);
                }
            }, s.add = function(c, p) {
              var f = [].concat(p);
              o.trigger(c, "beforeAdd", { object: p });
              for (var u = 0; u < f.length; u++) {
                var m = f[u];
                switch (m.type) {
                  case "body":
                    if (m.parent !== m) {
                      a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                      break;
                    }
                    s.addBody(c, m);
                    break;
                  case "constraint":
                    s.addConstraint(c, m);
                    break;
                  case "composite":
                    s.addComposite(c, m);
                    break;
                  case "mouseConstraint":
                    s.addConstraint(c, m.constraint);
                    break;
                }
              }
              return o.trigger(c, "afterAdd", { object: p }), c;
            }, s.remove = function(c, p, f) {
              var u = [].concat(p);
              o.trigger(c, "beforeRemove", { object: p });
              for (var m = 0; m < u.length; m++) {
                var g = u[m];
                switch (g.type) {
                  case "body":
                    s.removeBody(c, g, f);
                    break;
                  case "constraint":
                    s.removeConstraint(c, g, f);
                    break;
                  case "composite":
                    s.removeComposite(c, g, f);
                    break;
                  case "mouseConstraint":
                    s.removeConstraint(c, g.constraint);
                    break;
                }
              }
              return o.trigger(c, "afterRemove", { object: p }), c;
            }, s.addComposite = function(c, p) {
              return c.composites.push(p), p.parent = c, s.setModified(c, !0, !0, !1), c;
            }, s.removeComposite = function(c, p, f) {
              var u = a.indexOf(c.composites, p);
              if (u !== -1) {
                var m = s.allBodies(p);
                s.removeCompositeAt(c, u);
                for (var g = 0; g < m.length; g++)
                  m[g].sleepCounter = 0;
              }
              if (f)
                for (var g = 0; g < c.composites.length; g++)
                  s.removeComposite(c.composites[g], p, !0);
              return c;
            }, s.removeCompositeAt = function(c, p) {
              return c.composites.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.addBody = function(c, p) {
              return c.bodies.push(p), s.setModified(c, !0, !0, !1), c;
            }, s.removeBody = function(c, p, f) {
              var u = a.indexOf(c.bodies, p);
              if (u !== -1 && (s.removeBodyAt(c, u), p.sleepCounter = 0), f)
                for (var m = 0; m < c.composites.length; m++)
                  s.removeBody(c.composites[m], p, !0);
              return c;
            }, s.removeBodyAt = function(c, p) {
              return c.bodies.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.addConstraint = function(c, p) {
              return c.constraints.push(p), s.setModified(c, !0, !0, !1), c;
            }, s.removeConstraint = function(c, p, f) {
              var u = a.indexOf(c.constraints, p);
              if (u !== -1 && s.removeConstraintAt(c, u), f)
                for (var m = 0; m < c.composites.length; m++)
                  s.removeConstraint(c.composites[m], p, !0);
              return c;
            }, s.removeConstraintAt = function(c, p) {
              return c.constraints.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.clear = function(c, p, f) {
              if (f)
                for (var u = 0; u < c.composites.length; u++)
                  s.clear(c.composites[u], p, !0);
              return p ? c.bodies = c.bodies.filter(function(m) {
                return m.isStatic;
              }) : c.bodies.length = 0, c.constraints.length = 0, c.composites.length = 0, s.setModified(c, !0, !0, !1), c;
            }, s.allBodies = function(c) {
              if (c.cache && c.cache.allBodies)
                return c.cache.allBodies;
              for (var p = [].concat(c.bodies), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allBodies(c.composites[f]));
              return c.cache && (c.cache.allBodies = p), p;
            }, s.allConstraints = function(c) {
              if (c.cache && c.cache.allConstraints)
                return c.cache.allConstraints;
              for (var p = [].concat(c.constraints), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allConstraints(c.composites[f]));
              return c.cache && (c.cache.allConstraints = p), p;
            }, s.allComposites = function(c) {
              if (c.cache && c.cache.allComposites)
                return c.cache.allComposites;
              for (var p = [].concat(c.composites), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allComposites(c.composites[f]));
              return c.cache && (c.cache.allComposites = p), p;
            }, s.get = function(c, p, f) {
              var u, m;
              switch (f) {
                case "body":
                  u = s.allBodies(c);
                  break;
                case "constraint":
                  u = s.allConstraints(c);
                  break;
                case "composite":
                  u = s.allComposites(c).concat(c);
                  break;
              }
              return u ? (m = u.filter(function(g) {
                return g.id.toString() === p.toString();
              }), m.length === 0 ? null : m[0]) : null;
            }, s.move = function(c, p, f) {
              return s.remove(c, p), s.add(f, p), c;
            }, s.rebase = function(c) {
              for (var p = s.allBodies(c).concat(s.allConstraints(c)).concat(s.allComposites(c)), f = 0; f < p.length; f++)
                p[f].id = a.nextId();
              return c;
            }, s.translate = function(c, p, f) {
              for (var u = f ? s.allBodies(c) : c.bodies, m = 0; m < u.length; m++)
                h.translate(u[m], p);
              return c;
            }, s.rotate = function(c, p, f, u) {
              for (var m = Math.cos(p), g = Math.sin(p), y = u ? s.allBodies(c) : c.bodies, b = 0; b < y.length; b++) {
                var T = y[b], C = T.position.x - f.x, P = T.position.y - f.y;
                h.setPosition(T, {
                  x: f.x + (C * m - P * g),
                  y: f.y + (C * g + P * m)
                }), h.rotate(T, p);
              }
              return c;
            }, s.scale = function(c, p, f, u, m) {
              for (var g = m ? s.allBodies(c) : c.bodies, y = 0; y < g.length; y++) {
                var b = g[y], T = b.position.x - u.x, C = b.position.y - u.y;
                h.setPosition(b, {
                  x: u.x + T * p,
                  y: u.y + C * f
                }), h.scale(b, p, f);
              }
              return c;
            }, s.bounds = function(c) {
              for (var p = s.allBodies(c), f = [], u = 0; u < p.length; u += 1) {
                var m = p[u];
                f.push(m.bounds.min, m.bounds.max);
              }
              return l.create(f);
            };
          })();
        },
        /* 7 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(4), a = r(5), l = r(0);
          (function() {
            s._motionWakeThreshold = 0.18, s._motionSleepThreshold = 0.08, s._minBias = 0.9, s.update = function(h, c) {
              for (var p = c / l._baseDelta, f = s._motionSleepThreshold, u = 0; u < h.length; u++) {
                var m = h[u], g = o.getSpeed(m), y = o.getAngularSpeed(m), b = g * g + y * y;
                if (m.force.x !== 0 || m.force.y !== 0) {
                  s.set(m, !1);
                  continue;
                }
                var T = Math.min(m.motion, b), C = Math.max(m.motion, b);
                m.motion = s._minBias * T + (1 - s._minBias) * C, m.sleepThreshold > 0 && m.motion < f ? (m.sleepCounter += 1, m.sleepCounter >= m.sleepThreshold / p && s.set(m, !0)) : m.sleepCounter > 0 && (m.sleepCounter -= 1);
              }
            }, s.afterCollisions = function(h) {
              for (var c = s._motionSleepThreshold, p = 0; p < h.length; p++) {
                var f = h[p];
                if (f.isActive) {
                  var u = f.collision, m = u.bodyA.parent, g = u.bodyB.parent;
                  if (!(m.isSleeping && g.isSleeping || m.isStatic || g.isStatic) && (m.isSleeping || g.isSleeping)) {
                    var y = m.isSleeping && !m.isStatic ? m : g, b = y === m ? g : m;
                    !y.isStatic && b.motion > c && s.set(y, !1);
                  }
                }
              }
            }, s.set = function(h, c) {
              var p = h.isSleeping;
              c ? (h.isSleeping = !0, h.sleepCounter = h.sleepThreshold, h.positionImpulse.x = 0, h.positionImpulse.y = 0, h.positionPrev.x = h.position.x, h.positionPrev.y = h.position.y, h.anglePrev = h.angle, h.speed = 0, h.angularSpeed = 0, h.motion = 0, p || a.trigger(h, "sleepStart")) : (h.isSleeping = !1, h.sleepCounter = 0, p && a.trigger(h, "sleepEnd"));
            };
          })();
        },
        /* 8 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(9);
          (function() {
            var l = [], h = {
              overlap: 0,
              axis: null
            }, c = {
              overlap: 0,
              axis: null
            };
            s.create = function(p, f) {
              return {
                pair: null,
                collided: !1,
                bodyA: p,
                bodyB: f,
                parentA: p.parent,
                parentB: f.parent,
                depth: 0,
                normal: { x: 0, y: 0 },
                tangent: { x: 0, y: 0 },
                penetration: { x: 0, y: 0 },
                supports: [null, null],
                supportCount: 0
              };
            }, s.collides = function(p, f, u) {
              if (s._overlapAxes(h, p.vertices, f.vertices, p.axes), h.overlap <= 0 || (s._overlapAxes(c, f.vertices, p.vertices, f.axes), c.overlap <= 0))
                return null;
              var m = u && u.table[a.id(p, f)], g;
              m ? g = m.collision : (g = s.create(p, f), g.collided = !0, g.bodyA = p.id < f.id ? p : f, g.bodyB = p.id < f.id ? f : p, g.parentA = g.bodyA.parent, g.parentB = g.bodyB.parent), p = g.bodyA, f = g.bodyB;
              var y;
              h.overlap < c.overlap ? y = h : y = c;
              var b = g.normal, T = g.tangent, C = g.penetration, P = g.supports, S = y.overlap, I = y.axis, w = I.x, _ = I.y, x = f.position.x - p.position.x, A = f.position.y - p.position.y;
              w * x + _ * A >= 0 && (w = -w, _ = -_), b.x = w, b.y = _, T.x = -_, T.y = w, C.x = w * S, C.y = _ * S, g.depth = S;
              var R = s._findSupports(p, f, b, 1), M = 0;
              if (o.contains(p.vertices, R[0]) && (P[M++] = R[0]), o.contains(p.vertices, R[1]) && (P[M++] = R[1]), M < 2) {
                var k = s._findSupports(f, p, b, -1);
                o.contains(f.vertices, k[0]) && (P[M++] = k[0]), M < 2 && o.contains(f.vertices, k[1]) && (P[M++] = k[1]);
              }
              return M === 0 && (P[M++] = R[0]), g.supportCount = M, g;
            }, s._overlapAxes = function(p, f, u, m) {
              var g = f.length, y = u.length, b = f[0].x, T = f[0].y, C = u[0].x, P = u[0].y, S = m.length, I = Number.MAX_VALUE, w = 0, _, x, A, R, M, k;
              for (M = 0; M < S; M++) {
                var B = m[M], O = B.x, U = B.y, z = b * O + T * U, Q = C * O + P * U, j = z, H = Q;
                for (k = 1; k < g; k += 1)
                  R = f[k].x * O + f[k].y * U, R > j ? j = R : R < z && (z = R);
                for (k = 1; k < y; k += 1)
                  R = u[k].x * O + u[k].y * U, R > H ? H = R : R < Q && (Q = R);
                if (x = j - Q, A = H - z, _ = x < A ? x : A, _ < I && (I = _, w = M, _ <= 0))
                  break;
              }
              p.axis = m[w], p.overlap = I;
            }, s._findSupports = function(p, f, u, m) {
              var g = f.vertices, y = g.length, b = p.position.x, T = p.position.y, C = u.x * m, P = u.y * m, S = g[0], I = S, w = C * (b - I.x) + P * (T - I.y), _, x, A;
              for (A = 1; A < y; A += 1)
                I = g[A], x = C * (b - I.x) + P * (T - I.y), x < w && (w = x, S = I);
              return _ = g[(y + S.index - 1) % y], w = C * (b - _.x) + P * (T - _.y), I = g[(S.index + 1) % y], C * (b - I.x) + P * (T - I.y) < w ? (l[0] = S, l[1] = I, l) : (l[0] = S, l[1] = _, l);
            };
          })();
        },
        /* 9 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(16);
          (function() {
            s.create = function(a, l) {
              var h = a.bodyA, c = a.bodyB, p = {
                id: s.id(h, c),
                bodyA: h,
                bodyB: c,
                collision: a,
                contacts: [o.create(), o.create()],
                contactCount: 0,
                separation: 0,
                isActive: !0,
                isSensor: h.isSensor || c.isSensor,
                timeCreated: l,
                timeUpdated: l,
                inverseMass: 0,
                friction: 0,
                frictionStatic: 0,
                restitution: 0,
                slop: 0
              };
              return s.update(p, a, l), p;
            }, s.update = function(a, l, h) {
              var c = l.supports, p = l.supportCount, f = a.contacts, u = l.parentA, m = l.parentB;
              a.isActive = !0, a.timeUpdated = h, a.collision = l, a.separation = l.depth, a.inverseMass = u.inverseMass + m.inverseMass, a.friction = u.friction < m.friction ? u.friction : m.friction, a.frictionStatic = u.frictionStatic > m.frictionStatic ? u.frictionStatic : m.frictionStatic, a.restitution = u.restitution > m.restitution ? u.restitution : m.restitution, a.slop = u.slop > m.slop ? u.slop : m.slop, a.contactCount = p, l.pair = a;
              var g = c[0], y = f[0], b = c[1], T = f[1];
              (T.vertex === g || y.vertex === b) && (f[1] = y, f[0] = y = T, T = f[1]), y.vertex = g, T.vertex = b;
            }, s.setActive = function(a, l, h) {
              l ? (a.isActive = !0, a.timeUpdated = h) : (a.isActive = !1, a.contactCount = 0);
            }, s.id = function(a, l) {
              return a.id < l.id ? a.id.toString(36) + ":" + l.id.toString(36) : l.id.toString(36) + ":" + a.id.toString(36);
            };
          })();
        },
        /* 10 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(2), l = r(7), h = r(1), c = r(11), p = r(0);
          (function() {
            s._warming = 0.4, s._torqueDampen = 1, s._minLength = 1e-6, s.create = function(f) {
              var u = f;
              u.bodyA && !u.pointA && (u.pointA = { x: 0, y: 0 }), u.bodyB && !u.pointB && (u.pointB = { x: 0, y: 0 });
              var m = u.bodyA ? a.add(u.bodyA.position, u.pointA) : u.pointA, g = u.bodyB ? a.add(u.bodyB.position, u.pointB) : u.pointB, y = a.magnitude(a.sub(m, g));
              u.length = typeof u.length < "u" ? u.length : y, u.id = u.id || p.nextId(), u.label = u.label || "Constraint", u.type = "constraint", u.stiffness = u.stiffness || (u.length > 0 ? 1 : 0.7), u.damping = u.damping || 0, u.angularStiffness = u.angularStiffness || 0, u.angleA = u.bodyA ? u.bodyA.angle : u.angleA, u.angleB = u.bodyB ? u.bodyB.angle : u.angleB, u.plugin = {};
              var b = {
                visible: !0,
                lineWidth: 2,
                strokeStyle: "#ffffff",
                type: "line",
                anchors: !0
              };
              return u.length === 0 && u.stiffness > 0.1 ? (b.type = "pin", b.anchors = !1) : u.stiffness < 0.9 && (b.type = "spring"), u.render = p.extend(b, u.render), u;
            }, s.preSolveAll = function(f) {
              for (var u = 0; u < f.length; u += 1) {
                var m = f[u], g = m.constraintImpulse;
                m.isStatic || g.x === 0 && g.y === 0 && g.angle === 0 || (m.position.x += g.x, m.position.y += g.y, m.angle += g.angle);
              }
            }, s.solveAll = function(f, u) {
              for (var m = p.clamp(u / p._baseDelta, 0, 1), g = 0; g < f.length; g += 1) {
                var y = f[g], b = !y.bodyA || y.bodyA && y.bodyA.isStatic, T = !y.bodyB || y.bodyB && y.bodyB.isStatic;
                (b || T) && s.solve(f[g], m);
              }
              for (g = 0; g < f.length; g += 1)
                y = f[g], b = !y.bodyA || y.bodyA && y.bodyA.isStatic, T = !y.bodyB || y.bodyB && y.bodyB.isStatic, !b && !T && s.solve(f[g], m);
            }, s.solve = function(f, u) {
              var m = f.bodyA, g = f.bodyB, y = f.pointA, b = f.pointB;
              if (!(!m && !g)) {
                m && !m.isStatic && (a.rotate(y, m.angle - f.angleA, y), f.angleA = m.angle), g && !g.isStatic && (a.rotate(b, g.angle - f.angleB, b), f.angleB = g.angle);
                var T = y, C = b;
                if (m && (T = a.add(m.position, y)), g && (C = a.add(g.position, b)), !(!T || !C)) {
                  var P = a.sub(T, C), S = a.magnitude(P);
                  S < s._minLength && (S = s._minLength);
                  var I = (S - f.length) / S, w = f.stiffness >= 1 || f.length === 0, _ = w ? f.stiffness * u : f.stiffness * u * u, x = f.damping * u, A = a.mult(P, I * _), R = (m ? m.inverseMass : 0) + (g ? g.inverseMass : 0), M = (m ? m.inverseInertia : 0) + (g ? g.inverseInertia : 0), k = R + M, B, O, U, z, Q;
                  if (x > 0) {
                    var j = a.create();
                    U = a.div(P, S), Q = a.sub(
                      g && a.sub(g.position, g.positionPrev) || j,
                      m && a.sub(m.position, m.positionPrev) || j
                    ), z = a.dot(U, Q);
                  }
                  m && !m.isStatic && (O = m.inverseMass / R, m.constraintImpulse.x -= A.x * O, m.constraintImpulse.y -= A.y * O, m.position.x -= A.x * O, m.position.y -= A.y * O, x > 0 && (m.positionPrev.x -= x * U.x * z * O, m.positionPrev.y -= x * U.y * z * O), B = a.cross(y, A) / k * s._torqueDampen * m.inverseInertia * (1 - f.angularStiffness), m.constraintImpulse.angle -= B, m.angle -= B), g && !g.isStatic && (O = g.inverseMass / R, g.constraintImpulse.x += A.x * O, g.constraintImpulse.y += A.y * O, g.position.x += A.x * O, g.position.y += A.y * O, x > 0 && (g.positionPrev.x += x * U.x * z * O, g.positionPrev.y += x * U.y * z * O), B = a.cross(b, A) / k * s._torqueDampen * g.inverseInertia * (1 - f.angularStiffness), g.constraintImpulse.angle += B, g.angle += B);
                }
              }
            }, s.postSolveAll = function(f) {
              for (var u = 0; u < f.length; u++) {
                var m = f[u], g = m.constraintImpulse;
                if (!(m.isStatic || g.x === 0 && g.y === 0 && g.angle === 0)) {
                  l.set(m, !1);
                  for (var y = 0; y < m.parts.length; y++) {
                    var b = m.parts[y];
                    o.translate(b.vertices, g), y > 0 && (b.position.x += g.x, b.position.y += g.y), g.angle !== 0 && (o.rotate(b.vertices, g.angle, m.position), c.rotate(b.axes, g.angle), y > 0 && a.rotateAbout(b.position, g.angle, m.position, b.position)), h.update(b.bounds, b.vertices, m.velocity);
                  }
                  g.angle *= s._warming, g.x *= s._warming, g.y *= s._warming;
                }
              }
            }, s.pointAWorld = function(f) {
              return {
                x: (f.bodyA ? f.bodyA.position.x : 0) + (f.pointA ? f.pointA.x : 0),
                y: (f.bodyA ? f.bodyA.position.y : 0) + (f.pointA ? f.pointA.y : 0)
              };
            }, s.pointBWorld = function(f) {
              return {
                x: (f.bodyB ? f.bodyB.position.x : 0) + (f.pointB ? f.pointB.x : 0),
                y: (f.bodyB ? f.bodyB.position.y : 0) + (f.pointB ? f.pointB.y : 0)
              };
            }, s.currentLength = function(f) {
              var u = (f.bodyA ? f.bodyA.position.x : 0) + (f.pointA ? f.pointA.x : 0), m = (f.bodyA ? f.bodyA.position.y : 0) + (f.pointA ? f.pointA.y : 0), g = (f.bodyB ? f.bodyB.position.x : 0) + (f.pointB ? f.pointB.x : 0), y = (f.bodyB ? f.bodyB.position.y : 0) + (f.pointB ? f.pointB.y : 0), b = u - g, T = m - y;
              return Math.sqrt(b * b + T * T);
            };
          })();
        },
        /* 11 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(0);
          (function() {
            s.fromVertices = function(l) {
              for (var h = {}, c = 0; c < l.length; c++) {
                var p = (c + 1) % l.length, f = o.normalise({
                  x: l[p].y - l[c].y,
                  y: l[c].x - l[p].x
                }), u = f.y === 0 ? 1 / 0 : f.x / f.y;
                u = u.toFixed(3).toString(), h[u] = f;
              }
              return a.values(h);
            }, s.rotate = function(l, h) {
              if (h !== 0)
                for (var c = Math.cos(h), p = Math.sin(h), f = 0; f < l.length; f++) {
                  var u = l[f], m;
                  m = u.x * c - u.y * p, u.y = u.x * p + u.y * c, u.x = m;
                }
            };
          })();
        },
        /* 12 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(0), l = r(4), h = r(1), c = r(2);
          (function() {
            s.rectangle = function(p, f, u, m, g) {
              g = g || {};
              var y = {
                label: "Rectangle Body",
                position: { x: p, y: f },
                vertices: o.fromPath("L 0 0 L " + u + " 0 L " + u + " " + m + " L 0 " + m)
              };
              if (g.chamfer) {
                var b = g.chamfer;
                y.vertices = o.chamfer(
                  y.vertices,
                  b.radius,
                  b.quality,
                  b.qualityMin,
                  b.qualityMax
                ), delete g.chamfer;
              }
              return l.create(a.extend({}, y, g));
            }, s.trapezoid = function(p, f, u, m, g, y) {
              y = y || {}, g >= 1 && a.warn("Bodies.trapezoid: slope parameter must be < 1."), g *= 0.5;
              var b = (1 - g * 2) * u, T = u * g, C = T + b, P = C + T, S;
              g < 0.5 ? S = "L 0 0 L " + T + " " + -m + " L " + C + " " + -m + " L " + P + " 0" : S = "L 0 0 L " + C + " " + -m + " L " + P + " 0";
              var I = {
                label: "Trapezoid Body",
                position: { x: p, y: f },
                vertices: o.fromPath(S)
              };
              if (y.chamfer) {
                var w = y.chamfer;
                I.vertices = o.chamfer(
                  I.vertices,
                  w.radius,
                  w.quality,
                  w.qualityMin,
                  w.qualityMax
                ), delete y.chamfer;
              }
              return l.create(a.extend({}, I, y));
            }, s.circle = function(p, f, u, m, g) {
              m = m || {};
              var y = {
                label: "Circle Body",
                circleRadius: u
              };
              g = g || 25;
              var b = Math.ceil(Math.max(10, Math.min(g, u)));
              return b % 2 === 1 && (b += 1), s.polygon(p, f, b, u, a.extend({}, y, m));
            }, s.polygon = function(p, f, u, m, g) {
              if (g = g || {}, u < 3)
                return s.circle(p, f, m, g);
              for (var y = 2 * Math.PI / u, b = "", T = y * 0.5, C = 0; C < u; C += 1) {
                var P = T + C * y, S = Math.cos(P) * m, I = Math.sin(P) * m;
                b += "L " + S.toFixed(3) + " " + I.toFixed(3) + " ";
              }
              var w = {
                label: "Polygon Body",
                position: { x: p, y: f },
                vertices: o.fromPath(b)
              };
              if (g.chamfer) {
                var _ = g.chamfer;
                w.vertices = o.chamfer(
                  w.vertices,
                  _.radius,
                  _.quality,
                  _.qualityMin,
                  _.qualityMax
                ), delete g.chamfer;
              }
              return l.create(a.extend({}, w, g));
            }, s.fromVertices = function(p, f, u, m, g, y, b, T) {
              var C = a.getDecomp(), P, S, I, w, _, x, A, R, M, k, B;
              for (P = !!(C && C.quickDecomp), m = m || {}, I = [], g = typeof g < "u" ? g : !1, y = typeof y < "u" ? y : 0.01, b = typeof b < "u" ? b : 10, T = typeof T < "u" ? T : 0.01, a.isArray(u[0]) || (u = [u]), k = 0; k < u.length; k += 1)
                if (x = u[k], w = o.isConvex(x), _ = !w, _ && !P && a.warnOnce(
                  "Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."
                ), w || !P)
                  w ? x = o.clockwiseSort(x) : x = o.hull(x), I.push({
                    position: { x: p, y: f },
                    vertices: x
                  });
                else {
                  var O = x.map(function(rt) {
                    return [rt.x, rt.y];
                  });
                  C.makeCCW(O), y !== !1 && C.removeCollinearPoints(O, y), T !== !1 && C.removeDuplicatePoints && C.removeDuplicatePoints(O, T);
                  var U = C.quickDecomp(O);
                  for (A = 0; A < U.length; A++) {
                    var z = U[A], Q = z.map(function(rt) {
                      return {
                        x: rt[0],
                        y: rt[1]
                      };
                    });
                    b > 0 && o.area(Q) < b || I.push({
                      position: o.centre(Q),
                      vertices: Q
                    });
                  }
                }
              for (A = 0; A < I.length; A++)
                I[A] = l.create(a.extend(I[A], m));
              if (g) {
                var j = 5;
                for (A = 0; A < I.length; A++) {
                  var H = I[A];
                  for (R = A + 1; R < I.length; R++) {
                    var _t = I[R];
                    if (h.overlaps(H.bounds, _t.bounds)) {
                      var J = H.vertices, $ = _t.vertices;
                      for (M = 0; M < H.vertices.length; M++)
                        for (B = 0; B < _t.vertices.length; B++) {
                          var St = c.magnitudeSquared(c.sub(J[(M + 1) % J.length], $[B])), Ct = c.magnitudeSquared(c.sub(J[M], $[(B + 1) % $.length]));
                          St < j && Ct < j && (J[M].isInternal = !0, $[B].isInternal = !0);
                        }
                    }
                  }
                }
              }
              return I.length > 1 ? (S = l.create(a.extend({ parts: I.slice(0) }, m)), l.setPosition(S, { x: p, y: f }), S) : I[0];
            };
          })();
        },
        /* 13 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(0), a = r(8);
          (function() {
            s.create = function(l) {
              var h = {
                bodies: [],
                collisions: [],
                pairs: null
              };
              return o.extend(h, l);
            }, s.setBodies = function(l, h) {
              l.bodies = h.slice(0);
            }, s.clear = function(l) {
              l.bodies = [], l.collisions = [];
            }, s.collisions = function(l) {
              var h = l.pairs, c = l.bodies, p = c.length, f = s.canCollide, u = a.collides, m = l.collisions, g = 0, y, b;
              for (c.sort(s._compareBoundsX), y = 0; y < p; y++) {
                var T = c[y], C = T.bounds, P = T.bounds.max.x, S = T.bounds.max.y, I = T.bounds.min.y, w = T.isStatic || T.isSleeping, _ = T.parts.length, x = _ === 1;
                for (b = y + 1; b < p; b++) {
                  var A = c[b], R = A.bounds;
                  if (R.min.x > P)
                    break;
                  if (!(S < R.min.y || I > R.max.y) && !(w && (A.isStatic || A.isSleeping)) && f(T.collisionFilter, A.collisionFilter)) {
                    var M = A.parts.length;
                    if (x && M === 1) {
                      var k = u(T, A, h);
                      k && (m[g++] = k);
                    } else
                      for (var B = _ > 1 ? 1 : 0, O = M > 1 ? 1 : 0, U = B; U < _; U++)
                        for (var z = T.parts[U], C = z.bounds, Q = O; Q < M; Q++) {
                          var j = A.parts[Q], R = j.bounds;
                          if (!(C.min.x > R.max.x || C.max.x < R.min.x || C.max.y < R.min.y || C.min.y > R.max.y)) {
                            var k = u(z, j, h);
                            k && (m[g++] = k);
                          }
                        }
                  }
                }
              }
              return m.length !== g && (m.length = g), m;
            }, s.canCollide = function(l, h) {
              return l.group === h.group && l.group !== 0 ? l.group > 0 : (l.mask & h.category) !== 0 && (h.mask & l.category) !== 0;
            }, s._compareBoundsX = function(l, h) {
              return l.bounds.min.x - h.bounds.min.x;
            };
          })();
        },
        /* 14 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s.create = function(a) {
              var l = {};
              return a || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), l.element = a || document.body, l.absolute = { x: 0, y: 0 }, l.position = { x: 0, y: 0 }, l.mousedownPosition = { x: 0, y: 0 }, l.mouseupPosition = { x: 0, y: 0 }, l.offset = { x: 0, y: 0 }, l.scale = { x: 1, y: 1 }, l.wheelDelta = 0, l.button = -1, l.pixelRatio = parseInt(l.element.getAttribute("data-pixel-ratio"), 10) || 1, l.sourceEvents = {
                mousemove: null,
                mousedown: null,
                mouseup: null,
                mousewheel: null
              }, l.mousemove = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p && (l.button = 0, h.preventDefault()), l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.sourceEvents.mousemove = h;
              }, l.mousedown = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p ? (l.button = 0, h.preventDefault()) : l.button = h.button, l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.mousedownPosition.x = l.position.x, l.mousedownPosition.y = l.position.y, l.sourceEvents.mousedown = h;
              }, l.mouseup = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p && h.preventDefault(), l.button = -1, l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.mouseupPosition.x = l.position.x, l.mouseupPosition.y = l.position.y, l.sourceEvents.mouseup = h;
              }, l.mousewheel = function(h) {
                l.wheelDelta = Math.max(-1, Math.min(1, h.wheelDelta || -h.detail)), h.preventDefault(), l.sourceEvents.mousewheel = h;
              }, s.setElement(l, l.element), l;
            }, s.setElement = function(a, l) {
              a.element = l, l.addEventListener("mousemove", a.mousemove, { passive: !0 }), l.addEventListener("mousedown", a.mousedown, { passive: !0 }), l.addEventListener("mouseup", a.mouseup, { passive: !0 }), l.addEventListener("wheel", a.mousewheel, { passive: !1 }), l.addEventListener("touchmove", a.mousemove, { passive: !1 }), l.addEventListener("touchstart", a.mousedown, { passive: !1 }), l.addEventListener("touchend", a.mouseup, { passive: !1 });
            }, s.clearSourceEvents = function(a) {
              a.sourceEvents.mousemove = null, a.sourceEvents.mousedown = null, a.sourceEvents.mouseup = null, a.sourceEvents.mousewheel = null, a.wheelDelta = 0;
            }, s.setOffset = function(a, l) {
              a.offset.x = l.x, a.offset.y = l.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y;
            }, s.setScale = function(a, l) {
              a.scale.x = l.x, a.scale.y = l.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y;
            }, s._getRelativeMousePosition = function(a, l, h) {
              var c = l.getBoundingClientRect(), p = document.documentElement || document.body.parentNode || document.body, f = window.pageXOffset !== void 0 ? window.pageXOffset : p.scrollLeft, u = window.pageYOffset !== void 0 ? window.pageYOffset : p.scrollTop, m = a.changedTouches, g, y;
              return m ? (g = m[0].pageX - c.left - f, y = m[0].pageY - c.top - u) : (g = a.pageX - c.left - f, y = a.pageY - c.top - u), {
                x: g / (l.clientWidth / (l.width || l.clientWidth) * h),
                y: y / (l.clientHeight / (l.height || l.clientHeight) * h)
              };
            };
          })();
        },
        /* 15 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s._registry = {}, s.register = function(a) {
              if (s.isPlugin(a) || o.warn("Plugin.register:", s.toString(a), "does not implement all required fields."), a.name in s._registry) {
                var l = s._registry[a.name], h = s.versionParse(a.version).number, c = s.versionParse(l.version).number;
                h > c ? (o.warn("Plugin.register:", s.toString(l), "was upgraded to", s.toString(a)), s._registry[a.name] = a) : h < c ? o.warn("Plugin.register:", s.toString(l), "can not be downgraded to", s.toString(a)) : a !== l && o.warn("Plugin.register:", s.toString(a), "is already registered to different plugin object");
              } else
                s._registry[a.name] = a;
              return a;
            }, s.resolve = function(a) {
              return s._registry[s.dependencyParse(a).name];
            }, s.toString = function(a) {
              return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0");
            }, s.isPlugin = function(a) {
              return a && a.name && a.version && a.install;
            }, s.isUsed = function(a, l) {
              return a.used.indexOf(l) > -1;
            }, s.isFor = function(a, l) {
              var h = a.for && s.dependencyParse(a.for);
              return !a.for || l.name === h.name && s.versionSatisfies(l.version, h.range);
            }, s.use = function(a, l) {
              if (a.uses = (a.uses || []).concat(l || []), a.uses.length === 0) {
                o.warn("Plugin.use:", s.toString(a), "does not specify any dependencies to install.");
                return;
              }
              for (var h = s.dependencies(a), c = o.topologicalSort(h), p = [], f = 0; f < c.length; f += 1)
                if (c[f] !== a.name) {
                  var u = s.resolve(c[f]);
                  if (!u) {
                    p.push("❌ " + c[f]);
                    continue;
                  }
                  s.isUsed(a, u.name) || (s.isFor(u, a) || (o.warn("Plugin.use:", s.toString(u), "is for", u.for, "but installed on", s.toString(a) + "."), u._warned = !0), u.install ? u.install(a) : (o.warn("Plugin.use:", s.toString(u), "does not specify an install function."), u._warned = !0), u._warned ? (p.push("🔶 " + s.toString(u)), delete u._warned) : p.push("✅ " + s.toString(u)), a.used.push(u.name));
                }
              p.length > 0 && o.info(p.join("  "));
            }, s.dependencies = function(a, l) {
              var h = s.dependencyParse(a), c = h.name;
              if (l = l || {}, !(c in l)) {
                a = s.resolve(a) || a, l[c] = o.map(a.uses || [], function(f) {
                  s.isPlugin(f) && s.register(f);
                  var u = s.dependencyParse(f), m = s.resolve(f);
                  return m && !s.versionSatisfies(m.version, u.range) ? (o.warn(
                    "Plugin.dependencies:",
                    s.toString(m),
                    "does not satisfy",
                    s.toString(u),
                    "used by",
                    s.toString(h) + "."
                  ), m._warned = !0, a._warned = !0) : m || (o.warn(
                    "Plugin.dependencies:",
                    s.toString(f),
                    "used by",
                    s.toString(h),
                    "could not be resolved."
                  ), a._warned = !0), u.name;
                });
                for (var p = 0; p < l[c].length; p += 1)
                  s.dependencies(l[c][p], l);
                return l;
              }
            }, s.dependencyParse = function(a) {
              if (o.isString(a)) {
                var l = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                return l.test(a) || o.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."), {
                  name: a.split("@")[0],
                  range: a.split("@")[1] || "*"
                };
              }
              return {
                name: a.name,
                range: a.range || a.version
              };
            }, s.versionParse = function(a) {
              var l = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
              l.test(a) || o.warn("Plugin.versionParse:", a, "is not a valid version or range.");
              var h = l.exec(a), c = Number(h[4]), p = Number(h[5]), f = Number(h[6]);
              return {
                isRange: !!(h[1] || h[2]),
                version: h[3],
                range: a,
                operator: h[1] || h[2] || "",
                major: c,
                minor: p,
                patch: f,
                parts: [c, p, f],
                prerelease: h[7],
                number: c * 1e8 + p * 1e4 + f
              };
            }, s.versionSatisfies = function(a, l) {
              l = l || "*";
              var h = s.versionParse(l), c = s.versionParse(a);
              if (h.isRange) {
                if (h.operator === "*" || a === "*")
                  return !0;
                if (h.operator === ">")
                  return c.number > h.number;
                if (h.operator === ">=")
                  return c.number >= h.number;
                if (h.operator === "~")
                  return c.major === h.major && c.minor === h.minor && c.patch >= h.patch;
                if (h.operator === "^")
                  return h.major > 0 ? c.major === h.major && c.number >= h.number : h.minor > 0 ? c.minor === h.minor && c.patch >= h.patch : c.patch === h.patch;
              }
              return a === l || a === "*";
            };
          })();
        },
        /* 16 */
        /***/
        function(e, i) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s) {
              return {
                vertex: s,
                normalImpulse: 0,
                tangentImpulse: 0
              };
            };
          }();
        },
        /* 17 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(7), a = r(18), l = r(13), h = r(19), c = r(5), p = r(6), f = r(10), u = r(0), m = r(4);
          (function() {
            s._deltaMax = 1e3 / 60, s.create = function(g) {
              g = g || {};
              var y = {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: !1,
                events: [],
                plugin: {},
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 1e-3
                },
                timing: {
                  timestamp: 0,
                  timeScale: 1,
                  lastDelta: 0,
                  lastElapsed: 0,
                  lastUpdatesPerFrame: 0
                }
              }, b = u.extend(y, g);
              return b.world = g.world || p.create({ label: "World" }), b.pairs = g.pairs || h.create(), b.detector = g.detector || l.create(), b.detector.pairs = b.pairs, b.grid = { buckets: [] }, b.world.gravity = b.gravity, b.broadphase = b.grid, b.metrics = {}, b;
            }, s.update = function(g, y) {
              var b = u.now(), T = g.world, C = g.detector, P = g.pairs, S = g.timing, I = S.timestamp, w;
              y > s._deltaMax && u.warnOnce(
                "Matter.Engine.update: delta argument is recommended to be less than or equal to",
                s._deltaMax.toFixed(3),
                "ms."
              ), y = typeof y < "u" ? y : u._baseDelta, y *= S.timeScale, S.timestamp += y, S.lastDelta = y;
              var _ = {
                timestamp: S.timestamp,
                delta: y
              };
              c.trigger(g, "beforeUpdate", _);
              var x = p.allBodies(T), A = p.allConstraints(T);
              for (T.isModified && (l.setBodies(C, x), p.setModified(T, !1, !1, !0)), g.enableSleeping && o.update(x, y), s._bodiesApplyGravity(x, g.gravity), y > 0 && s._bodiesUpdate(x, y), c.trigger(g, "beforeSolve", _), f.preSolveAll(x), w = 0; w < g.constraintIterations; w++)
                f.solveAll(A, y);
              f.postSolveAll(x);
              var R = l.collisions(C);
              h.update(P, R, I), g.enableSleeping && o.afterCollisions(P.list), P.collisionStart.length > 0 && c.trigger(g, "collisionStart", {
                pairs: P.collisionStart,
                timestamp: S.timestamp,
                delta: y
              });
              var M = u.clamp(20 / g.positionIterations, 0, 1);
              for (a.preSolvePosition(P.list), w = 0; w < g.positionIterations; w++)
                a.solvePosition(P.list, y, M);
              for (a.postSolvePosition(x), f.preSolveAll(x), w = 0; w < g.constraintIterations; w++)
                f.solveAll(A, y);
              for (f.postSolveAll(x), a.preSolveVelocity(P.list), w = 0; w < g.velocityIterations; w++)
                a.solveVelocity(P.list, y);
              return s._bodiesUpdateVelocities(x), P.collisionActive.length > 0 && c.trigger(g, "collisionActive", {
                pairs: P.collisionActive,
                timestamp: S.timestamp,
                delta: y
              }), P.collisionEnd.length > 0 && c.trigger(g, "collisionEnd", {
                pairs: P.collisionEnd,
                timestamp: S.timestamp,
                delta: y
              }), s._bodiesClearForces(x), c.trigger(g, "afterUpdate", _), g.timing.lastElapsed = u.now() - b, g;
            }, s.merge = function(g, y) {
              if (u.extend(g, y), y.world) {
                g.world = y.world, s.clear(g);
                for (var b = p.allBodies(g.world), T = 0; T < b.length; T++) {
                  var C = b[T];
                  o.set(C, !1), C.id = u.nextId();
                }
              }
            }, s.clear = function(g) {
              h.clear(g.pairs), l.clear(g.detector);
            }, s._bodiesClearForces = function(g) {
              for (var y = g.length, b = 0; b < y; b++) {
                var T = g[b];
                T.force.x = 0, T.force.y = 0, T.torque = 0;
              }
            }, s._bodiesApplyGravity = function(g, y) {
              var b = typeof y.scale < "u" ? y.scale : 1e-3, T = g.length;
              if (!(y.x === 0 && y.y === 0 || b === 0))
                for (var C = 0; C < T; C++) {
                  var P = g[C];
                  P.isStatic || P.isSleeping || (P.force.y += P.mass * y.y * b, P.force.x += P.mass * y.x * b);
                }
            }, s._bodiesUpdate = function(g, y) {
              for (var b = g.length, T = 0; T < b; T++) {
                var C = g[T];
                C.isStatic || C.isSleeping || m.update(C, y);
              }
            }, s._bodiesUpdateVelocities = function(g) {
              for (var y = g.length, b = 0; b < y; b++)
                m.updateVelocities(g[b]);
            };
          })();
        },
        /* 18 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(0), l = r(1);
          (function() {
            s._restingThresh = 2, s._restingThreshTangent = Math.sqrt(6), s._positionDampen = 0.9, s._positionWarming = 0.8, s._frictionNormalMultiplier = 5, s._frictionMaxStatic = Number.MAX_VALUE, s.preSolvePosition = function(h) {
              var c, p, f, u = h.length;
              for (c = 0; c < u; c++)
                p = h[c], p.isActive && (f = p.contactCount, p.collision.parentA.totalContacts += f, p.collision.parentB.totalContacts += f);
            }, s.solvePosition = function(h, c, p) {
              var f, u, m, g, y, b, T, C, P = s._positionDampen * (p || 1), S = a.clamp(c / a._baseDelta, 0, 1), I = h.length;
              for (f = 0; f < I; f++)
                u = h[f], !(!u.isActive || u.isSensor) && (m = u.collision, g = m.parentA, y = m.parentB, b = m.normal, u.separation = m.depth + b.x * (y.positionImpulse.x - g.positionImpulse.x) + b.y * (y.positionImpulse.y - g.positionImpulse.y));
              for (f = 0; f < I; f++)
                u = h[f], !(!u.isActive || u.isSensor) && (m = u.collision, g = m.parentA, y = m.parentB, b = m.normal, C = u.separation - u.slop * S, (g.isStatic || y.isStatic) && (C *= 2), g.isStatic || g.isSleeping || (T = P / g.totalContacts, g.positionImpulse.x += b.x * C * T, g.positionImpulse.y += b.y * C * T), y.isStatic || y.isSleeping || (T = P / y.totalContacts, y.positionImpulse.x -= b.x * C * T, y.positionImpulse.y -= b.y * C * T));
            }, s.postSolvePosition = function(h) {
              for (var c = s._positionWarming, p = h.length, f = o.translate, u = l.update, m = 0; m < p; m++) {
                var g = h[m], y = g.positionImpulse, b = y.x, T = y.y, C = g.velocity;
                if (g.totalContacts = 0, b !== 0 || T !== 0) {
                  for (var P = 0; P < g.parts.length; P++) {
                    var S = g.parts[P];
                    f(S.vertices, y), u(S.bounds, S.vertices, C), S.position.x += b, S.position.y += T;
                  }
                  g.positionPrev.x += b, g.positionPrev.y += T, b * C.x + T * C.y < 0 ? (y.x = 0, y.y = 0) : (y.x *= c, y.y *= c);
                }
              }
            }, s.preSolveVelocity = function(h) {
              var c = h.length, p, f;
              for (p = 0; p < c; p++) {
                var u = h[p];
                if (!(!u.isActive || u.isSensor)) {
                  var m = u.contacts, g = u.contactCount, y = u.collision, b = y.parentA, T = y.parentB, C = y.normal, P = y.tangent;
                  for (f = 0; f < g; f++) {
                    var S = m[f], I = S.vertex, w = S.normalImpulse, _ = S.tangentImpulse;
                    if (w !== 0 || _ !== 0) {
                      var x = C.x * w + P.x * _, A = C.y * w + P.y * _;
                      b.isStatic || b.isSleeping || (b.positionPrev.x += x * b.inverseMass, b.positionPrev.y += A * b.inverseMass, b.anglePrev += b.inverseInertia * ((I.x - b.position.x) * A - (I.y - b.position.y) * x)), T.isStatic || T.isSleeping || (T.positionPrev.x -= x * T.inverseMass, T.positionPrev.y -= A * T.inverseMass, T.anglePrev -= T.inverseInertia * ((I.x - T.position.x) * A - (I.y - T.position.y) * x));
                    }
                  }
                }
              }
            }, s.solveVelocity = function(h, c) {
              var p = c / a._baseDelta, f = p * p, u = f * p, m = -s._restingThresh * p, g = s._restingThreshTangent, y = s._frictionNormalMultiplier * p, b = s._frictionMaxStatic, T = h.length, C, P, S, I;
              for (S = 0; S < T; S++) {
                var w = h[S];
                if (!(!w.isActive || w.isSensor)) {
                  var _ = w.collision, x = _.parentA, A = _.parentB, R = _.normal.x, M = _.normal.y, k = _.tangent.x, B = _.tangent.y, O = w.inverseMass, U = w.friction * w.frictionStatic * y, z = w.contacts, Q = w.contactCount, j = 1 / Q, H = x.position.x - x.positionPrev.x, _t = x.position.y - x.positionPrev.y, J = x.angle - x.anglePrev, $ = A.position.x - A.positionPrev.x, St = A.position.y - A.positionPrev.y, Ct = A.angle - A.anglePrev;
                  for (I = 0; I < Q; I++) {
                    var rt = z[I], Xt = rt.vertex, Pt = Xt.x - x.position.x, Ne = Xt.y - x.position.y, te = Xt.x - A.position.x, ee = Xt.y - A.position.y, It = H - Ne * J, fn = _t + Pt * J, Cn = $ - ee * Ct, Ue = St + te * Ct, ze = It - Cn, Ze = fn - Ue, je = R * ze + M * Ze, Re = k * ze + B * Ze, Pn = w.separation + je, qn = Math.min(Pn, 1);
                    qn = Pn < 0 ? 0 : qn;
                    var Ao = qn * U;
                    Re < -Ao || Re > Ao ? (P = Re > 0 ? Re : -Re, C = w.friction * (Re > 0 ? 1 : -1) * u, C < -P ? C = -P : C > P && (C = P)) : (C = Re, P = b);
                    var tr = Pt * M - Ne * R, er = te * M - ee * R, ns = j / (O + x.inverseInertia * tr * tr + A.inverseInertia * er * er), Nt = (1 + w.restitution) * je * ns;
                    if (C *= ns, je < m)
                      rt.normalImpulse = 0;
                    else {
                      var ae = rt.normalImpulse;
                      rt.normalImpulse += Nt, rt.normalImpulse > 0 && (rt.normalImpulse = 0), Nt = rt.normalImpulse - ae;
                    }
                    if (Re < -g || Re > g)
                      rt.tangentImpulse = 0;
                    else {
                      var nr = rt.tangentImpulse;
                      rt.tangentImpulse += C, rt.tangentImpulse < -P && (rt.tangentImpulse = -P), rt.tangentImpulse > P && (rt.tangentImpulse = P), C = rt.tangentImpulse - nr;
                    }
                    var gi = R * Nt + k * C, yi = M * Nt + B * C;
                    x.isStatic || x.isSleeping || (x.positionPrev.x += gi * x.inverseMass, x.positionPrev.y += yi * x.inverseMass, x.anglePrev += (Pt * yi - Ne * gi) * x.inverseInertia), A.isStatic || A.isSleeping || (A.positionPrev.x -= gi * A.inverseMass, A.positionPrev.y -= yi * A.inverseMass, A.anglePrev -= (te * yi - ee * gi) * A.inverseInertia);
                  }
                }
              }
            };
          })();
        },
        /* 19 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(9), a = r(0);
          (function() {
            s.create = function(l) {
              return a.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
              }, l);
            }, s.update = function(l, h, c) {
              var p = o.update, f = o.create, u = o.setActive, m = l.table, g = l.list, y = g.length, b = y, T = l.collisionStart, C = l.collisionEnd, P = l.collisionActive, S = h.length, I = 0, w = 0, _ = 0, x, A, R;
              for (R = 0; R < S; R++)
                x = h[R], A = x.pair, A ? (A.isActive && (P[_++] = A), p(A, x, c)) : (A = f(x, c), m[A.id] = A, T[I++] = A, g[b++] = A);
              for (b = 0, y = g.length, R = 0; R < y; R++)
                A = g[R], A.timeUpdated >= c ? g[b++] = A : (u(A, !1, c), A.collision.bodyA.sleepCounter > 0 && A.collision.bodyB.sleepCounter > 0 ? g[b++] = A : (C[w++] = A, delete m[A.id]));
              g.length !== b && (g.length = b), T.length !== I && (T.length = I), C.length !== w && (C.length = w), P.length !== _ && (P.length = _);
            }, s.clear = function(l) {
              return l.table = {}, l.list.length = 0, l.collisionStart.length = 0, l.collisionActive.length = 0, l.collisionEnd.length = 0, l;
            };
          })();
        },
        /* 20 */
        /***/
        function(e, i, r) {
          var s = e.exports = r(21);
          s.Axes = r(11), s.Bodies = r(12), s.Body = r(4), s.Bounds = r(1), s.Collision = r(8), s.Common = r(0), s.Composite = r(6), s.Composites = r(22), s.Constraint = r(10), s.Contact = r(16), s.Detector = r(13), s.Engine = r(17), s.Events = r(5), s.Grid = r(23), s.Mouse = r(14), s.MouseConstraint = r(24), s.Pair = r(9), s.Pairs = r(19), s.Plugin = r(15), s.Query = r(25), s.Render = r(26), s.Resolver = r(18), s.Runner = r(27), s.SAT = r(28), s.Sleeping = r(7), s.Svg = r(29), s.Vector = r(2), s.Vertices = r(3), s.World = r(30), s.Engine.run = s.Runner.run, s.Common.deprecated(s.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead");
        },
        /* 21 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(15), a = r(0);
          (function() {
            s.name = "matter-js", s.version = "0.20.0", s.uses = [], s.used = [], s.use = function() {
              o.use(s, Array.prototype.slice.call(arguments));
            }, s.before = function(l, h) {
              return l = l.replace(/^Matter./, ""), a.chainPathBefore(s, l, h);
            }, s.after = function(l, h) {
              return l = l.replace(/^Matter./, ""), a.chainPathAfter(s, l, h);
            };
          })();
        },
        /* 22 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(6), a = r(10), l = r(0), h = r(4), c = r(12), p = l.deprecated;
          (function() {
            s.stack = function(f, u, m, g, y, b, T) {
              for (var C = o.create({ label: "Stack" }), P = f, S = u, I, w = 0, _ = 0; _ < g; _++) {
                for (var x = 0, A = 0; A < m; A++) {
                  var R = T(P, S, A, _, I, w);
                  if (R) {
                    var M = R.bounds.max.y - R.bounds.min.y, k = R.bounds.max.x - R.bounds.min.x;
                    M > x && (x = M), h.translate(R, { x: k * 0.5, y: M * 0.5 }), P = R.bounds.max.x + y, o.addBody(C, R), I = R, w += 1;
                  } else
                    P += y;
                }
                S += x + b, P = f;
              }
              return C;
            }, s.chain = function(f, u, m, g, y, b) {
              for (var T = f.bodies, C = 1; C < T.length; C++) {
                var P = T[C - 1], S = T[C], I = P.bounds.max.y - P.bounds.min.y, w = P.bounds.max.x - P.bounds.min.x, _ = S.bounds.max.y - S.bounds.min.y, x = S.bounds.max.x - S.bounds.min.x, A = {
                  bodyA: P,
                  pointA: { x: w * u, y: I * m },
                  bodyB: S,
                  pointB: { x: x * g, y: _ * y }
                }, R = l.extend(A, b);
                o.addConstraint(f, a.create(R));
              }
              return f.label += " Chain", f;
            }, s.mesh = function(f, u, m, g, y) {
              var b = f.bodies, T, C, P, S, I;
              for (T = 0; T < m; T++) {
                for (C = 1; C < u; C++)
                  P = b[C - 1 + T * u], S = b[C + T * u], o.addConstraint(f, a.create(l.extend({ bodyA: P, bodyB: S }, y)));
                if (T > 0)
                  for (C = 0; C < u; C++)
                    P = b[C + (T - 1) * u], S = b[C + T * u], o.addConstraint(f, a.create(l.extend({ bodyA: P, bodyB: S }, y))), g && C > 0 && (I = b[C - 1 + (T - 1) * u], o.addConstraint(f, a.create(l.extend({ bodyA: I, bodyB: S }, y)))), g && C < u - 1 && (I = b[C + 1 + (T - 1) * u], o.addConstraint(f, a.create(l.extend({ bodyA: I, bodyB: S }, y))));
              }
              return f.label += " Mesh", f;
            }, s.pyramid = function(f, u, m, g, y, b, T) {
              return s.stack(f, u, m, g, y, b, function(C, P, S, I, w, _) {
                var x = Math.min(g, Math.ceil(m / 2)), A = w ? w.bounds.max.x - w.bounds.min.x : 0;
                if (!(I > x)) {
                  I = x - I;
                  var R = I, M = m - 1 - I;
                  if (!(S < R || S > M)) {
                    _ === 1 && h.translate(w, { x: (S + (m % 2 === 1 ? 1 : -1)) * A, y: 0 });
                    var k = w ? S * A : 0;
                    return T(f + k + S * y, P, S, I, w, _);
                  }
                }
              });
            }, s.newtonsCradle = function(f, u, m, g, y) {
              for (var b = o.create({ label: "Newtons Cradle" }), T = 0; T < m; T++) {
                var C = 1.9, P = c.circle(
                  f + T * (g * C),
                  u + y,
                  g,
                  { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }
                ), S = a.create({ pointA: { x: f + T * (g * C), y: u }, bodyB: P });
                o.addBody(b, P), o.addConstraint(b, S);
              }
              return b;
            }, p(s, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), s.car = function(f, u, m, g, y) {
              var b = h.nextGroup(!0), T = 20, C = -m * 0.5 + T, P = m * 0.5 - T, S = 0, I = o.create({ label: "Car" }), w = c.rectangle(f, u, m, g, {
                collisionFilter: {
                  group: b
                },
                chamfer: {
                  radius: g * 0.5
                },
                density: 2e-4
              }), _ = c.circle(f + C, u + S, y, {
                collisionFilter: {
                  group: b
                },
                friction: 0.8
              }), x = c.circle(f + P, u + S, y, {
                collisionFilter: {
                  group: b
                },
                friction: 0.8
              }), A = a.create({
                bodyB: w,
                pointB: { x: C, y: S },
                bodyA: _,
                stiffness: 1,
                length: 0
              }), R = a.create({
                bodyB: w,
                pointB: { x: P, y: S },
                bodyA: x,
                stiffness: 1,
                length: 0
              });
              return o.addBody(I, w), o.addBody(I, _), o.addBody(I, x), o.addConstraint(I, A), o.addConstraint(I, R), I;
            }, p(s, "car", "Composites.car ➤ moved to car example"), s.softBody = function(f, u, m, g, y, b, T, C, P, S) {
              P = l.extend({ inertia: 1 / 0 }, P), S = l.extend({ stiffness: 0.2, render: { type: "line", anchors: !1 } }, S);
              var I = s.stack(f, u, m, g, y, b, function(w, _) {
                return c.circle(w, _, C, P);
              });
              return s.mesh(I, m, g, T, S), I.label = "Soft Body", I;
            }, p(s, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples");
          })();
        },
        /* 23 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(9), a = r(0), l = a.deprecated;
          (function() {
            s.create = function(h) {
              var c = {
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
              };
              return a.extend(c, h);
            }, s.update = function(h, c, p, f) {
              var u, m, g, y = p.world, b = h.buckets, T, C, P = !1;
              for (u = 0; u < c.length; u++) {
                var S = c[u];
                if (!(S.isSleeping && !f) && !(y.bounds && (S.bounds.max.x < y.bounds.min.x || S.bounds.min.x > y.bounds.max.x || S.bounds.max.y < y.bounds.min.y || S.bounds.min.y > y.bounds.max.y))) {
                  var I = s._getRegion(h, S);
                  if (!S.region || I.id !== S.region.id || f) {
                    (!S.region || f) && (S.region = I);
                    var w = s._regionUnion(I, S.region);
                    for (m = w.startCol; m <= w.endCol; m++)
                      for (g = w.startRow; g <= w.endRow; g++) {
                        C = s._getBucketId(m, g), T = b[C];
                        var _ = m >= I.startCol && m <= I.endCol && g >= I.startRow && g <= I.endRow, x = m >= S.region.startCol && m <= S.region.endCol && g >= S.region.startRow && g <= S.region.endRow;
                        !_ && x && x && T && s._bucketRemoveBody(h, T, S), (S.region === I || _ && !x || f) && (T || (T = s._createBucket(b, C)), s._bucketAddBody(h, T, S));
                      }
                    S.region = I, P = !0;
                  }
                }
              }
              P && (h.pairsList = s._createActivePairsList(h));
            }, l(s, "update", "Grid.update ➤ replaced by Matter.Detector"), s.clear = function(h) {
              h.buckets = {}, h.pairs = {}, h.pairsList = [];
            }, l(s, "clear", "Grid.clear ➤ replaced by Matter.Detector"), s._regionUnion = function(h, c) {
              var p = Math.min(h.startCol, c.startCol), f = Math.max(h.endCol, c.endCol), u = Math.min(h.startRow, c.startRow), m = Math.max(h.endRow, c.endRow);
              return s._createRegion(p, f, u, m);
            }, s._getRegion = function(h, c) {
              var p = c.bounds, f = Math.floor(p.min.x / h.bucketWidth), u = Math.floor(p.max.x / h.bucketWidth), m = Math.floor(p.min.y / h.bucketHeight), g = Math.floor(p.max.y / h.bucketHeight);
              return s._createRegion(f, u, m, g);
            }, s._createRegion = function(h, c, p, f) {
              return {
                id: h + "," + c + "," + p + "," + f,
                startCol: h,
                endCol: c,
                startRow: p,
                endRow: f
              };
            }, s._getBucketId = function(h, c) {
              return "C" + h + "R" + c;
            }, s._createBucket = function(h, c) {
              var p = h[c] = [];
              return p;
            }, s._bucketAddBody = function(h, c, p) {
              var f = h.pairs, u = o.id, m = c.length, g;
              for (g = 0; g < m; g++) {
                var y = c[g];
                if (!(p.id === y.id || p.isStatic && y.isStatic)) {
                  var b = u(p, y), T = f[b];
                  T ? T[2] += 1 : f[b] = [p, y, 1];
                }
              }
              c.push(p);
            }, s._bucketRemoveBody = function(h, c, p) {
              var f = h.pairs, u = o.id, m;
              c.splice(a.indexOf(c, p), 1);
              var g = c.length;
              for (m = 0; m < g; m++) {
                var y = f[u(p, c[m])];
                y && (y[2] -= 1);
              }
            }, s._createActivePairsList = function(h) {
              var c, p = h.pairs, f = a.keys(p), u = f.length, m = [], g;
              for (g = 0; g < u; g++)
                c = p[f[g]], c[2] > 0 ? m.push(c) : delete p[f[g]];
              return m;
            };
          })();
        },
        /* 24 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(7), l = r(14), h = r(5), c = r(13), p = r(10), f = r(6), u = r(0), m = r(1);
          (function() {
            s.create = function(g, y) {
              var b = (g ? g.mouse : null) || (y ? y.mouse : null);
              b || (g && g.render && g.render.canvas ? b = l.create(g.render.canvas) : y && y.element ? b = l.create(y.element) : (b = l.create(), u.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
              var T = p.create({
                label: "Mouse Constraint",
                pointA: b.position,
                pointB: { x: 0, y: 0 },
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                render: {
                  strokeStyle: "#90EE90",
                  lineWidth: 3
                }
              }), C = {
                type: "mouseConstraint",
                mouse: b,
                element: null,
                body: null,
                constraint: T,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                }
              }, P = u.extend(C, y);
              return h.on(g, "beforeUpdate", function() {
                var S = f.allBodies(g.world);
                s.update(P, S), s._triggerEvents(P);
              }), P;
            }, s.update = function(g, y) {
              var b = g.mouse, T = g.constraint, C = g.body;
              if (b.button === 0) {
                if (T.bodyB)
                  a.set(T.bodyB, !1), T.pointA = b.position;
                else
                  for (var P = 0; P < y.length; P++)
                    if (C = y[P], m.contains(C.bounds, b.position) && c.canCollide(C.collisionFilter, g.collisionFilter))
                      for (var S = C.parts.length > 1 ? 1 : 0; S < C.parts.length; S++) {
                        var I = C.parts[S];
                        if (o.contains(I.vertices, b.position)) {
                          T.pointA = b.position, T.bodyB = g.body = C, T.pointB = { x: b.position.x - C.position.x, y: b.position.y - C.position.y }, T.angleB = C.angle, a.set(C, !1), h.trigger(g, "startdrag", { mouse: b, body: C });
                          break;
                        }
                      }
              } else
                T.bodyB = g.body = null, T.pointB = null, C && h.trigger(g, "enddrag", { mouse: b, body: C });
            }, s._triggerEvents = function(g) {
              var y = g.mouse, b = y.sourceEvents;
              b.mousemove && h.trigger(g, "mousemove", { mouse: y }), b.mousedown && h.trigger(g, "mousedown", { mouse: y }), b.mouseup && h.trigger(g, "mouseup", { mouse: y }), l.clearSourceEvents(y);
            };
          })();
        },
        /* 25 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(8), l = r(1), h = r(12), c = r(3);
          (function() {
            s.collides = function(p, f) {
              for (var u = [], m = f.length, g = p.bounds, y = a.collides, b = l.overlaps, T = 0; T < m; T++) {
                var C = f[T], P = C.parts.length, S = P === 1 ? 0 : 1;
                if (b(C.bounds, g))
                  for (var I = S; I < P; I++) {
                    var w = C.parts[I];
                    if (b(w.bounds, g)) {
                      var _ = y(w, p);
                      if (_) {
                        u.push(_);
                        break;
                      }
                    }
                  }
              }
              return u;
            }, s.ray = function(p, f, u, m) {
              m = m || 1e-100;
              for (var g = o.angle(f, u), y = o.magnitude(o.sub(f, u)), b = (u.x + f.x) * 0.5, T = (u.y + f.y) * 0.5, C = h.rectangle(b, T, y, m, { angle: g }), P = s.collides(C, p), S = 0; S < P.length; S += 1) {
                var I = P[S];
                I.body = I.bodyB = I.bodyA;
              }
              return P;
            }, s.region = function(p, f, u) {
              for (var m = [], g = 0; g < p.length; g++) {
                var y = p[g], b = l.overlaps(y.bounds, f);
                (b && !u || !b && u) && m.push(y);
              }
              return m;
            }, s.point = function(p, f) {
              for (var u = [], m = 0; m < p.length; m++) {
                var g = p[m];
                if (l.contains(g.bounds, f))
                  for (var y = g.parts.length === 1 ? 0 : 1; y < g.parts.length; y++) {
                    var b = g.parts[y];
                    if (l.contains(b.bounds, f) && c.contains(b.vertices, f)) {
                      u.push(g);
                      break;
                    }
                  }
              }
              return u;
            };
          })();
        },
        /* 26 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(4), a = r(0), l = r(6), h = r(1), c = r(5), p = r(2), f = r(14);
          (function() {
            var u, m;
            typeof window < "u" && (u = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(S) {
              window.setTimeout(function() {
                S(a.now());
              }, 1e3 / 60);
            }, m = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), s._goodFps = 30, s._goodDelta = 1e3 / 60, s.create = function(S) {
              var I = {
                engine: null,
                element: null,
                canvas: null,
                mouse: null,
                frameRequestId: null,
                timing: {
                  historySize: 60,
                  delta: 0,
                  deltaHistory: [],
                  lastTime: 0,
                  lastTimestamp: 0,
                  lastElapsed: 0,
                  timestampElapsed: 0,
                  timestampElapsedHistory: [],
                  engineDeltaHistory: [],
                  engineElapsedHistory: [],
                  engineUpdatesHistory: [],
                  elapsedHistory: []
                },
                options: {
                  width: 800,
                  height: 600,
                  pixelRatio: 1,
                  background: "#14151f",
                  wireframeBackground: "#14151f",
                  wireframeStrokeStyle: "#bbb",
                  hasBounds: !!S.bounds,
                  enabled: !0,
                  wireframes: !0,
                  showSleeping: !0,
                  showDebug: !1,
                  showStats: !1,
                  showPerformance: !1,
                  showBounds: !1,
                  showVelocity: !1,
                  showCollisions: !1,
                  showSeparations: !1,
                  showAxes: !1,
                  showPositions: !1,
                  showAngleIndicator: !1,
                  showIds: !1,
                  showVertexNumbers: !1,
                  showConvexHulls: !1,
                  showInternalEdges: !1,
                  showMousePosition: !1
                }
              }, w = a.extend(I, S);
              return w.canvas && (w.canvas.width = w.options.width || w.canvas.width, w.canvas.height = w.options.height || w.canvas.height), w.mouse = S.mouse, w.engine = S.engine, w.canvas = w.canvas || b(w.options.width, w.options.height), w.context = w.canvas.getContext("2d"), w.textures = {}, w.bounds = w.bounds || {
                min: {
                  x: 0,
                  y: 0
                },
                max: {
                  x: w.canvas.width,
                  y: w.canvas.height
                }
              }, w.controller = s, w.options.showBroadphase = !1, w.options.pixelRatio !== 1 && s.setPixelRatio(w, w.options.pixelRatio), a.isElement(w.element) && w.element.appendChild(w.canvas), w;
            }, s.run = function(S) {
              (function I(w) {
                S.frameRequestId = u(I), g(S, w), s.world(S, w), S.context.setTransform(S.options.pixelRatio, 0, 0, S.options.pixelRatio, 0, 0), (S.options.showStats || S.options.showDebug) && s.stats(S, S.context, w), (S.options.showPerformance || S.options.showDebug) && s.performance(S, S.context, w), S.context.setTransform(1, 0, 0, 1, 0, 0);
              })();
            }, s.stop = function(S) {
              m(S.frameRequestId);
            }, s.setPixelRatio = function(S, I) {
              var w = S.options, _ = S.canvas;
              I === "auto" && (I = T(_)), w.pixelRatio = I, _.setAttribute("data-pixel-ratio", I), _.width = w.width * I, _.height = w.height * I, _.style.width = w.width + "px", _.style.height = w.height + "px";
            }, s.setSize = function(S, I, w) {
              S.options.width = I, S.options.height = w, S.bounds.max.x = S.bounds.min.x + I, S.bounds.max.y = S.bounds.min.y + w, S.options.pixelRatio !== 1 ? s.setPixelRatio(S, S.options.pixelRatio) : (S.canvas.width = I, S.canvas.height = w);
            }, s.lookAt = function(S, I, w, _) {
              _ = typeof _ < "u" ? _ : !0, I = a.isArray(I) ? I : [I], w = w || {
                x: 0,
                y: 0
              };
              for (var x = {
                min: { x: 1 / 0, y: 1 / 0 },
                max: { x: -1 / 0, y: -1 / 0 }
              }, A = 0; A < I.length; A += 1) {
                var R = I[A], M = R.bounds ? R.bounds.min : R.min || R.position || R, k = R.bounds ? R.bounds.max : R.max || R.position || R;
                M && k && (M.x < x.min.x && (x.min.x = M.x), k.x > x.max.x && (x.max.x = k.x), M.y < x.min.y && (x.min.y = M.y), k.y > x.max.y && (x.max.y = k.y));
              }
              var B = x.max.x - x.min.x + 2 * w.x, O = x.max.y - x.min.y + 2 * w.y, U = S.canvas.height, z = S.canvas.width, Q = z / U, j = B / O, H = 1, _t = 1;
              j > Q ? _t = j / Q : H = Q / j, S.options.hasBounds = !0, S.bounds.min.x = x.min.x, S.bounds.max.x = x.min.x + B * H, S.bounds.min.y = x.min.y, S.bounds.max.y = x.min.y + O * _t, _ && (S.bounds.min.x += B * 0.5 - B * H * 0.5, S.bounds.max.x += B * 0.5 - B * H * 0.5, S.bounds.min.y += O * 0.5 - O * _t * 0.5, S.bounds.max.y += O * 0.5 - O * _t * 0.5), S.bounds.min.x -= w.x, S.bounds.max.x -= w.x, S.bounds.min.y -= w.y, S.bounds.max.y -= w.y, S.mouse && (f.setScale(S.mouse, {
                x: (S.bounds.max.x - S.bounds.min.x) / S.canvas.width,
                y: (S.bounds.max.y - S.bounds.min.y) / S.canvas.height
              }), f.setOffset(S.mouse, S.bounds.min));
            }, s.startViewTransform = function(S) {
              var I = S.bounds.max.x - S.bounds.min.x, w = S.bounds.max.y - S.bounds.min.y, _ = I / S.options.width, x = w / S.options.height;
              S.context.setTransform(
                S.options.pixelRatio / _,
                0,
                0,
                S.options.pixelRatio / x,
                0,
                0
              ), S.context.translate(-S.bounds.min.x, -S.bounds.min.y);
            }, s.endViewTransform = function(S) {
              S.context.setTransform(S.options.pixelRatio, 0, 0, S.options.pixelRatio, 0, 0);
            }, s.world = function(S, I) {
              var w = a.now(), _ = S.engine, x = _.world, A = S.canvas, R = S.context, M = S.options, k = S.timing, B = l.allBodies(x), O = l.allConstraints(x), U = M.wireframes ? M.wireframeBackground : M.background, z = [], Q = [], j, H = {
                timestamp: _.timing.timestamp
              };
              if (c.trigger(S, "beforeRender", H), S.currentBackground !== U && P(S, U), R.globalCompositeOperation = "source-in", R.fillStyle = "transparent", R.fillRect(0, 0, A.width, A.height), R.globalCompositeOperation = "source-over", M.hasBounds) {
                for (j = 0; j < B.length; j++) {
                  var _t = B[j];
                  h.overlaps(_t.bounds, S.bounds) && z.push(_t);
                }
                for (j = 0; j < O.length; j++) {
                  var J = O[j], $ = J.bodyA, St = J.bodyB, Ct = J.pointA, rt = J.pointB;
                  $ && (Ct = p.add($.position, J.pointA)), St && (rt = p.add(St.position, J.pointB)), !(!Ct || !rt) && (h.contains(S.bounds, Ct) || h.contains(S.bounds, rt)) && Q.push(J);
                }
                s.startViewTransform(S), S.mouse && (f.setScale(S.mouse, {
                  x: (S.bounds.max.x - S.bounds.min.x) / S.options.width,
                  y: (S.bounds.max.y - S.bounds.min.y) / S.options.height
                }), f.setOffset(S.mouse, S.bounds.min));
              } else
                Q = O, z = B, S.options.pixelRatio !== 1 && S.context.setTransform(S.options.pixelRatio, 0, 0, S.options.pixelRatio, 0, 0);
              !M.wireframes || _.enableSleeping && M.showSleeping ? s.bodies(S, z, R) : (M.showConvexHulls && s.bodyConvexHulls(S, z, R), s.bodyWireframes(S, z, R)), M.showBounds && s.bodyBounds(S, z, R), (M.showAxes || M.showAngleIndicator) && s.bodyAxes(S, z, R), M.showPositions && s.bodyPositions(S, z, R), M.showVelocity && s.bodyVelocity(S, z, R), M.showIds && s.bodyIds(S, z, R), M.showSeparations && s.separations(S, _.pairs.list, R), M.showCollisions && s.collisions(S, _.pairs.list, R), M.showVertexNumbers && s.vertexNumbers(S, z, R), M.showMousePosition && s.mousePosition(S, S.mouse, R), s.constraints(Q, R), M.hasBounds && s.endViewTransform(S), c.trigger(S, "afterRender", H), k.lastElapsed = a.now() - w;
            }, s.stats = function(S, I, w) {
              for (var _ = S.engine, x = _.world, A = l.allBodies(x), R = 0, M = 55, k = 44, B = 0, O = 0, U = 0; U < A.length; U += 1)
                R += A[U].parts.length;
              var z = {
                Part: R,
                Body: A.length,
                Cons: l.allConstraints(x).length,
                Comp: l.allComposites(x).length,
                Pair: _.pairs.list.length
              };
              I.fillStyle = "#0e0f19", I.fillRect(B, O, M * 5.5, k), I.font = "12px Arial", I.textBaseline = "top", I.textAlign = "right";
              for (var Q in z) {
                var j = z[Q];
                I.fillStyle = "#aaa", I.fillText(Q, B + M, O + 8), I.fillStyle = "#eee", I.fillText(j, B + M, O + 26), B += M;
              }
            }, s.performance = function(S, I) {
              var w = S.engine, _ = S.timing, x = _.deltaHistory, A = _.elapsedHistory, R = _.timestampElapsedHistory, M = _.engineDeltaHistory, k = _.engineUpdatesHistory, B = _.engineElapsedHistory, O = w.timing.lastUpdatesPerFrame, U = w.timing.lastDelta, z = y(x), Q = y(A), j = y(M), H = y(k), _t = y(B), J = y(R), $ = J / z || 0, St = Math.round(z / U), Ct = 1e3 / z || 0, rt = 4, Xt = 12, Pt = 60, Ne = 34, te = 10, ee = 69;
              I.fillStyle = "#0e0f19", I.fillRect(0, 50, Xt * 5 + Pt * 6 + 22, Ne), s.status(
                I,
                te,
                ee,
                Pt,
                rt,
                x.length,
                Math.round(Ct) + " fps",
                Ct / s._goodFps,
                function(It) {
                  return x[It] / z - 1;
                }
              ), s.status(
                I,
                te + Xt + Pt,
                ee,
                Pt,
                rt,
                M.length,
                U.toFixed(2) + " dt",
                s._goodDelta / U,
                function(It) {
                  return M[It] / j - 1;
                }
              ), s.status(
                I,
                te + (Xt + Pt) * 2,
                ee,
                Pt,
                rt,
                k.length,
                O + " upf",
                Math.pow(a.clamp(H / St || 1, 0, 1), 4),
                function(It) {
                  return k[It] / H - 1;
                }
              ), s.status(
                I,
                te + (Xt + Pt) * 3,
                ee,
                Pt,
                rt,
                B.length,
                _t.toFixed(2) + " ut",
                1 - O * _t / s._goodFps,
                function(It) {
                  return B[It] / _t - 1;
                }
              ), s.status(
                I,
                te + (Xt + Pt) * 4,
                ee,
                Pt,
                rt,
                A.length,
                Q.toFixed(2) + " rt",
                1 - Q / s._goodFps,
                function(It) {
                  return A[It] / Q - 1;
                }
              ), s.status(
                I,
                te + (Xt + Pt) * 5,
                ee,
                Pt,
                rt,
                R.length,
                $.toFixed(2) + " x",
                $ * $ * $,
                function(It) {
                  return (R[It] / x[It] / $ || 0) - 1;
                }
              );
            }, s.status = function(S, I, w, _, x, A, R, M, k) {
              S.strokeStyle = "#888", S.fillStyle = "#444", S.lineWidth = 1, S.fillRect(I, w + 7, _, 1), S.beginPath(), S.moveTo(I, w + 7 - x * a.clamp(0.4 * k(0), -2, 2));
              for (var B = 0; B < _; B += 1)
                S.lineTo(I + B, w + 7 - (B < A ? x * a.clamp(0.4 * k(B), -2, 2) : 0));
              S.stroke(), S.fillStyle = "hsl(" + a.clamp(25 + 95 * M, 0, 120) + ",100%,60%)", S.fillRect(I, w - 7, 4, 4), S.font = "12px Arial", S.textBaseline = "middle", S.textAlign = "right", S.fillStyle = "#eee", S.fillText(R, I + _, w - 5);
            }, s.constraints = function(S, I) {
              for (var w = I, _ = 0; _ < S.length; _++) {
                var x = S[_];
                if (!(!x.render.visible || !x.pointA || !x.pointB)) {
                  var A = x.bodyA, R = x.bodyB, M, k;
                  if (A ? M = p.add(A.position, x.pointA) : M = x.pointA, x.render.type === "pin")
                    w.beginPath(), w.arc(M.x, M.y, 3, 0, 2 * Math.PI), w.closePath();
                  else {
                    if (R ? k = p.add(R.position, x.pointB) : k = x.pointB, w.beginPath(), w.moveTo(M.x, M.y), x.render.type === "spring")
                      for (var B = p.sub(k, M), O = p.perp(p.normalise(B)), U = Math.ceil(a.clamp(x.length / 5, 12, 20)), z, Q = 1; Q < U; Q += 1)
                        z = Q % 2 === 0 ? 1 : -1, w.lineTo(
                          M.x + B.x * (Q / U) + O.x * z * 4,
                          M.y + B.y * (Q / U) + O.y * z * 4
                        );
                    w.lineTo(k.x, k.y);
                  }
                  x.render.lineWidth && (w.lineWidth = x.render.lineWidth, w.strokeStyle = x.render.strokeStyle, w.stroke()), x.render.anchors && (w.fillStyle = x.render.strokeStyle, w.beginPath(), w.arc(M.x, M.y, 3, 0, 2 * Math.PI), w.arc(k.x, k.y, 3, 0, 2 * Math.PI), w.closePath(), w.fill());
                }
              }
            }, s.bodies = function(S, I, w) {
              var _ = w;
              S.engine;
              var x = S.options, A = x.showInternalEdges || !x.wireframes, R, M, k, B;
              for (k = 0; k < I.length; k++)
                if (R = I[k], !!R.render.visible) {
                  for (B = R.parts.length > 1 ? 1 : 0; B < R.parts.length; B++)
                    if (M = R.parts[B], !!M.render.visible) {
                      if (x.showSleeping && R.isSleeping ? _.globalAlpha = 0.5 * M.render.opacity : M.render.opacity !== 1 && (_.globalAlpha = M.render.opacity), M.render.sprite && M.render.sprite.texture && !x.wireframes) {
                        var O = M.render.sprite, U = C(S, O.texture);
                        _.translate(M.position.x, M.position.y), _.rotate(M.angle), _.drawImage(
                          U,
                          U.width * -O.xOffset * O.xScale,
                          U.height * -O.yOffset * O.yScale,
                          U.width * O.xScale,
                          U.height * O.yScale
                        ), _.rotate(-M.angle), _.translate(-M.position.x, -M.position.y);
                      } else {
                        if (M.circleRadius)
                          _.beginPath(), _.arc(M.position.x, M.position.y, M.circleRadius, 0, 2 * Math.PI);
                        else {
                          _.beginPath(), _.moveTo(M.vertices[0].x, M.vertices[0].y);
                          for (var z = 1; z < M.vertices.length; z++)
                            !M.vertices[z - 1].isInternal || A ? _.lineTo(M.vertices[z].x, M.vertices[z].y) : _.moveTo(M.vertices[z].x, M.vertices[z].y), M.vertices[z].isInternal && !A && _.moveTo(M.vertices[(z + 1) % M.vertices.length].x, M.vertices[(z + 1) % M.vertices.length].y);
                          _.lineTo(M.vertices[0].x, M.vertices[0].y), _.closePath();
                        }
                        x.wireframes ? (_.lineWidth = 1, _.strokeStyle = S.options.wireframeStrokeStyle, _.stroke()) : (_.fillStyle = M.render.fillStyle, M.render.lineWidth && (_.lineWidth = M.render.lineWidth, _.strokeStyle = M.render.strokeStyle, _.stroke()), _.fill());
                      }
                      _.globalAlpha = 1;
                    }
                }
            }, s.bodyWireframes = function(S, I, w) {
              var _ = w, x = S.options.showInternalEdges, A, R, M, k, B;
              for (_.beginPath(), M = 0; M < I.length; M++)
                if (A = I[M], !!A.render.visible)
                  for (B = A.parts.length > 1 ? 1 : 0; B < A.parts.length; B++) {
                    for (R = A.parts[B], _.moveTo(R.vertices[0].x, R.vertices[0].y), k = 1; k < R.vertices.length; k++)
                      !R.vertices[k - 1].isInternal || x ? _.lineTo(R.vertices[k].x, R.vertices[k].y) : _.moveTo(R.vertices[k].x, R.vertices[k].y), R.vertices[k].isInternal && !x && _.moveTo(R.vertices[(k + 1) % R.vertices.length].x, R.vertices[(k + 1) % R.vertices.length].y);
                    _.lineTo(R.vertices[0].x, R.vertices[0].y);
                  }
              _.lineWidth = 1, _.strokeStyle = S.options.wireframeStrokeStyle, _.stroke();
            }, s.bodyConvexHulls = function(S, I, w) {
              var _ = w, x, A, R;
              for (_.beginPath(), A = 0; A < I.length; A++)
                if (x = I[A], !(!x.render.visible || x.parts.length === 1)) {
                  for (_.moveTo(x.vertices[0].x, x.vertices[0].y), R = 1; R < x.vertices.length; R++)
                    _.lineTo(x.vertices[R].x, x.vertices[R].y);
                  _.lineTo(x.vertices[0].x, x.vertices[0].y);
                }
              _.lineWidth = 1, _.strokeStyle = "rgba(255,255,255,0.2)", _.stroke();
            }, s.vertexNumbers = function(S, I, w) {
              var _ = w, x, A, R;
              for (x = 0; x < I.length; x++) {
                var M = I[x].parts;
                for (R = M.length > 1 ? 1 : 0; R < M.length; R++) {
                  var k = M[R];
                  for (A = 0; A < k.vertices.length; A++)
                    _.fillStyle = "rgba(255,255,255,0.2)", _.fillText(x + "_" + A, k.position.x + (k.vertices[A].x - k.position.x) * 0.8, k.position.y + (k.vertices[A].y - k.position.y) * 0.8);
                }
              }
            }, s.mousePosition = function(S, I, w) {
              var _ = w;
              _.fillStyle = "rgba(255,255,255,0.8)", _.fillText(I.position.x + "  " + I.position.y, I.position.x + 5, I.position.y - 5);
            }, s.bodyBounds = function(S, I, w) {
              var _ = w;
              S.engine;
              var x = S.options;
              _.beginPath();
              for (var A = 0; A < I.length; A++) {
                var R = I[A];
                if (R.render.visible)
                  for (var M = I[A].parts, k = M.length > 1 ? 1 : 0; k < M.length; k++) {
                    var B = M[k];
                    _.rect(B.bounds.min.x, B.bounds.min.y, B.bounds.max.x - B.bounds.min.x, B.bounds.max.y - B.bounds.min.y);
                  }
              }
              x.wireframes ? _.strokeStyle = "rgba(255,255,255,0.08)" : _.strokeStyle = "rgba(0,0,0,0.1)", _.lineWidth = 1, _.stroke();
            }, s.bodyAxes = function(S, I, w) {
              var _ = w;
              S.engine;
              var x = S.options, A, R, M, k;
              for (_.beginPath(), R = 0; R < I.length; R++) {
                var B = I[R], O = B.parts;
                if (B.render.visible)
                  if (x.showAxes)
                    for (M = O.length > 1 ? 1 : 0; M < O.length; M++)
                      for (A = O[M], k = 0; k < A.axes.length; k++) {
                        var U = A.axes[k];
                        _.moveTo(A.position.x, A.position.y), _.lineTo(A.position.x + U.x * 20, A.position.y + U.y * 20);
                      }
                  else
                    for (M = O.length > 1 ? 1 : 0; M < O.length; M++)
                      for (A = O[M], k = 0; k < A.axes.length; k++)
                        _.moveTo(A.position.x, A.position.y), _.lineTo(
                          (A.vertices[0].x + A.vertices[A.vertices.length - 1].x) / 2,
                          (A.vertices[0].y + A.vertices[A.vertices.length - 1].y) / 2
                        );
              }
              x.wireframes ? (_.strokeStyle = "indianred", _.lineWidth = 1) : (_.strokeStyle = "rgba(255, 255, 255, 0.4)", _.globalCompositeOperation = "overlay", _.lineWidth = 2), _.stroke(), _.globalCompositeOperation = "source-over";
            }, s.bodyPositions = function(S, I, w) {
              var _ = w;
              S.engine;
              var x = S.options, A, R, M, k;
              for (_.beginPath(), M = 0; M < I.length; M++)
                if (A = I[M], !!A.render.visible)
                  for (k = 0; k < A.parts.length; k++)
                    R = A.parts[k], _.arc(R.position.x, R.position.y, 3, 0, 2 * Math.PI, !1), _.closePath();
              for (x.wireframes ? _.fillStyle = "indianred" : _.fillStyle = "rgba(0,0,0,0.5)", _.fill(), _.beginPath(), M = 0; M < I.length; M++)
                A = I[M], A.render.visible && (_.arc(A.positionPrev.x, A.positionPrev.y, 2, 0, 2 * Math.PI, !1), _.closePath());
              _.fillStyle = "rgba(255,165,0,0.8)", _.fill();
            }, s.bodyVelocity = function(S, I, w) {
              var _ = w;
              _.beginPath();
              for (var x = 0; x < I.length; x++) {
                var A = I[x];
                if (A.render.visible) {
                  var R = o.getVelocity(A);
                  _.moveTo(A.position.x, A.position.y), _.lineTo(A.position.x + R.x, A.position.y + R.y);
                }
              }
              _.lineWidth = 3, _.strokeStyle = "cornflowerblue", _.stroke();
            }, s.bodyIds = function(S, I, w) {
              var _ = w, x, A;
              for (x = 0; x < I.length; x++)
                if (I[x].render.visible) {
                  var R = I[x].parts;
                  for (A = R.length > 1 ? 1 : 0; A < R.length; A++) {
                    var M = R[A];
                    _.font = "12px Arial", _.fillStyle = "rgba(255,255,255,0.5)", _.fillText(M.id, M.position.x + 10, M.position.y - 10);
                  }
                }
            }, s.collisions = function(S, I, w) {
              var _ = w, x = S.options, A, R, M, k;
              for (_.beginPath(), M = 0; M < I.length; M++)
                if (A = I[M], !!A.isActive)
                  for (R = A.collision, k = 0; k < A.contactCount; k++) {
                    var B = A.contacts[k], O = B.vertex;
                    _.rect(O.x - 1.5, O.y - 1.5, 3.5, 3.5);
                  }
              for (x.wireframes ? _.fillStyle = "rgba(255,255,255,0.7)" : _.fillStyle = "orange", _.fill(), _.beginPath(), M = 0; M < I.length; M++)
                if (A = I[M], !!A.isActive && (R = A.collision, A.contactCount > 0)) {
                  var U = A.contacts[0].vertex.x, z = A.contacts[0].vertex.y;
                  A.contactCount === 2 && (U = (A.contacts[0].vertex.x + A.contacts[1].vertex.x) / 2, z = (A.contacts[0].vertex.y + A.contacts[1].vertex.y) / 2), R.bodyB === R.supports[0].body || R.bodyA.isStatic === !0 ? _.moveTo(U - R.normal.x * 8, z - R.normal.y * 8) : _.moveTo(U + R.normal.x * 8, z + R.normal.y * 8), _.lineTo(U, z);
                }
              x.wireframes ? _.strokeStyle = "rgba(255,165,0,0.7)" : _.strokeStyle = "orange", _.lineWidth = 1, _.stroke();
            }, s.separations = function(S, I, w) {
              var _ = w, x = S.options, A, R, M, k, B;
              for (_.beginPath(), B = 0; B < I.length; B++)
                if (A = I[B], !!A.isActive) {
                  R = A.collision, M = R.bodyA, k = R.bodyB;
                  var O = 1;
                  !k.isStatic && !M.isStatic && (O = 0.5), k.isStatic && (O = 0), _.moveTo(k.position.x, k.position.y), _.lineTo(k.position.x - R.penetration.x * O, k.position.y - R.penetration.y * O), O = 1, !k.isStatic && !M.isStatic && (O = 0.5), M.isStatic && (O = 0), _.moveTo(M.position.x, M.position.y), _.lineTo(M.position.x + R.penetration.x * O, M.position.y + R.penetration.y * O);
                }
              x.wireframes ? _.strokeStyle = "rgba(255,165,0,0.5)" : _.strokeStyle = "orange", _.stroke();
            }, s.inspector = function(S, I) {
              S.engine;
              var w = S.selected, _ = S.render, x = _.options, A;
              if (x.hasBounds) {
                var R = _.bounds.max.x - _.bounds.min.x, M = _.bounds.max.y - _.bounds.min.y, k = R / _.options.width, B = M / _.options.height;
                I.scale(1 / k, 1 / B), I.translate(-_.bounds.min.x, -_.bounds.min.y);
              }
              for (var O = 0; O < w.length; O++) {
                var U = w[O].data;
                switch (I.translate(0.5, 0.5), I.lineWidth = 1, I.strokeStyle = "rgba(255,165,0,0.9)", I.setLineDash([1, 2]), U.type) {
                  case "body":
                    A = U.bounds, I.beginPath(), I.rect(
                      Math.floor(A.min.x - 3),
                      Math.floor(A.min.y - 3),
                      Math.floor(A.max.x - A.min.x + 6),
                      Math.floor(A.max.y - A.min.y + 6)
                    ), I.closePath(), I.stroke();
                    break;
                  case "constraint":
                    var z = U.pointA;
                    U.bodyA && (z = U.pointB), I.beginPath(), I.arc(z.x, z.y, 10, 0, 2 * Math.PI), I.closePath(), I.stroke();
                    break;
                }
                I.setLineDash([]), I.translate(-0.5, -0.5);
              }
              S.selectStart !== null && (I.translate(0.5, 0.5), I.lineWidth = 1, I.strokeStyle = "rgba(255,165,0,0.6)", I.fillStyle = "rgba(255,165,0,0.1)", A = S.selectBounds, I.beginPath(), I.rect(
                Math.floor(A.min.x),
                Math.floor(A.min.y),
                Math.floor(A.max.x - A.min.x),
                Math.floor(A.max.y - A.min.y)
              ), I.closePath(), I.stroke(), I.fill(), I.translate(-0.5, -0.5)), x.hasBounds && I.setTransform(1, 0, 0, 1, 0, 0);
            };
            var g = function(S, I) {
              var w = S.engine, _ = S.timing, x = _.historySize, A = w.timing.timestamp;
              _.delta = I - _.lastTime || s._goodDelta, _.lastTime = I, _.timestampElapsed = A - _.lastTimestamp || 0, _.lastTimestamp = A, _.deltaHistory.unshift(_.delta), _.deltaHistory.length = Math.min(_.deltaHistory.length, x), _.engineDeltaHistory.unshift(w.timing.lastDelta), _.engineDeltaHistory.length = Math.min(_.engineDeltaHistory.length, x), _.timestampElapsedHistory.unshift(_.timestampElapsed), _.timestampElapsedHistory.length = Math.min(_.timestampElapsedHistory.length, x), _.engineUpdatesHistory.unshift(w.timing.lastUpdatesPerFrame), _.engineUpdatesHistory.length = Math.min(_.engineUpdatesHistory.length, x), _.engineElapsedHistory.unshift(w.timing.lastElapsed), _.engineElapsedHistory.length = Math.min(_.engineElapsedHistory.length, x), _.elapsedHistory.unshift(_.lastElapsed), _.elapsedHistory.length = Math.min(_.elapsedHistory.length, x);
            }, y = function(S) {
              for (var I = 0, w = 0; w < S.length; w += 1)
                I += S[w];
              return I / S.length || 0;
            }, b = function(S, I) {
              var w = document.createElement("canvas");
              return w.width = S, w.height = I, w.oncontextmenu = function() {
                return !1;
              }, w.onselectstart = function() {
                return !1;
              }, w;
            }, T = function(S) {
              var I = S.getContext("2d"), w = window.devicePixelRatio || 1, _ = I.webkitBackingStorePixelRatio || I.mozBackingStorePixelRatio || I.msBackingStorePixelRatio || I.oBackingStorePixelRatio || I.backingStorePixelRatio || 1;
              return w / _;
            }, C = function(S, I) {
              var w = S.textures[I];
              return w || (w = S.textures[I] = new Image(), w.src = I, w);
            }, P = function(S, I) {
              var w = I;
              /(jpg|gif|png)$/.test(I) && (w = "url(" + I + ")"), S.canvas.style.background = w, S.canvas.style.backgroundSize = "contain", S.currentBackground = I;
            };
          })();
        },
        /* 27 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(5), a = r(17), l = r(0);
          (function() {
            s._maxFrameDelta = 1e3 / 15, s._frameDeltaFallback = 1e3 / 60, s._timeBufferMargin = 1.5, s._elapsedNextEstimate = 1, s._smoothingLowerBound = 0.1, s._smoothingUpperBound = 0.9, s.create = function(c) {
              var p = {
                delta: 16.666666666666668,
                frameDelta: null,
                frameDeltaSmoothing: !0,
                frameDeltaSnapping: !0,
                frameDeltaHistory: [],
                frameDeltaHistorySize: 100,
                frameRequestId: null,
                timeBuffer: 0,
                timeLastTick: null,
                maxUpdates: null,
                maxFrameTime: 33.333333333333336,
                lastUpdatesDeferred: 0,
                enabled: !0
              }, f = l.extend(p, c);
              return f.fps = 0, f;
            }, s.run = function(c, p) {
              return c.timeBuffer = s._frameDeltaFallback, function f(u) {
                c.frameRequestId = s._onNextFrame(c, f), u && c.enabled && s.tick(c, p, u);
              }(), c;
            }, s.tick = function(c, p, f) {
              var u = l.now(), m = c.delta, g = 0, y = f - c.timeLastTick;
              if ((!y || !c.timeLastTick || y > Math.max(s._maxFrameDelta, c.maxFrameTime)) && (y = c.frameDelta || s._frameDeltaFallback), c.frameDeltaSmoothing) {
                c.frameDeltaHistory.push(y), c.frameDeltaHistory = c.frameDeltaHistory.slice(-c.frameDeltaHistorySize);
                var b = c.frameDeltaHistory.slice(0).sort(), T = c.frameDeltaHistory.slice(
                  b.length * s._smoothingLowerBound,
                  b.length * s._smoothingUpperBound
                ), C = h(T);
                y = C || y;
              }
              c.frameDeltaSnapping && (y = 1e3 / Math.round(1e3 / y)), c.frameDelta = y, c.timeLastTick = f, c.timeBuffer += c.frameDelta, c.timeBuffer = l.clamp(
                c.timeBuffer,
                0,
                c.frameDelta + m * s._timeBufferMargin
              ), c.lastUpdatesDeferred = 0;
              var P = c.maxUpdates || Math.ceil(c.maxFrameTime / m), S = {
                timestamp: p.timing.timestamp
              };
              o.trigger(c, "beforeTick", S), o.trigger(c, "tick", S);
              for (var I = l.now(); m > 0 && c.timeBuffer >= m * s._timeBufferMargin; ) {
                o.trigger(c, "beforeUpdate", S), a.update(p, m), o.trigger(c, "afterUpdate", S), c.timeBuffer -= m, g += 1;
                var w = l.now() - u, _ = l.now() - I, x = w + s._elapsedNextEstimate * _ / g;
                if (g >= P || x > c.maxFrameTime) {
                  c.lastUpdatesDeferred = Math.round(Math.max(0, c.timeBuffer / m - s._timeBufferMargin));
                  break;
                }
              }
              p.timing.lastUpdatesPerFrame = g, o.trigger(c, "afterTick", S), c.frameDeltaHistory.length >= 100 && (c.lastUpdatesDeferred && Math.round(c.frameDelta / m) > P ? l.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : c.lastUpdatesDeferred && l.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof c.isFixed < "u" && l.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (c.deltaMin || c.deltaMax) && l.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), c.fps !== 0 && l.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs."));
            }, s.stop = function(c) {
              s._cancelNextFrame(c);
            }, s._onNextFrame = function(c, p) {
              if (typeof window < "u" && window.requestAnimationFrame)
                c.frameRequestId = window.requestAnimationFrame(p);
              else
                throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");
              return c.frameRequestId;
            }, s._cancelNextFrame = function(c) {
              if (typeof window < "u" && window.cancelAnimationFrame)
                window.cancelAnimationFrame(c.frameRequestId);
              else
                throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.");
            };
            var h = function(c) {
              for (var p = 0, f = c.length, u = 0; u < f; u += 1)
                p += c[u];
              return p / f || 0;
            };
          })();
        },
        /* 28 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(8), a = r(0), l = a.deprecated;
          (function() {
            s.collides = function(h, c) {
              return o.collides(h, c);
            }, l(s, "collides", "SAT.collides ➤ replaced by Collision.collides");
          })();
        },
        /* 29 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s, r(1);
          var o = r(0);
          (function() {
            s.pathToVertices = function(a, l) {
              typeof window < "u" && !("SVGPathSeg" in window) && o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
              var h, c, p, f, u, m, g, y, b, T, C = [], P, S, I = 0, w = 0, _ = 0;
              l = l || 15;
              var x = function(R, M, k) {
                var B = k % 2 === 1 && k > 1;
                if (!b || R != b.x || M != b.y) {
                  b && B ? (P = b.x, S = b.y) : (P = 0, S = 0);
                  var O = {
                    x: P + R,
                    y: S + M
                  };
                  (B || !b) && (b = O), C.push(O), w = P + R, _ = S + M;
                }
              }, A = function(R) {
                var M = R.pathSegTypeAsLetter.toUpperCase();
                if (M !== "Z") {
                  switch (M) {
                    case "M":
                    case "L":
                    case "T":
                    case "C":
                    case "S":
                    case "Q":
                      w = R.x, _ = R.y;
                      break;
                    case "H":
                      w = R.x;
                      break;
                    case "V":
                      _ = R.y;
                      break;
                  }
                  x(w, _, R.pathSegType);
                }
              };
              for (s._svgPathToAbsolute(a), p = a.getTotalLength(), m = [], h = 0; h < a.pathSegList.numberOfItems; h += 1)
                m.push(a.pathSegList.getItem(h));
              for (g = m.concat(); I < p; ) {
                if (T = a.getPathSegAtLength(I), u = m[T], u != y) {
                  for (; g.length && g[0] != u; )
                    A(g.shift());
                  y = u;
                }
                switch (u.pathSegTypeAsLetter.toUpperCase()) {
                  case "C":
                  case "T":
                  case "S":
                  case "Q":
                  case "A":
                    f = a.getPointAtLength(I), x(f.x, f.y, 0);
                    break;
                }
                I += l;
              }
              for (h = 0, c = g.length; h < c; ++h)
                A(g[h]);
              return C;
            }, s._svgPathToAbsolute = function(a) {
              for (var l, h, c, p, f, u, m = a.pathSegList, g = 0, y = 0, b = m.numberOfItems, T = 0; T < b; ++T) {
                var C = m.getItem(T), P = C.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(P))
                  "x" in C && (g = C.x), "y" in C && (y = C.y);
                else
                  switch ("x1" in C && (c = g + C.x1), "x2" in C && (f = g + C.x2), "y1" in C && (p = y + C.y1), "y2" in C && (u = y + C.y2), "x" in C && (g += C.x), "y" in C && (y += C.y), P) {
                    case "m":
                      m.replaceItem(a.createSVGPathSegMovetoAbs(g, y), T);
                      break;
                    case "l":
                      m.replaceItem(a.createSVGPathSegLinetoAbs(g, y), T);
                      break;
                    case "h":
                      m.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(g), T);
                      break;
                    case "v":
                      m.replaceItem(a.createSVGPathSegLinetoVerticalAbs(y), T);
                      break;
                    case "c":
                      m.replaceItem(a.createSVGPathSegCurvetoCubicAbs(g, y, c, p, f, u), T);
                      break;
                    case "s":
                      m.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(g, y, f, u), T);
                      break;
                    case "q":
                      m.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(g, y, c, p), T);
                      break;
                    case "t":
                      m.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(g, y), T);
                      break;
                    case "a":
                      m.replaceItem(a.createSVGPathSegArcAbs(g, y, C.r1, C.r2, C.angle, C.largeArcFlag, C.sweepFlag), T);
                      break;
                    case "z":
                    case "Z":
                      g = l, y = h;
                      break;
                  }
                (P == "M" || P == "m") && (l = g, h = y);
              }
            };
          })();
        },
        /* 30 */
        /***/
        function(e, i, r) {
          var s = {};
          e.exports = s;
          var o = r(6);
          r(0), function() {
            s.create = o.create, s.add = o.add, s.remove = o.remove, s.clear = o.clear, s.addComposite = o.addComposite, s.addBody = o.addBody, s.addConstraint = o.addConstraint;
          }();
        }
        /******/
      ])
    );
  });
})(Xy);
var cn = Xy.exports;
let Oi;
const _r = /* @__PURE__ */ new Map(), ca = /* @__PURE__ */ new Map(), _u = /* @__PURE__ */ new Map();
let Qo = 0;
const cT = () => {
  Oi = cn.Engine.create(), cn.Events.on(Oi, "collisionStart", (n) => {
    n.pairs.forEach((t) => {
      var e, i;
      const { bodyA: r, bodyB: s } = t, o = _r.get(r.label), a = _r.get(s.label);
      if (!o || !a) return;
      const l = [o, a].find((c) => c.surface), h = [o, a].find((c) => !c.surface);
      h && (l ? ca.set(
        h.target.matterBody.label,
        Math.floor(vf(l).y1)
      ) : ((e = o.onCollision) == null || e.call(o, a.target), (i = a.onCollision) == null || i.call(a, o.target)));
    });
  }), cn.Events.on(Oi, "collisionEnd", (n) => {
    n.pairs.forEach((t) => {
      const { bodyA: e, bodyB: i } = t, r = _r.get(e.label), s = _r.get(i.label);
      if (!r || !s) return;
      const o = [r, s].find((l) => l.surface), a = [r, s].find((l) => !l.surface);
      a && o && ca.delete(a.target.matterBody.label);
    });
  }), cn.Events.on(Oi, "afterUpdate", () => {
    _u.forEach((n) => {
      var t;
      if (!n.target.matterBody) return;
      const e = vf(n), i = (ca.get(n.target.matterBody.label) ?? -1 / 0) >= Math.floor(e.y2);
      (t = n.onUpdatePosition) == null || t.call(n, e.x1, e.y1, i);
    });
  });
}, uT = (n) => {
  cn.Engine.update(Oi, n);
}, sl = (n) => {
  if (n.rectangle)
    n.target.matterBody = cn.Bodies.rectangle(
      n.rectangle.x + n.rectangle.width / 2,
      n.rectangle.y + n.rectangle.height / 2,
      n.rectangle.width,
      n.rectangle.height,
      _f(n)
    );
  else if (n.circle)
    n.target.matterBody = cn.Bodies.circle(
      n.circle.x,
      n.circle.y,
      n.circle.radius,
      _f(n)
    );
  else
    throw new Error("No body specification provided");
  _r.set(n.target.matterBody.label, n), n.onUpdatePosition && _u.set(n.target.matterBody.label, n), cn.Composite.add(Oi.world, n.target.matterBody), n.movement && vu(n.target, n.movement);
}, dT = (n) => {
  n.matterBody && (cn.Composite.remove(Oi.world, n.matterBody), _r.delete(n.matterBody.label), ca.delete(n.matterBody.label), _u.delete(n.matterBody.label));
}, vu = (n, t) => {
  n.matterBody && t.linearMovement && cn.Body.setVelocity(n.matterBody, t.linearMovement.velocity);
}, yf = (n, t, e) => {
  n.matterBody && cn.Body.setPosition(n.matterBody, {
    x: n.matterBody.position.x + t,
    y: n.matterBody.position.y + e
  });
}, _f = (n) => {
  var t;
  return Qo++, n.surface ? {
    isStatic: !0,
    label: Qo.toString(),
    inertia: 1 / 0,
    inverseInertia: 0,
    restitution: 0
  } : (t = n.movement) != null && t.linearMovement ? {
    friction: 0,
    frictionAir: 0,
    frictionStatic: 0,
    inertia: 1 / 0,
    inverseInertia: 0,
    restitution: 0,
    label: Qo.toString()
  } : {
    isStatic: !0,
    friction: 0,
    frictionAir: 0,
    frictionStatic: 0,
    restitution: 0,
    isSensor: !0,
    label: Qo.toString()
  };
}, vf = (n) => n.target.matterBody ? n.rectangle ? {
  x1: n.target.matterBody.position.x - n.rectangle.width / 2,
  y1: n.target.matterBody.position.y - n.rectangle.height / 2,
  x2: n.target.matterBody.position.x + n.rectangle.width / 2,
  y2: n.target.matterBody.position.y + n.rectangle.height / 2
} : n.circle ? {
  x1: n.target.matterBody.position.x - n.circle.radius,
  y1: n.target.matterBody.position.y - n.circle.radius,
  x2: n.target.matterBody.position.x + n.circle.radius,
  y2: n.target.matterBody.position.y + n.circle.radius
} : { x1: 0, y1: 0, x2: 0, y2: 0 } : { x1: 0, y1: 0, x2: 0, y2: 0 };
class ol {
  constructor(t, e) {
    Ee(this, "_props"), Ee(this, "_object"), Ee(this, "_parent", null), Ee(this, "_bindings", []), Ee(this, "_animations", []), this._props = e, this._object = t, this.hitArea = this.props.hitArea, this._createEvents(), this._setOrientationProperties(), this._positionToScreen(), (this.props.animations ?? []).forEach((i) => this.animate(i));
  }
  _registerToSignal(t, e) {
    this._bindings.push(Ss(t, e.bind(this)));
  }
  _unregisterFromSignal(t) {
    for (let e = 0; e < this._bindings.length; e++)
      this._bindings[e].name === t && (ba(t, this._bindings[e].binding), this._bindings.splice(e, 1), e--);
  }
  get props() {
    return this._props;
  }
  get object() {
    return this._object;
  }
  get x() {
    return this.object.x;
  }
  set x(t) {
    this.object.x = t;
  }
  get y() {
    return this.object.y;
  }
  set y(t) {
    this.object.y = t;
  }
  get position() {
    return this.object.position;
  }
  set position(t) {
    this.object.position = t;
  }
  get globalPosition() {
    return this.object.toGlobal({ x: 0, y: 0 });
  }
  set scale(t) {
    this.object.scale = t;
  }
  get scale() {
    return this.object.scale;
  }
  get scaleX() {
    return this.object.scale.x;
  }
  set scaleX(t) {
    this.object.scale.x = t;
  }
  get scaleY() {
    return this.object.scale.y;
  }
  set scaleY(t) {
    this.object.scale.y = t;
  }
  get width() {
    return this.object.width;
  }
  set width(t) {
    this.object.width = t;
  }
  get height() {
    return this.object.height;
  }
  set height(t) {
    this.object.height = t;
  }
  get alpha() {
    return this.object.alpha;
  }
  set alpha(t) {
    this.object.alpha = t;
  }
  get visible() {
    return this.object.visible;
  }
  set visible(t) {
    this.object.visible = t;
  }
  get label() {
    return this.object.label;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  get interactive() {
    return this.object.interactive ?? !1;
  }
  set interactive(t) {
    this.object.interactive = t;
  }
  get rotation() {
    return this.object.rotation;
  }
  set rotation(t) {
    this.object.rotation = t;
  }
  get tint() {
    return this.object.tint;
  }
  set tint(t) {
    this.object.tint = t;
  }
  get zIndex() {
    return this.object.zIndex;
  }
  set zIndex(t) {
    this.object.zIndex = t;
  }
  set hitArea(t) {
    t != null && t.circle ? this.object.hitArea = new Za(
      t.circle.x,
      t.circle.y,
      t.circle.radius
    ) : t != null && t.roundedRectangle ? this.object.hitArea = new $a(
      t.roundedRectangle.x,
      t.roundedRectangle.y,
      t.roundedRectangle.width,
      t.roundedRectangle.height,
      t.roundedRectangle.borderRadius
    ) : t != null && t.rectangle ? this.object.hitArea = new Wt(
      t.rectangle.x,
      t.rectangle.y,
      t.rectangle.width,
      t.rectangle.height
    ) : t != null && t.polygon ? this.object.hitArea = new vr(t.polygon.points) : this.object.hitArea = null;
  }
  animate(t) {
    return this._createAnimation(this, t);
  }
  getAnimation(t) {
    return this._animations.find((e) => e.name === t);
  }
  stopAnimations() {
    this._animations.forEach((t) => t.stop()), this._animations = [];
  }
  finishAnimations() {
    this._animations.forEach((t) => t.finish());
  }
  delay(t) {
    return this._createAnimation(
      { x: 0 },
      {
        from: { x: 0 },
        to: { x: 1 },
        duration: t
      }
    );
  }
  destroy() {
    if (this.parent) {
      this.parent.removeComponent(this);
      return;
    }
    dT(this), this._bindings.forEach(
      ({ name: t, binding: e }) => ba(t, e)
    ), this._bindings = [], this.stopAnimations(), this.parent = null, this.object.destroy();
  }
  _positionToScreen() {
    var t, e, i, r;
    this.props.horizontalAlignment === "center" ? this.x = st.screen.width / 2 + (((t = this.props.margin) == null ? void 0 : t.x) ?? 0) : this.props.horizontalAlignment === "right" && (this.x = st.screen.width + (((e = this.props.margin) == null ? void 0 : e.x) ?? 0)), this.props.verticalAlignment === "center" ? this.y = st.screen.height / 2 + (((i = this.props.margin) == null ? void 0 : i.y) ?? 0) : this.props.verticalAlignment === "bottom" && (this.y = st.screen.height + (((r = this.props.margin) == null ? void 0 : r.y) ?? 0));
  }
  _setOrientationProperties() {
    if (!this.props.landscape && !this.props.portrait) return;
    const t = this.props[st.screen.orientation];
    for (const e in t)
      this[e] = t[e];
  }
  async _createAnimation(t, e) {
    const i = new Xr(e);
    this._animations.push(i), await i.start(t);
    const r = this._animations.indexOf(i);
    this._animations.splice(r, 1);
  }
  _createEvents() {
    var t, e, i;
    const r = [
      this.props.horizontalAlignment || this.props.verticalAlignment ? this._positionToScreen.bind(this) : null,
      this.props.onResize,
      (t = this._onResize) == null ? void 0 : t.bind(this)
    ].filter(Boolean);
    r.length > 0 && this._registerToSignal(W.signals.onResize, () => {
      r.forEach((a) => a(this));
    });
    const s = [
      this.props.landscape || this.props.portrait ? this._setOrientationProperties.bind(this) : null,
      this.props.onOrientationChange,
      (e = this._onOrientationChange) == null ? void 0 : e.bind(this)
    ].filter(Boolean);
    s.length > 0 && this._registerToSignal(W.signals.onOrientationChange, () => {
      s.forEach((a) => a(this));
    });
    const o = [
      this.props.onTick,
      (i = this._onTick) == null ? void 0 : i.bind(this)
    ].filter(Boolean);
    o.length > 0 && this._registerToSignal(W.signals.onTick, () => {
      o.forEach((a) => a(this));
    }), (this._onClick || this.props.onClick) && this.object.on("pointerdown", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onClick) == null || h.call(l, this), (c = this._onClick) == null || c.call(this);
    }), (this._onPointerUp || this.props.onPointerUp) && this.object.on("pointerup", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerUp) == null || h.call(l, this), (c = this._onPointerUp) == null || c.call(this);
    }), (this._onPointerEnter || this.props.onPointerEnter) && this.object.on("pointerenter", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerEnter) == null || h.call(l, this), (c = this._onPointerEnter) == null || c.call(this);
    }), (this._onPointerOut || this.props.onPointerOut) && this.object.on("pointerout", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerOut) == null || h.call(l, this), (c = this._onPointerOut) == null || c.call(this);
    });
  }
}
let Ns;
const Fn = /* @__PURE__ */ new Map(), pT = () => {
  Ns = vn.get("audio/sounds.mp3");
  const n = vn.get("audio/sounds.json");
  Ns.muted = st.muted, Ns.addSprites(n);
}, Ki = async (n, t = {}) => {
  const { loop: e = !1, volume: i = 1 } = t, r = await Ns.play({
    sprite: n,
    loop: e,
    volume: i,
    complete: () => Fn.delete(n)
  });
  Fn.set(n, r);
}, xu = async (n, t) => {
  const {
    fromVolume: e = 0.1,
    toVolume: i = 1,
    fadeDuration: r,
    loop: s = !1
  } = t;
  await Ki(n, { loop: s, volume: i }), await new Xr({
    duration: r,
    from: { volume: e },
    to: { volume: i }
  }).start(Fn.get(n));
}, fT = (n) => {
  var t, e;
  (t = Fn.get(n)) == null || t.stop(), (e = Fn.get(n)) == null || e.destroy(), Fn.delete(n);
}, bu = async (n, t) => {
  const e = Fn.get(n);
  if (!e) return;
  const { fadeDuration: i } = t;
  await new Xr({
    duration: i,
    from: { volume: e.volume },
    to: { volume: 0 }
  }).start(e), fT(n);
}, mT = (n) => {
  Ns.muted = n;
}, gT = () => {
  for (const [n, t] of Fn)
    t.paused = !0;
}, yT = () => {
  for (const [n, t] of Fn)
    t.paused = !1;
}, al = (n) => ({
  label: n.label,
  position: n.position,
  anchor: n.anchor,
  scale: n.scale,
  rotation: n.rotation,
  width: n.width,
  height: n.height,
  alpha: n.alpha,
  interactive: n.interactive,
  cursor: n.cursor,
  visible: n.visible,
  tint: n.tint,
  zIndex: n.zIndex
});
let Ky;
const xf = /* @__PURE__ */ new Map(), _T = (n) => {
  Ky = n;
}, vT = (n) => {
  let t;
  if (n.rectangle)
    t = new Di().rect(
      n.rectangle.x,
      n.rectangle.y,
      n.rectangle.width,
      n.rectangle.height
    );
  else if (n.roundedRectangle)
    t = new Di().roundRect(
      n.roundedRectangle.x,
      n.roundedRectangle.y,
      n.roundedRectangle.width,
      n.roundedRectangle.height,
      n.roundedRectangle.borderRadius
    );
  else if (n.circle)
    t = new Di().circle(
      n.circle.x,
      n.circle.y,
      n.circle.radius
    );
  else if (n.polygon)
    t = new Di().poly(n.polygon.points);
  else
    throw new Error("Invalid shape type");
  return t = t.fill(n.fillColor), n.strokeColor != null && (t = t.stroke({
    color: n.strokeColor,
    width: n.strokeWidth ?? 0
  })), t;
}, Ia = (n) => {
  const t = JSON.stringify(n);
  let e = xf.get(t);
  if (e) return e;
  if (typeof n == "string") return ot.from(n);
  const i = vT(n);
  return e = tu.create({
    width: i.width,
    height: i.height
  }), Ky.render({ container: i, target: e }), xf.set(t, e), e;
};
class Le extends ol {
  constructor(t) {
    super(
      new Ir({
        ...al(t),
        texture: Ia(t.resource)
      }),
      t
    );
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get originalWidth() {
    return this.object.texture.width;
  }
  get originalHeight() {
    return this.object.texture.height;
  }
  set texture(t) {
    this.object.texture = Ia(t);
  }
}
class ll extends Le {
  constructor(t) {
    super(t), Ee(this, "_pointerOver", !1), Ee(this, "_enabled", !0);
  }
  get props() {
    return super.props;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled !== t && (this._enabled = t, this._setCurrentTexture());
  }
  get pointerOver() {
    return this._pointerOver;
  }
  _onPointerEnter() {
    this._pointerOver = !0, this._setCurrentTexture();
  }
  _onPointerOut() {
    this._pointerOver = !1, this._setCurrentTexture();
  }
  async _onClick() {
    Ki(W.sounds.click), this.texture = this.enabled ? this.props.resource : this.props.disabledResource, await this.delay(0.1), this._setCurrentTexture();
  }
  _setCurrentTexture() {
    this.enabled ? this.pointerOver ? this.texture = this.props.hoverResource : this.texture = this.props.resource : this.texture = this.props.disabledResource;
  }
}
class Je extends ol {
  constructor(t) {
    super(
      new Ie({
        ...al(t),
        sortableChildren: t.sortableChildren
      }),
      t
    ), Ee(this, "_components", []), this.addComponents(t.components ?? []);
  }
  get components() {
    return this._components;
  }
  get sortableChildren() {
    return this.object.sortableChildren;
  }
  set sortableChildren(t) {
    this.object.sortableChildren = t;
  }
  addComponent(t) {
    return this.components.push(t), this.object.addChild(t.object), t.parent = this, t;
  }
  addComponents(t) {
    t.forEach((e) => this.addComponent(e));
  }
  getComponent(t) {
    return this.components.find((e) => e.label === t);
  }
  removeComponent(t) {
    const e = this.components.indexOf(t);
    e >= 0 && (this.components[e].parent = null, this.components[e].destroy(), this.components.splice(e, 1));
  }
  removeComponents() {
    this.components.forEach((t) => {
      t.parent = null, t.destroy();
    }), this._components = [];
  }
  destroy() {
    this.removeComponents(), super.destroy();
  }
  _positionToScreen() {
    var t, e, i, r;
    this.props.horizontalAlignment === "center" ? this.x = (st.screen.width - (this.props.width ?? 0)) / 2 + (((t = this.props.margin) == null ? void 0 : t.x) ?? 0) : this.props.horizontalAlignment === "right" && (this.x = st.screen.width - (this.props.width ?? 0) + (((e = this.props.margin) == null ? void 0 : e.x) ?? 0)), this.props.verticalAlignment === "center" ? this.y = (st.screen.height - (this.props.height ?? 0)) / 2 + (((i = this.props.margin) == null ? void 0 : i.y) ?? 0) : this.props.verticalAlignment === "bottom" && (this.y = st.screen.height - (this.props.height ?? 0) + (((r = this.props.margin) == null ? void 0 : r.y) ?? 0));
  }
}
class Qy extends ll {
  constructor(t) {
    super(t);
  }
  get props() {
    return super.props;
  }
  async _onClick() {
    super._onClick(), window.location.href = this.props.url;
  }
}
class ro extends ol {
  constructor(t) {
    super(
      new qw({
        ...al(t),
        texture: Ia(t.resource),
        anchor: typeof t.anchor == "number" ? { x: t.anchor, y: t.anchor } : t.anchor
      }),
      t
    );
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get originalWidth() {
    return this.object.texture.width;
  }
  get originalHeight() {
    return this.object.texture.height;
  }
  get tileScale() {
    return this.object.tileScale;
  }
  set tileScale(t) {
    this.object.tileScale = t;
  }
  get tilePosition() {
    return this.object.tilePosition;
  }
  set tilePosition(t) {
    this.object.tilePosition = t;
  }
  set texture(t) {
    this.object.texture = Ia(t);
  }
}
class Jy extends ro {
  constructor(t) {
    super(t), this._onResize();
  }
  _onResize() {
    this.width = st.screen.width, this.height = st.screen.height;
    const t = st.screen.height / this.originalHeight;
    this.tileScale = { x: t, y: t };
  }
}
class Zy extends Jy {
  _onTick() {
    this.tilePosition.x--;
  }
}
class Qt extends ol {
  constructor(t) {
    const e = {
      ...al(t),
      text: t.text,
      style: {
        fontFamily: t.fontFamily,
        fontSize: t.fontSize,
        fill: t.textColor,
        lineHeight: t.lineHeight,
        wordWrap: t.wordWrap,
        wordWrapWidth: t.wordWrapWidth,
        align: t.align,
        fontWeight: t.fontWeight ?? "normal",
        fontStyle: t.fontStyle ?? "normal",
        letterSpacing: t.letterSpacing ?? 0,
        stroke: t.strokeColor && {
          color: t.strokeColor,
          width: t.strokeWidth
        }
      }
    };
    super(t.bitmap ? new Yw(e) : new Ww(e), t);
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get fontSize() {
    return this.object.style.fontSize;
  }
  set fontSize(t) {
    this.object.style.fontSize = t;
  }
  get wordWrapWidth() {
    return this.object.style.wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this.object.style.wordWrapWidth = t;
  }
  get fontWeight() {
    return this.object.style.fontWeight;
  }
  set fontWeight(t) {
    this.object.style.fontWeight = t;
  }
  get fontStyle() {
    return this.object.style.fontStyle;
  }
  set fontStyle(t) {
    this.object.style.fontStyle = t;
  }
  get align() {
    return this.object.style.align;
  }
  set align(t) {
    this.object.style.align = t;
  }
  get text() {
    return this.object.text;
  }
  set text(t) {
    this.object.text = t;
  }
}
class xT extends ll {
  constructor(t) {
    super(t), Ee(this, "_originalProps"), this._originalProps = structuredClone(t), this._setResources();
  }
  get props() {
    return super.props;
  }
  async _onClick() {
    localStorage.setItem("muted", st.muted ? "false" : "true"), st.muted = !st.muted, mT(st.muted), this._setResources(), super._onClick();
  }
  _setResources() {
    st.muted ? (this.props.resource = this._originalProps.mutedResource, this.props.hoverResource = this._originalProps.mutedHoverResource, this.props.disabledResource = this._originalProps.mutedDisabledResource) : (this.props.resource = this._originalProps.resource, this.props.hoverResource = this._originalProps.hoverResource, this.props.disabledResource = this._originalProps.disabledResource), this._setCurrentTexture();
  }
}
class bT extends Je {
  constructor(t) {
    super({
      ...t,
      interactive: !0,
      cursor: "text"
    }), Ee(this, "_input", null), Ee(this, "_inputEventAbort", null), Ee(this, "_text", "");
    const { height: e } = this.addComponent(
      new Le({
        label: "bg",
        resource: this.props.background
      })
    ), i = this.addComponent(
      new Qt({
        label: "text",
        position: { x: this.props.padding ?? 0, y: e / 2 },
        anchor: { x: 0, y: 0.5 },
        text: this.props.text ?? "",
        fontFamily: this.props.fontFamily,
        fontSize: this.props.fontSize,
        fontWeight: this.props.fontWeight,
        textColor: this.props.textColor,
        strokeColor: this.props.strokeColor,
        strokeWidth: this.props.strokeWidth,
        letterSpacing: this.props.letterSpacing
      })
    );
    this.addComponent(
      new Le({
        label: "caret",
        position: { x: i.x + i.width + 2, y: e / 2 },
        anchor: { x: 0, y: 0.5 },
        visible: !1,
        resource: {
          rectangle: {
            x: 0,
            y: 0,
            width: 2,
            height: e - (this.props.padding ?? 0) * 2
          },
          fillColor: this.props.textColor
        },
        animations: [
          {
            from: { alpha: 1 },
            to: { alpha: 0 },
            duration: 0.4,
            repeat: -1,
            revert: !0
          }
        ]
      })
    ), this._text = this.props.text ?? "";
  }
  get props() {
    return super.props;
  }
  get text() {
    return this._text;
  }
  set text(t) {
    var e, i;
    if (this._text === t) return;
    this._text = t;
    const r = this.getComponent("text");
    r.text = this._text;
    const s = this.getComponent("caret");
    s.x = r.x + r.width + 2, (i = (e = this.props).onChange) == null || i.call(e, this._text), this._onChange && this._onChange(this._text);
  }
  destroy() {
    this._removeInput(), super.destroy();
  }
  _onClick() {
    this._createInput(), setTimeout(() => {
      this._input && (this._input.focus(), this.getComponent("caret").visible = !0, setTimeout(() => {
        this._input && (this._input.style.left = "-9999px");
      }, 100));
    }, 100);
  }
  _createInput() {
    if (this._input) return;
    const t = W.gameContainer.querySelector("canvas");
    if (!t) return;
    const { x: e, y: i } = this.globalPosition, { width: r, height: s } = this.getComponent("bg"), o = parseFloat(t.style.top), a = parseFloat(t.style.left), l = t.width, h = t.height, c = parseFloat(t.style.width), p = parseFloat(t.style.height), f = c / l, u = p / h, m = o + i * u, g = a + e * f, y = s * u, b = r * f;
    this._input = document.createElement("input"), this._input.type = "text", this._input.value = this.text, this._input.style.position = "fixed", this._input.style.top = `${m}px`, this._input.style.left = `${g}px`, this._input.style.width = `${b}px`, this._input.style.height = `${y}px`, this._input.style.opacity = "0", W.gameContainer.appendChild(this._input), this._inputEventAbort = new AbortController(), this._input.addEventListener("change", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("keyup", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("input", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("blur", this._blur.bind(this), {
      signal: this._inputEventAbort.signal
    });
  }
  _blur() {
    this._removeInput(), this.getComponent("caret").visible = !1;
  }
  _updateText() {
    if (!this._input) return;
    const t = this._input.value.substring(
      0,
      this.props.maxLength ?? this._input.value.length
    );
    this._input.value = t, this.text = t;
  }
  _removeInput() {
    var t;
    this._input && ((t = this._inputEventAbort) == null || t.abort(), this._input.remove(), this._input = null, this._inputEventAbort = null);
  }
}
class Kr extends Je {
  constructor(t = "Scene") {
    super({ label: t });
  }
  async init() {
  }
}
class wT extends Kr {
  async init() {
    this.addComponent(
      new Qt({
        label: "loading-text",
        text: W.loadingScene.text,
        anchor: { x: 0.5, y: 0.5 },
        fontFamily: W.loadingScene.fontFamily,
        fontSize: W.loadingScene.fontSize,
        textColor: W.loadingScene.textColor,
        horizontalAlignment: "center",
        verticalAlignment: "center"
      })
    );
  }
}
const wu = (n, t, e = 500, i = 1e3) => {
  let r = null, s = !1;
  return { start: () => {
    r != null && clearTimeout(r), r = setTimeout(() => {
      s = !0, r = null, n();
    }, e);
  }, cancel: () => {
    r != null && (clearTimeout(r), r = null), s ? r = setTimeout(() => {
      s = !1, r = null, t();
    }, i) : t();
  } };
}, AT = (n, t, e, i) => {
  const r = n.clientWidth, s = n.clientHeight;
  if (r < s) {
    const f = e;
    e = i, i = f;
  }
  const o = Math.min(
    r / e,
    s / i
  ), a = Math.floor(o * e), l = Math.floor(o * i), h = (r - a) / 2, c = (s - l) / 2;
  t.style.width = `${a}px`, t.style.height = `${l}px`, t.style.left = `${h}px`, t.style.top = `${c}px`, t.width = e, t.height = i;
  const p = e < i ? "portrait" : "landscape";
  return {
    width: e,
    height: i,
    orientation: p
  };
};
let $y;
function TT(n) {
  return $y = n, n;
}
function so() {
  return $y;
}
class _c {
  /**
   * Dezippering is removed in the future Web Audio API, instead
   * we use the `setValueAtTime` method, however, this is not available
   * in all environments (e.g., Android webview), so we fallback to the `value` setter.
   * @param param - AudioNode parameter object
   * @param value - Value to set
   * @return The value set
   */
  static setParamValue(t, e) {
    if (t.setValueAtTime) {
      const i = so().context;
      t.setValueAtTime(e, i.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }
}
class ST extends Ae {
  constructor() {
    super(...arguments), this.speed = 1, this.muted = !1, this.volume = 1, this.paused = !1;
  }
  /** Internal trigger when volume, mute or speed changes */
  refresh() {
    this.emit("refresh");
  }
  /** Internal trigger paused changes */
  refreshPaused() {
    this.emit("refreshPaused");
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    return console.warn("HTML Audio does not support filters"), null;
  }
  set filters(t) {
    console.warn("HTML Audio does not support filters");
  }
  /**
   * HTML Audio does not support `audioContext`
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    return console.warn("HTML Audio does not support audioContext"), null;
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current paused state.
   */
  togglePause() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }
  /** Destroy and don't use after this */
  destroy() {
    this.removeAllListeners();
  }
}
let ET = 0;
const vc = class extends Ae {
  /** @param parent - Parent element */
  constructor(n) {
    super(), this.id = ET++, this.init(n);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set
   * @param value - Value to set property to
   */
  set(n, t) {
    if (this[n] === void 0)
      throw new Error(`Property with name ${n} does not exist.`);
    switch (n) {
      case "speed":
        this.speed = t;
        break;
      case "volume":
        this.volume = t;
        break;
      case "paused":
        this.paused = t;
        break;
      case "loop":
        this.loop = t;
        break;
      case "muted":
        this.muted = t;
        break;
    }
    return this;
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    const { currentTime: n } = this._source;
    return n / this._duration;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(n) {
    this._paused = n, this.refreshPaused();
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPlay() {
    this._playing = !0;
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPause() {
    this._playing = !1;
  }
  /**
   * Initialize the instance.
   * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor
   */
  init(n) {
    this._playing = !1, this._duration = n.source.duration;
    const t = this._source = n.source.cloneNode(!1);
    t.src = n.parent.url, t.onplay = this._onPlay.bind(this), t.onpause = this._onPause.bind(this), n.context.on("refresh", this.refresh, this), n.context.on("refreshPaused", this.refreshPaused, this), this._media = n;
  }
  /**
   * Stop the sound playing
   * @private
   */
  _internalStop() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }
  /** Stop the sound playing */
  stop() {
    this._internalStop(), this._source && this.emit("stop");
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(n) {
    this._speed = n, this.refresh();
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(n) {
    this._volume = n, this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(n) {
    this._loop = n, this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(n) {
    this._muted = n, this.refresh();
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    return console.warn("HTML Audio does not support filters"), null;
  }
  set filters(n) {
    console.warn("HTML Audio does not support filters");
  }
  /** Call whenever the loop, speed or volume changes */
  refresh() {
    const n = this._media.context, t = this._media.parent;
    this._source.loop = this._loop || t.loop;
    const e = n.volume * (n.muted ? 0 : 1), i = t.volume * (t.muted ? 0 : 1), r = this._volume * (this._muted ? 0 : 1);
    this._source.volume = r * e * i, this._source.playbackRate = this._speed * n.speed * t.speed;
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const n = this._media.context, t = this._media.parent, e = this._paused || t.paused || n.paused;
    e !== this._pausedReal && (this._pausedReal = e, e ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({
      start: this._source.currentTime,
      end: this._end,
      volume: this._volume,
      speed: this._speed,
      loop: this._loop
    })), this.emit("pause", e));
  }
  /** Start playing the sound/ */
  play(n) {
    const { start: t, end: e, speed: i, loop: r, volume: s, muted: o } = n;
    e && console.assert(e > t, "End time is before start time"), this._speed = i, this._volume = s, this._loop = !!r, this._muted = o, this.refresh(), this.loop && e !== null && (console.warn('Looping not support when specifying an "end" time'), this.loop = !1), this._start = t, this._end = e || this._duration, this._start = Math.max(0, this._start - vc.PADDING), this._end = Math.min(this._end + vc.PADDING, this._duration), this._source.onloadedmetadata = () => {
      this._source && (this._source.currentTime = t, this._source.onloadedmetadata = null, this.emit("progress", t / this._duration, this._duration), Dn.shared.add(this._onUpdate, this));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }
  /**
   * Handle time update on sound.
   * @private
   */
  _onUpdate() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }
  /**
   * Callback when completed.
   * @private
   */
  _onComplete() {
    Dn.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }
  /** Don't use after this. */
  destroy() {
    Dn.shared.remove(this._onUpdate, this), this.removeAllListeners();
    const n = this._source;
    n && (n.onended = null, n.onplay = null, n.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[HTMLAudioInstance id=${this.id}]`;
  }
};
let t0 = vc;
t0.PADDING = 0.1;
class CT extends Ae {
  init(t) {
    this.parent = t, this._source = t.options.source || new Audio(), t.url && (this._source.src = t.url);
  }
  // Implement create
  create() {
    return new t0(this);
  }
  /**
   * If the audio media is playable (ready).
   * @readonly
   */
  get isPlayable() {
    return !!this._source && this._source.readyState === 4;
  }
  /**
   * THe duration of the media in seconds.
   * @readonly
   */
  get duration() {
    return this._source.duration;
  }
  /**
   * Reference to the context.
   * @readonly
   */
  get context() {
    return this.parent.context;
  }
  /** The collection of filters, does not apply to HTML Audio. */
  get filters() {
    return null;
  }
  set filters(t) {
    console.warn("HTML Audio does not support filters");
  }
  // Override the destroy
  destroy() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }
  /**
   * Get the audio source element.
   * @type {HTMLAudioElement}
   * @readonly
   */
  get source() {
    return this._source;
  }
  // Implement the method to being preloading
  load(t) {
    const e = this._source, i = this.parent;
    if (e.readyState === 4) {
      i.isLoaded = !0;
      const l = i.autoPlayStart();
      t && setTimeout(() => {
        t(null, i, l);
      }, 0);
      return;
    }
    if (!i.url) {
      t(new Error("sound.url or sound.source must be set"));
      return;
    }
    e.src = i.url;
    const r = () => {
      a(), i.isLoaded = !0;
      const l = i.autoPlayStart();
      t && t(null, i, l);
    }, s = () => {
      a(), t && t(new Error("Sound loading has been aborted"));
    }, o = () => {
      a();
      const l = `Failed to load audio element (code: ${e.error.code})`;
      t ? t(new Error(l)) : console.error(l);
    }, a = () => {
      e.removeEventListener("canplaythrough", r), e.removeEventListener("load", r), e.removeEventListener("abort", s), e.removeEventListener("error", o);
    };
    e.addEventListener("canplaythrough", r, !1), e.addEventListener("load", r, !1), e.addEventListener("abort", s, !1), e.addEventListener("error", o, !1), e.load();
  }
}
class PT {
  /**
   * @param parent - The parent sound
   * @param options - Data associated with object.
   */
  constructor(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start, console.assert(this.duration > 0, "End time must be after start time");
  }
  /**
   * Play the sound sprite.
   * @param {Function} [complete] - Function call when complete
   * @return Sound instance being played.
   */
  play(t) {
    return this.parent.play({
      complete: t,
      speed: this.speed || this.parent.speed,
      end: this.end,
      start: this.start,
      loop: this.loop
    });
  }
  /** Destroy and don't use after this */
  destroy() {
    this.parent = null;
  }
}
const Ra = [
  "ogg",
  "oga",
  "opus",
  "m4a",
  "mp3",
  "mpeg",
  "wav",
  "aiff",
  "wma",
  "mid",
  "caf"
], IT = [
  "audio/mpeg",
  "audio/ogg"
], ka = {};
function RT(n) {
  const t = {
    m4a: "audio/mp4",
    oga: "audio/ogg",
    opus: 'audio/ogg; codecs="opus"',
    caf: 'audio/x-caf; codecs="opus"'
  }, e = document.createElement("audio"), i = {}, r = /^no$/;
  Ra.forEach((s) => {
    const o = e.canPlayType(`audio/${s}`).replace(r, ""), a = t[s] ? e.canPlayType(t[s]).replace(r, "") : "";
    i[s] = !!o || !!a;
  }), Object.assign(ka, i);
}
RT();
let kT = 0;
class MT extends Ae {
  constructor(t) {
    super(), this.id = kT++, this._media = null, this._paused = !1, this._muted = !1, this._elapsed = 0, this.init(t);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set.
   * @param value - Value to set property to.
   */
  set(t, e) {
    if (this[t] === void 0)
      throw new Error(`Property with name ${t} does not exist.`);
    switch (t) {
      case "speed":
        this.speed = e;
        break;
      case "volume":
        this.volume = e;
        break;
      case "muted":
        this.muted = e;
        break;
      case "loop":
        this.loop = e;
        break;
      case "paused":
        this.paused = e;
        break;
    }
    return this;
  }
  /** Stops the instance, don't use after this. */
  stop() {
    this._source && (this._internalStop(), this.emit("stop"));
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(t) {
    this._speed = t, this.refresh(), this._update(!0);
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(t) {
    this._volume = t, this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(t) {
    this._muted = t, this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this.refresh();
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(t) {
    var e;
    this._filters && ((e = this._filters) == null || e.filter((i) => i).forEach((i) => i.disconnect()), this._filters = null, this._source.connect(this._gain)), this._filters = t != null && t.length ? t.slice(0) : null, this.refresh();
  }
  /** Refresh loop, volume and speed based on changes to parent */
  refresh() {
    if (!this._source)
      return;
    const t = this._media.context, e = this._media.parent;
    this._source.loop = this._loop || e.loop;
    const i = t.volume * (t.muted ? 0 : 1), r = e.volume * (e.muted ? 0 : 1), s = this._volume * (this._muted ? 0 : 1);
    _c.setParamValue(this._gain.gain, s * r * i), _c.setParamValue(this._source.playbackRate, this._speed * e.speed * t.speed), this.applyFilters();
  }
  /** Connect filters nodes to audio context */
  applyFilters() {
    var t;
    if ((t = this._filters) != null && t.length) {
      this._source.disconnect();
      let e = this._source;
      this._filters.forEach((i) => {
        e.connect(i.destination), e = i;
      }), e.connect(this._gain);
    }
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const t = this._media.context, e = this._media.parent, i = this._paused || e.paused || t.paused;
    i !== this._pausedReal && (this._pausedReal = i, i ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({
      start: this._elapsed % this._duration,
      end: this._end,
      speed: this._speed,
      loop: this._loop,
      volume: this._volume
    })), this.emit("pause", i));
  }
  /**
   * Plays the sound.
   * @param options - Play options.
   */
  play(t) {
    const { start: e, end: i, speed: r, loop: s, volume: o, muted: a, filters: l } = t;
    i && console.assert(i > e, "End time is before start time"), this._paused = !1;
    const { source: h, gain: c } = this._media.nodes.cloneBufferSource();
    this._source = h, this._gain = c, this._speed = r, this._volume = o, this._loop = !!s, this._muted = a, this._filters = l, this.refresh();
    const p = this._source.buffer.duration;
    this._duration = p, this._end = i, this._lastUpdate = this._now(), this._elapsed = e, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = i, this._source.loopStart = e, this._source.start(0, e)) : i ? this._source.start(0, e, i - e) : this._source.start(0, e), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }
  /** Start the update progress. */
  enableTicker(t) {
    Dn.shared.remove(this._updateListener, this), t && Dn.shared.add(this._updateListener, this);
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    return this._progress;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(t) {
    this._paused = t, this.refreshPaused();
  }
  /** Don't use after this. */
  destroy() {
    var t;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (t = this._filters) == null || t.forEach((e) => e.disconnect()), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[WebAudioInstance id=${this.id}]`;
  }
  /**
   * Get the current time in seconds.
   * @return Seconds since start of context
   */
  _now() {
    return this._media.context.audioContext.currentTime;
  }
  /** Callback for update listener */
  _updateListener() {
    this._update();
  }
  /** Internal update the progress. */
  _update(t = !1) {
    if (this._source) {
      const e = this._now(), i = e - this._lastUpdate;
      if (i > 0 || t) {
        const r = this._source.playbackRate.value;
        this._elapsed += i * r, this._lastUpdate = e;
        const s = this._duration;
        let o;
        if (this._source.loopStart) {
          const a = this._source.loopEnd - this._source.loopStart;
          o = (this._source.loopStart + this._elapsed % a) / s;
        } else
          o = this._elapsed % s / s;
        this._progress = o, this.emit("progress", this._progress, s);
      }
    }
  }
  /** Initializes the instance. */
  init(t) {
    this._media = t, t.context.events.on("refresh", this.refresh, this), t.context.events.on("refreshPaused", this.refreshPaused, this);
  }
  /** Stops the instance. */
  _internalStop() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
      }
      this._source = null;
    }
  }
  /** Callback when completed. */
  _onComplete() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }
}
class e0 {
  /**
   * @param input - The source audio node
   * @param output - The output audio node
   */
  constructor(t, e) {
    this._output = e, this._input = t;
  }
  /** The destination output audio node */
  get destination() {
    return this._input;
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(t) {
    if (this._filters && (this._filters.forEach((e) => {
      e && e.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      let e = null;
      t.forEach((i) => {
        e === null ? this._input.connect(i.destination) : e.connect(i.destination), e = i;
      }), e.connect(this._output);
    }
  }
  /** Cleans up. */
  destroy() {
    this.filters = null, this._input = null, this._output = null;
  }
}
const n0 = class extends e0 {
  /**
   * @param context - The audio context.
   */
  constructor(n) {
    const t = n.audioContext, e = t.createBufferSource(), i = t.createGain(), r = t.createAnalyser();
    e.connect(r), r.connect(i), i.connect(n.destination), super(r, i), this.context = n, this.bufferSource = e, this.gain = i, this.analyser = r;
  }
  /**
   * Get the script processor node.
   * @readonly
   */
  get script() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(n0.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }
  /** Cleans up. */
  destroy() {
    super.destroy(), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }
  /**
   * Clones the bufferSource. Used just before playing a sound.
   * @returns {SourceClone} The clone AudioBufferSourceNode.
   */
  cloneBufferSource() {
    const n = this.bufferSource, t = this.context.audioContext.createBufferSource();
    t.buffer = n.buffer, _c.setParamValue(t.playbackRate, n.playbackRate.value), t.loop = n.loop;
    const e = this.context.audioContext.createGain();
    return t.connect(e), e.connect(this.destination), { source: t, gain: e };
  }
  /**
   * Get buffer size of `ScriptProcessorNode`.
   * @readonly
   */
  get bufferSize() {
    return this.script.bufferSize;
  }
};
let i0 = n0;
i0.BUFFER_SIZE = 0;
class VT {
  /**
   * Re-initialize without constructing.
   * @param parent - - Instance of parent Sound container
   */
  init(t) {
    this.parent = t, this._nodes = new i0(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch (t) {
      console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
    }
    this._source = null, this.source = null;
  }
  // Implement create
  create() {
    return new MT(this);
  }
  // Implement context
  get context() {
    return this.parent.context;
  }
  // Implement isPlayable
  get isPlayable() {
    return !!this._source && !!this._source.buffer;
  }
  // Implement filters
  get filters() {
    return this._nodes.filters;
  }
  set filters(t) {
    this._nodes.filters = t;
  }
  // Implements duration
  get duration() {
    return console.assert(this.isPlayable, "Sound not yet playable, no duration"), this._source.buffer.duration;
  }
  /** Gets and sets the buffer. */
  get buffer() {
    return this._source.buffer;
  }
  set buffer(t) {
    this._source.buffer = t;
  }
  /** Get the current chained nodes object */
  get nodes() {
    return this._nodes;
  }
  // Implements load
  load(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t ? t(new Error("sound.url or sound.source must be set")) : console.error("sound.url or sound.source must be set");
  }
  /** Loads a sound using XHMLHttpRequest object. */
  async _loadUrl(t) {
    const e = this.parent.url, i = await Bt.get().fetch(e);
    this._decode(await i.arrayBuffer(), t);
  }
  /**
   * Decodes the array buffer.
   * @param arrayBuffer - From load.
   * @param {Function} callback - Callback optional
   */
  _decode(t, e) {
    const i = (r, s) => {
      if (r)
        e && e(r);
      else {
        this.parent.isLoaded = !0, this.buffer = s;
        const o = this.parent.autoPlayStart();
        e && e(null, this.parent, o);
      }
    };
    t instanceof AudioBuffer ? i(null, t) : this.parent.context.decode(t, i);
  }
}
const cr = class {
  /**
   * Create a new sound instance from source.
   * @param source - Either the path or url to the source file.
   *        or the object of options to use.
   * @return Created sound instance.
   */
  static from(n) {
    let t = {};
    typeof n == "string" ? t.url = n : n instanceof ArrayBuffer || n instanceof AudioBuffer || n instanceof HTMLAudioElement ? t.source = n : Array.isArray(n) ? t.url = n : t = n, t = {
      autoPlay: !1,
      singleInstance: !1,
      url: null,
      source: null,
      preload: !1,
      volume: 1,
      speed: 1,
      complete: null,
      loaded: null,
      loop: !1,
      ...t
    }, Object.freeze(t);
    const e = so().useLegacy ? new CT() : new VT();
    return new cr(e, t);
  }
  /**
   * Use `Sound.from`
   * @ignore
   */
  constructor(n, t) {
    this.media = n, this.options = t, this._instances = [], this._sprites = {}, this.media.init(this);
    const e = t.complete;
    this._autoPlayOptions = e ? { complete: e } : null, this.isLoaded = !1, this._preloadQueue = null, this.isPlaying = !1, this.autoPlay = t.autoPlay, this.singleInstance = t.singleInstance, this.preload = t.preload || this.autoPlay, this.url = Array.isArray(t.url) ? this.preferUrl(t.url) : t.url, this.speed = t.speed, this.volume = t.volume, this.loop = t.loop, t.sprites && this.addSprites(t.sprites), this.preload && this._preload(t.loaded);
  }
  /**
   * Internal help for resolving which file to use if there are multiple provide
   * this is especially helpful for working with bundlers (non Assets loading).
   */
  preferUrl(n) {
    const [t] = n.map((e) => ({ url: e, ext: ue.extname(e).slice(1) })).filter(({ ext: e }) => ka[e]).sort((e, i) => Ra.indexOf(e.ext) - Ra.indexOf(i.ext));
    if (!t)
      throw new Error("No supported file type found");
    return t.url;
  }
  /** Instance of the media context. */
  get context() {
    return so().context;
  }
  /** Stops all the instances of this sound from playing. */
  pause() {
    return this.isPlaying = !1, this.paused = !0, this;
  }
  /** Resuming all the instances of this sound from playing */
  resume() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }
  /** Stops all the instances of this sound from playing. */
  get paused() {
    return this._paused;
  }
  set paused(n) {
    this._paused = n, this.refreshPaused();
  }
  /** The playback rate. */
  get speed() {
    return this._speed;
  }
  set speed(n) {
    this._speed = n, this.refresh();
  }
  /** Set the filters. Only supported with WebAudio. */
  get filters() {
    return this.media.filters;
  }
  set filters(n) {
    this.media.filters = n;
  }
  /**
   * @ignore
   */
  addSprites(n, t) {
    if (typeof n == "object") {
      const i = {};
      for (const r in n)
        i[r] = this.addSprites(r, n[r]);
      return i;
    }
    console.assert(!this._sprites[n], `Alias ${n} is already taken`);
    const e = new PT(this, t);
    return this._sprites[n] = e, e;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }
  /**
   * Remove a sound sprite.
   * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.
   */
  removeSprites(n) {
    if (n) {
      const t = this._sprites[n];
      t !== void 0 && (t.destroy(), delete this._sprites[n]);
    } else
      for (const t in this._sprites)
        this.removeSprites(t);
    return this;
  }
  /** If the current sound is playable (loaded). */
  get isPlayable() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }
  /** Stops all the instances of this sound from playing. */
  stop() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (let n = this._instances.length - 1; n >= 0; n--)
      this._instances[n].stop();
    return this;
  }
  // Overloaded function
  play(n, t) {
    let e;
    if (typeof n == "string" ? e = { sprite: n, loop: this.loop, complete: t } : typeof n == "function" ? (e = {}, e.complete = n) : e = n, e = {
      complete: null,
      loaded: null,
      sprite: null,
      end: null,
      start: 0,
      volume: 1,
      speed: 1,
      muted: !1,
      loop: !1,
      ...e || {}
    }, e.sprite) {
      const r = e.sprite;
      console.assert(!!this._sprites[r], `Alias ${r} is not available`);
      const s = this._sprites[r];
      e.start = s.start + (e.start || 0), e.end = s.end, e.speed = s.speed || 1, e.loop = s.loop || e.loop, delete e.sprite;
    }
    if (e.offset && (e.start = e.offset), !this.isLoaded)
      return this._preloadQueue ? new Promise((r) => {
        this._preloadQueue.push(() => {
          r(this.play(e));
        });
      }) : (this._preloadQueue = [], this.autoPlay = !0, this._autoPlayOptions = e, new Promise((r, s) => {
        this._preload((o, a, l) => {
          this._preloadQueue.forEach((h) => h()), this._preloadQueue = null, o ? s(o) : (e.loaded && e.loaded(o, a, l), r(l));
        });
      }));
    (this.singleInstance || e.singleInstance) && this._removeInstances();
    const i = this._createInstance();
    return this._instances.push(i), this.isPlaying = !0, i.once("end", () => {
      e.complete && e.complete(this), this._onComplete(i);
    }), i.once("stop", () => {
      this._onComplete(i);
    }), i.play(e), i;
  }
  /** Internal only, speed, loop, volume change occured. */
  refresh() {
    const n = this._instances.length;
    for (let t = 0; t < n; t++)
      this._instances[t].refresh();
  }
  /** Handle changes in paused state. Internal only. */
  refreshPaused() {
    const n = this._instances.length;
    for (let t = 0; t < n; t++)
      this._instances[t].refreshPaused();
  }
  /** Gets and sets the volume. */
  get volume() {
    return this._volume;
  }
  set volume(n) {
    this._volume = n, this.refresh();
  }
  /** Gets and sets the muted flag. */
  get muted() {
    return this._muted;
  }
  set muted(n) {
    this._muted = n, this.refresh();
  }
  /** Gets and sets the looping. */
  get loop() {
    return this._loop;
  }
  set loop(n) {
    this._loop = n, this.refresh();
  }
  /** Starts the preloading of sound. */
  _preload(n) {
    this.media.load(n);
  }
  /** Gets the list of instances that are currently being played of this sound. */
  get instances() {
    return this._instances;
  }
  /** Get the map of sprites. */
  get sprites() {
    return this._sprites;
  }
  /** Get the duration of the audio in seconds. */
  get duration() {
    return this.media.duration;
  }
  /** Auto play the first instance. */
  autoPlayStart() {
    let n;
    return this.autoPlay && (n = this.play(this._autoPlayOptions)), n;
  }
  /** Removes all instances. */
  _removeInstances() {
    for (let n = this._instances.length - 1; n >= 0; n--)
      this._poolInstance(this._instances[n]);
    this._instances.length = 0;
  }
  /**
   * Sound instance completed.
   * @param instance
   */
  _onComplete(n) {
    if (this._instances) {
      const t = this._instances.indexOf(n);
      t > -1 && this._instances.splice(t, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(n);
  }
  /** Create a new instance. */
  _createInstance() {
    if (cr._pool.length > 0) {
      const n = cr._pool.pop();
      return n.init(this.media), n;
    }
    return this.media.create();
  }
  /**
   * Destroy/recycling the instance object.
   * @param instance - Instance to recycle
   */
  _poolInstance(n) {
    n.destroy(), cr._pool.indexOf(n) < 0 && cr._pool.push(n);
  }
};
let Ma = cr;
Ma._pool = [];
class oo extends e0 {
  constructor() {
    const t = window, e = new oo.AudioContext(), i = e.createDynamicsCompressor(), r = e.createAnalyser();
    r.connect(i), i.connect(e.destination), super(r, i), this.autoPause = !0, this._ctx = e, this._offlineCtx = new oo.OfflineAudioContext(
      1,
      2,
      t.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, e.sampleRate)) : 44100
    ), this.compressor = i, this.analyser = r, this.events = new Ae(), this.volume = 1, this.speed = 1, this.muted = !1, this.paused = !1, this._locked = e.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), this._locked && (this._unlock(), this._unlock = this._unlock.bind(this), document.addEventListener("mousedown", this._unlock, !0), document.addEventListener("touchstart", this._unlock, !0), document.addEventListener("touchend", this._unlock, !0)), this.onFocus = this.onFocus.bind(this), this.onBlur = this.onBlur.bind(this), globalThis.addEventListener("focus", this.onFocus), globalThis.addEventListener("blur", this.onBlur);
  }
  /** Handle mobile WebAudio context resume */
  onFocus() {
    if (!this.autoPause)
      return;
    const t = this._ctx.state;
    (t === "suspended" || t === "interrupted" || !this._locked) && (this.paused = this._pausedOnBlur, this.refreshPaused());
  }
  /** Handle mobile WebAudio context suspend */
  onBlur() {
    this.autoPause && (this._locked || (this._pausedOnBlur = this._paused, this.paused = !0, this.refreshPaused()));
  }
  /**
   * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of
   * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend
   * will fail if the user presses for too long, indicating a scroll event instead of a click event.
   *
   * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding
   * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we
   * stick with `mousedown` and `touchend`.
   */
  _unlock() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }
  /**
   * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they
   * require the first sound to be played inside of a user initiated event (touch/click).
   */
  playEmptySound() {
    const t = this._ctx.createBufferSource();
    t.buffer = this._ctx.createBuffer(1, 1, 22050), t.connect(this._ctx.destination), t.start(0, 0, 0), t.context.state === "suspended" && t.context.resume();
  }
  /**
   * Get AudioContext class, if not supported returns `null`
   * @type {AudioContext}
   * @readonly
   */
  static get AudioContext() {
    const t = window;
    return t.AudioContext || t.webkitAudioContext || null;
  }
  /**
   * Get OfflineAudioContext class, if not supported returns `null`
   * @type {OfflineAudioContext}
   * @readonly
   */
  static get OfflineAudioContext() {
    const t = window;
    return t.OfflineAudioContext || t.webkitOfflineAudioContext || null;
  }
  /** Destroy this context. */
  destroy() {
    super.destroy();
    const t = this._ctx;
    typeof t.close < "u" && t.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }
  /**
   * The WebAudio API AudioContext object.
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    return this._ctx;
  }
  /**
   * The WebAudio API OfflineAudioContext object.
   * @readonly
   * @type {OfflineAudioContext}
   */
  get offlineContext() {
    return this._offlineCtx;
  }
  /**
   * Pauses all sounds, even though we handle this at the instance
   * level, we'll also pause the audioContext so that the
   * time used to compute progress isn't messed up.
   * @default false
   */
  set paused(t) {
    t && this._ctx.state === "running" ? this._ctx.suspend() : !t && this._ctx.state === "suspended" && this._ctx.resume(), this._paused = t;
  }
  get paused() {
    return this._paused;
  }
  /** Emit event when muted, volume or speed changes */
  refresh() {
    this.events.emit("refresh");
  }
  /** Emit event when muted, volume or speed changes */
  refreshPaused() {
    this.events.emit("refreshPaused");
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current muted state.
   */
  togglePause() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }
  /**
   * Decode the audio data
   * @param arrayBuffer - Buffer from loader
   * @param callback - When completed, error and audioBuffer are parameters.
   */
  decode(t, e) {
    const i = (s) => {
      e(new Error((s == null ? void 0 : s.message) || "Unable to decode file"));
    }, r = this._offlineCtx.decodeAudioData(
      t,
      (s) => {
        e(null, s);
      },
      i
    );
    r && r.catch(i);
  }
}
class DT {
  constructor() {
    this.init();
  }
  /**
   * Re-initialize the sound library, this will
   * recreate the AudioContext. If there's a hardware-failure
   * call `close` and then `init`.
   * @return Sound instance
   */
  init() {
    return this.supported && (this._webAudioContext = new oo()), this._htmlAudioContext = new ST(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }
  /**
   * The global context to use.
   * @readonly
   */
  get context() {
    return this._context;
  }
  /**
   * Apply filters to all sounds. Can be useful
   * for setting global planning or global effects.
   * **Only supported with WebAudio.**
   * @example
   * import { sound, filters } from '@pixi/sound';
   * // Adds a filter to pan all output left
   * sound.filtersAll = [
   *     new filters.StereoFilter(-1)
   * ];
   */
  get filtersAll() {
    return this.useLegacy ? [] : this._context.filters;
  }
  set filtersAll(t) {
    this.useLegacy || (this._context.filters = t);
  }
  /**
   * `true` if WebAudio is supported on the current browser.
   */
  get supported() {
    return oo.AudioContext !== null;
  }
  /**
   * @ignore
   */
  add(t, e) {
    if (typeof t == "object") {
      const s = {};
      for (const o in t) {
        const a = this._getOptions(
          t[o],
          e
        );
        s[o] = this.add(o, a);
      }
      return s;
    }
    if (console.assert(!this._sounds[t], `Sound with alias ${t} already exists.`), e instanceof Ma)
      return this._sounds[t] = e, e;
    const i = this._getOptions(e), r = Ma.from(i);
    return this._sounds[t] = r, r;
  }
  /**
   * Internal methods for getting the options object
   * @private
   * @param source - The source options
   * @param overrides - Override default options
   * @return The construction options
   */
  _getOptions(t, e) {
    let i;
    return typeof t == "string" ? i = { url: t } : Array.isArray(t) ? i = { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? i = { source: t } : i = t, i = { ...i, ...e || {} }, i;
  }
  /**
   * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.
   */
  get useLegacy() {
    return this._useLegacy;
  }
  set useLegacy(t) {
    this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }
  /**
   * This disables auto-pause all playback when the window blurs (WebAudio only).
   * This is helpful to keep from playing sounds when the user switches tabs.
   * However, if you're running content within an iframe, this may be undesirable
   * and you should disable (set to `true`) this behavior.
   * @default false
   */
  get disableAutoPause() {
    return !this._webAudioContext.autoPause;
  }
  set disableAutoPause(t) {
    this._webAudioContext.autoPause = !t;
  }
  /**
   * Removes a sound by alias.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  remove(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }
  /**
   * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.
   */
  get volumeAll() {
    return this._context.volume;
  }
  set volumeAll(t) {
    this._context.volume = t, this._context.refresh();
  }
  /**
   * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.
   */
  get speedAll() {
    return this._context.speed;
  }
  set speedAll(t) {
    this._context.speed = t, this._context.refresh();
  }
  /**
   * Toggle paused property for all sounds.
   * @return `true` if all sounds are paused.
   */
  togglePauseAll() {
    return this._context.togglePause();
  }
  /**
   * Pauses any playing sounds.
   * @return Instance for chaining.
   */
  pauseAll() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }
  /**
   * Resumes any sounds.
   * @return Instance for chaining.
   */
  resumeAll() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }
  /**
   * Toggle muted property for all sounds.
   * @return `true` if all sounds are muted.
   */
  toggleMuteAll() {
    return this._context.toggleMute();
  }
  /**
   * Mutes all playing sounds.
   * @return Instance for chaining.
   */
  muteAll() {
    return this._context.muted = !0, this._context.refresh(), this;
  }
  /**
   * Unmutes all playing sounds.
   * @return Instance for chaining.
   */
  unmuteAll() {
    return this._context.muted = !1, this._context.refresh(), this;
  }
  /**
   * Stops and removes all sounds. They cannot be used after this.
   * @return Instance for chaining.
   */
  removeAll() {
    for (const t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }
  /**
   * Stops all sounds.
   * @return Instance for chaining.
   */
  stopAll() {
    for (const t in this._sounds)
      this._sounds[t].stop();
    return this;
  }
  /**
   * Checks if a sound by alias exists.
   * @param alias - Check for alias.
   * @param assert - Whether enable console.assert.
   * @return true if the sound exists.
   */
  exists(t, e = !1) {
    const i = !!this._sounds[t];
    return e && console.assert(i, `No sound matching alias '${t}'.`), i;
  }
  /**
   * Convenience function to check to see if any sound is playing.
   * @returns `true` if any sound is currently playing.
   */
  isPlaying() {
    for (const t in this._sounds)
      if (this._sounds[t].isPlaying)
        return !0;
    return !1;
  }
  /**
   * Find a sound by alias.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  find(t) {
    return this.exists(t, !0), this._sounds[t];
  }
  /**
   * Plays a sound.
   * @method play
   * @instance
   * @param {string} alias - The sound alias reference.
   * @param {string} sprite - The alias of the sprite to play.
   * @return {IMediaInstance|null} The sound instance, this cannot be reused
   *         after it is done playing. Returns `null` if the sound has not yet loaded.
   */
  /**
   * Plays a sound.
   * @param alias - The sound alias reference.
   * @param {PlayOptions|Function} options - The options or callback when done.
   * @return The sound instance,
   *        this cannot be reused after it is done playing. Returns a Promise if the sound
   *        has not yet loaded.
   */
  play(t, e) {
    return this.find(t).play(e);
  }
  /**
   * Stops a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  stop(t) {
    return this.find(t).stop();
  }
  /**
   * Pauses a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  pause(t) {
    return this.find(t).pause();
  }
  /**
   * Resumes a sound.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  resume(t) {
    return this.find(t).resume();
  }
  /**
   * Get or set the volume for a sound.
   * @param alias - The sound alias reference.
   * @param volume - Optional current volume to set.
   * @return The current volume.
   */
  volume(t, e) {
    const i = this.find(t);
    return e !== void 0 && (i.volume = e), i.volume;
  }
  /**
   * Get or set the speed for a sound.
   * @param alias - The sound alias reference.
   * @param speed - Optional current speed to set.
   * @return The current speed.
   */
  speed(t, e) {
    const i = this.find(t);
    return e !== void 0 && (i.speed = e), i.speed;
  }
  /**
   * Get the length of a sound in seconds.
   * @param alias - The sound alias reference.
   * @return The current duration in seconds.
   */
  duration(t) {
    return this.find(t).duration;
  }
  /**
   * Closes the sound library. This will release/destroy
   * the AudioContext(s). Can be used safely if you want to
   * initialize the sound library later. Use `init` method.
   */
  close() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }
}
const bf = (n) => {
  var t;
  const e = n.src;
  let i = (t = n == null ? void 0 : n.alias) == null ? void 0 : t[0];
  return (!i || n.src === i) && (i = ue.basename(e, ue.extname(e))), i;
}, BT = {
  extension: K.Asset,
  detection: {
    test: async () => !0,
    add: async (n) => [...n, ...Ra.filter((t) => ka[t])],
    remove: async (n) => n.filter((t) => n.includes(t))
  },
  loader: {
    name: "sound",
    extension: {
      type: [K.LoadParser],
      priority: Hn.High
    },
    /** Should we attempt to load this file? */
    test(n) {
      const t = ue.extname(n).slice(1);
      return !!ka[t] || IT.some((e) => n.startsWith(`data:${e}`));
    },
    /** Load the sound file, this is mostly handled by Sound.from() */
    async load(n, t) {
      const e = await new Promise((i, r) => Ma.from({
        ...t.data,
        url: n,
        preload: !0,
        loaded(s, o) {
          var a, l;
          s ? r(s) : i(o), (l = (a = t.data) == null ? void 0 : a.loaded) == null || l.call(a, s, o);
        }
      }));
      return so().add(bf(t), e), e;
    },
    /** Remove the sound from the library */
    async unload(n, t) {
      so().remove(bf(t));
    }
  }
};
xe.add(BT);
TT(new DT());
class OT extends Kr {
  constructor() {
    super("Pause"), this.visible = !1, this.zIndex = 1e3;
  }
  async init() {
    this.addComponent(
      new Le({
        label: "overlay",
        resource: {
          fillColor: W.pauseScene.overlayColor,
          rectangle: {
            x: 0,
            y: 0,
            width: W.screen.width,
            height: W.screen.width
          }
        },
        alpha: W.pauseScene.overlayAlpha
      })
    ), this.addComponent(
      new Qt({
        label: "title",
        text: W.pauseScene.title,
        fontFamily: W.pauseScene.fontFamily,
        fontSize: W.pauseScene.titleFontSize,
        textColor: W.pauseScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: -50 }
      })
    ), this.addComponent(
      new Qt({
        label: "subtitle",
        text: W.pauseScene.subTitle,
        fontFamily: W.pauseScene.fontFamily,
        fontSize: W.pauseScene.subTitleFontSize,
        textColor: W.pauseScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: 50 }
      })
    );
  }
}
let Se, Is = !1, Us;
const r0 = () => W.screen.width * 1 / W.screen.aspectRatio, wf = () => {
  const { width: n, height: t, orientation: e } = AT(
    W.gameContainer,
    Se.canvas,
    W.screen.width,
    r0()
  );
  (n !== st.screen.width || t !== st.screen.height) && (st.screen.width = n, st.screen.height = t, Se.renderer.resize(n, t), Pe(W.signals.onResize));
  const i = st.screen.orientation !== e;
  st.screen.orientation = e, i && Pe(W.signals.onOrientationChange);
}, FT = () => {
  const { start: n } = wu(
    () => {
      wf();
    },
    () => {
    },
    100
  );
  new ResizeObserver(() => {
    n();
  }).observe(W.gameContainer), wf();
}, LT = () => {
  let n = 0, t = 0, e = 0;
  W.debug && setInterval(() => {
    console.log(
      t === 0 ? 0 : Math.floor(e / t)
    ), t = 0, e = 0;
  }, 1e3), Se.ticker.maxFPS = W.maxFPS, Se.ticker.add((i) => {
    if (W.debug && (e += Math.floor(i.FPS), t++), !Is)
      for (n += i.deltaMS; n >= W.tickIntervalMillis; )
        Pe(W.signals.onTick), Xr.updateEngine(W.tickIntervalMillis), uT(W.tickIntervalMillis), n -= W.tickIntervalMillis;
  });
}, NT = () => {
  let n = !1;
  const { start: t, cancel: e } = wu(
    () => {
      Se.stage.eventMode = "passive";
    },
    () => {
    },
    100,
    0
  ), i = () => {
    Is && (Is = !1, Us.visible = !1, yT(), t());
  }, r = () => {
    Is || !n || (Is = !0, Us.visible = !0, Se.stage.eventMode = "none", gT(), e());
  };
  window.addEventListener(
    "focus",
    () => {
      n = !0;
    },
    { once: !0 }
  ), document.addEventListener("click", () => {
    n = !0, i();
  }), window.addEventListener("blur", () => {
    r();
  }), document.addEventListener("visibilitychange", () => {
    document.hidden && r();
  });
}, Rs = async (n) => {
  st.scene && (st.scene.destroy(), Se.stage.removeChild(st.scene.object)), st.scene = n, Se.stage.addChild(st.scene.object), await n.init();
}, UT = async () => {
  W.gameContainer.style.backgroundColor = W.colors.backgroundColor, Se = new gg(), await Se.init({
    backgroundColor: W.colors.backgroundColor,
    width: W.screen.width,
    height: r0()
  }), W.debug && (globalThis.__PIXI_APP__ = Se), W.gameContainer.appendChild(Se.canvas), Se.canvas.style.position = "absolute", _T(Se.renderer), Us = new OT(), await Us.init(), Se.stage.addChild(Us.object), Rs(new wT()), FT(), cT(), Xr.initEngine(), LT(), NT(), await Promise.all([
    new Promise(
      (n) => setTimeout(n, W.loadingScene.keepAliveTimeMS)
    ),
    (async () => {
      await vn.init({
        basePath: W.assets.basePath,
        manifest: W.assets.manifest
      }), vn.addBundle("extra", W.assets.extra), await Promise.all([
        vn.loadBundle("default"),
        vn.loadBundle("extra")
      ]), pT();
    })()
  ]), Pe(W.signals.destroyLoadingScene);
}, Kn = (n, t) => Math.floor(Math.random() * (t - n) + n), tt = {
  sounds: {
    mainLoop: "main-loop",
    menuLoop: "menu-loop",
    gameOver: "game-over",
    coin: "coin",
    playerHit: "player-hit"
  },
  signals: {
    goToIntro: "goToIntro",
    goToGame: "goToGame",
    chooseCharacter: "chooseCharacter",
    loseLifePoints: "loseLifePoints",
    gameOver: "gameOver",
    moveScreen: "moveScreen",
    updateScore: "updateScore"
  },
  lifePoints: 3,
  creditsUrl: "",
  privacyPolicyUrl: "",
  fireBaseApiKey: "",
  fireBaseAuthDomain: "",
  fireBaseProjectId: "",
  fireBaseStorageBucket: "",
  fireBaseMessagingSenderId: "",
  fireBaseAppId: ""
};
class zT extends Qt {
  constructor() {
    super({
      label: "cta",
      text: "Click to play",
      fontFamily: "PressStart2P",
      fontSize: 24,
      textColor: 13421772,
      anchor: { x: 0.5, y: 0.5 },
      alpha: 0,
      horizontalAlignment: "center",
      verticalAlignment: "center",
      animations: [
        {
          from: { alpha: 0 },
          to: { alpha: 1 },
          duration: 0.5,
          repeat: -1,
          revert: !0,
          delay: 1.5
        }
      ]
    });
  }
}
class jT extends Qt {
  constructor() {
    super({
      label: "logo",
      text: "COUPLES RUN",
      textColor: 16763904,
      fontSize: 128,
      fontFamily: "Lobster",
      anchor: { x: 0.5, y: 0 },
      position: { x: 0, y: 50 },
      strokeColor: 16711680,
      strokeWidth: 7,
      alpha: 0,
      horizontalAlignment: "center",
      landscape: {
        fontSize: 128
      },
      portrait: {
        fontSize: 86
      },
      animations: [
        {
          duration: 1,
          from: { alpha: 0, y: 0 },
          to: { alpha: 1, y: 50 },
          ease: "back.out(2)"
        }
      ]
    });
  }
  _onOrientationChange() {
    this.finishAnimations();
  }
}
const GT = 8, HT = 5;
class qT extends Le {
  constructor() {
    super({
      label: "moving-boy",
      resource: "boy/run/boy-run-1.png",
      anchor: { x: 0, y: 1 },
      position: { x: 130, y: 0 },
      scale: 2,
      verticalAlignment: "bottom",
      margin: { x: 0, y: -55 }
    });
    vt(this, "_runSprite", 0);
    vt(this, "_moveFrame", 0);
  }
  _onTick() {
    this._moveFrame++, this._moveFrame % HT === 0 && (this._moveFrame = 0, this._runSprite = (this._runSprite + 1) % GT, this.texture = `boy/run/boy-run-${this._runSprite + 1}.png`);
  }
}
const WT = 8, YT = 5;
class XT extends Le {
  constructor() {
    super({
      label: "moving-girl",
      resource: "girl/run/girl-run-1.png",
      anchor: { x: 0, y: 1 },
      position: { x: 200, y: 0 },
      scale: 2,
      verticalAlignment: "bottom",
      margin: { x: 0, y: -55 }
    });
    vt(this, "_runSprite", 0);
    vt(this, "_moveFrame", 0);
  }
  _onTick() {
    this._moveFrame++, this._moveFrame % YT === 0 && (this._moveFrame = 0, this._runSprite = (this._runSprite + 1) % WT, this.texture = `girl/run/girl-run-${this._runSprite + 1}.png`);
  }
}
const KT = 2;
class QT extends Je {
  constructor() {
    super({
      label: "moving-platform",
      components: [
        new ro({
          label: "moving-platform-top",
          resource: "platform-top.png",
          onTick: (t) => (t.tilePosition.x--, 1)
        }),
        new ro({
          label: "moving-platform-middle",
          resource: "platform-middle.png",
          onTick: (t) => {
            t.tilePosition.x--;
          }
        })
      ]
    }), this._onResize();
  }
  _onResize() {
    const t = this.getComponent(
      "moving-platform-top"
    ), e = this.getComponent(
      "moving-platform-middle"
    );
    e.width = st.screen.width, e.height = e.originalHeight * KT, e.position.y = st.screen.height - e.height, t.width = st.screen.width, t.position.y = st.screen.height - e.height - t.height;
  }
}
class JT extends Qy {
  constructor() {
    super({
      label: "credits-button",
      url: tt.creditsUrl,
      resource: "credits-button.png",
      hoverResource: "credits-button-hover.png",
      disabledResource: "credits-button.png",
      interactive: !0,
      cursor: "pointer",
      position: { x: 155, y: 24 },
      alpha: 0,
      anchor: 0.5,
      scale: 0,
      animations: [
        {
          from: { alpha: 0, scaleX: 0, scaleY: 0 },
          to: { alpha: 1, scaleX: 1, scaleY: 1 },
          duration: 0.5,
          delay: 1.7
        }
      ]
    });
  }
}
class ZT extends xT {
  constructor() {
    super({
      label: "volume-button",
      resource: "volume-on.png",
      hoverResource: "volume-on-hover.png",
      disabledResource: "volume-on.png",
      mutedResource: "volume-off.png",
      mutedHoverResource: "volume-off-hover.png",
      mutedDisabledResource: "volume-off.png",
      interactive: !0,
      cursor: "pointer",
      alpha: 0,
      position: { x: 24, y: 24 },
      scale: 0,
      anchor: 0.5,
      animations: [
        {
          from: { alpha: 0, scaleX: 0, scaleY: 0 },
          to: { alpha: 1, scaleX: 1, scaleY: 1 },
          duration: 0.5,
          delay: 1.5
        }
      ]
    });
  }
}
class $T extends Je {
  constructor() {
    super({
      label: "settings",
      horizontalAlignment: "center",
      verticalAlignment: "bottom",
      width: 230,
      height: 48,
      margin: { x: 0, y: -200 },
      components: [new ZT(), new JT()]
    });
  }
}
class tS extends Kr {
  constructor() {
    super(...arguments);
    vt(this, "_canContinue", !1);
  }
  async init() {
    this.interactive = !0, this.addComponent(
      new Zy({
        label: "city-bg",
        resource: "city-bg.png"
      })
    ), this.addComponent(new QT()), this.addComponent(new XT()), this.addComponent(new qT()), this.addComponent(new jT()), this.addComponent(new zT()), this.addComponent(new $T()), xu(tt.sounds.mainLoop, {
      loop: !0,
      toVolume: 0.3,
      fadeDuration: 0.5
    }), this.delay(2).then(() => {
      this._canContinue = !0;
    });
  }
  async _onClick() {
    this._canContinue && (this.interactive = !1, await Promise.all([
      Ki(W.sounds.click),
      bu(tt.sounds.mainLoop, { fadeDuration: 2 }),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 2
      })
    ]), Pe(tt.signals.goToIntro));
  }
}
const eS = "data:font/woff2;base64,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", nS = "data:font/woff2;base64,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", iS = `The night has fallen deep and the young(?) couple is ready to get married, but a tragedy happens. They're out of drinks in the party. They go out to get more drinks for the guests and they engage into a zombie apocalypse.

Collect as many drinks as you can to increase your score. You lose a life point each time an enemy touches you. It's game over if you lose 3 life points or you fall into a pit. Jump to avoid enemies and pits.`;
class rS extends Je {
  constructor() {
    super({
      label: "introduction-screen",
      alpha: 0
    });
    const t = this.addComponent(
      new Qt({
        label: "text",
        text: iS,
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 13421772,
        position: { x: 20, y: 20 },
        wordWrap: !0,
        wordWrapWidth: st.screen.width - 40,
        align: "justify",
        lineHeight: 40
      })
    ), e = this.addComponent(
      new ll({
        label: "continue-button",
        resource: "continue-button.png",
        hoverResource: "continue-button-hover.png",
        disabledResource: "continue-button.png",
        position: { x: 0, y: t.y + t.height + 40 },
        horizontalAlignment: "center",
        interactive: !1,
        cursor: "pointer",
        anchor: { x: 0.5, y: 0 },
        onClick: async () => {
          e.interactive = !1, await this.animate({
            from: { alpha: 1 },
            to: { alpha: 0 },
            duration: 1
          }), this.parent.showCharacterSelectionScreen();
        }
      })
    );
    this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    }).then(() => {
      e.interactive = !0;
    });
  }
  _onResize() {
    const t = this.components[0];
    t.wordWrapWidth = st.screen.width - 40;
    const e = this.components[1];
    e.y = t.y + t.height + 40;
  }
}
const pt = {
  selectedCharacter: "girl",
  started: !1,
  speed: 3,
  originalSpeed: 3,
  score: 0
};
let sS = class extends Le {
  constructor() {
    super({
      label: "boy",
      resource: "boy/boy-selection.png",
      position: { x: 224, y: 79.5 },
      anchor: { x: 0.5, y: 0.5 },
      interactive: !0,
      cursor: "pointer"
    }), this._registerToSignal(
      tt.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onClick() {
    this.interactive = !1, pt.selectedCharacter = "boy", Pe(tt.signals.chooseCharacter);
  }
  _onCharacterSelection() {
    pt.selectedCharacter !== "boy" ? this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 0, scaleY: 0 },
      duration: 0.2
    }) : this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 1.1, scaleY: 1.1 },
      duration: 0.2,
      revert: !0,
      repeat: 1
    });
  }
}, oS = class extends Le {
  constructor() {
    super({
      label: "girl",
      resource: "girl/girl-selection.png",
      position: { x: 64, y: 79.5 },
      anchor: { x: 0.5, y: 0.5 },
      interactive: !0,
      cursor: "pointer"
    }), this._registerToSignal(
      tt.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onClick() {
    this.interactive = !1, pt.selectedCharacter = "girl", Pe(tt.signals.chooseCharacter);
  }
  _onCharacterSelection() {
    pt.selectedCharacter !== "girl" ? this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 0, scaleY: 0 },
      duration: 0.2
    }) : this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 1.1, scaleY: 1.1 },
      duration: 0.2,
      revert: !0,
      repeat: 1
    });
  }
};
class aS extends Je {
  constructor() {
    super({
      label: "character-selection",
      horizontalAlignment: "center",
      width: 288,
      height: 159,
      anchor: { x: 0.5, y: 0 }
    }), this.addComponent(new oS()), this.addComponent(new sS());
  }
}
const lS = "You can make both characters jump by clicking/tapping on the screen. Anastasia can reduce her speed if you click/tap on the screen and hold it for a while. She then jumps higher when you release it. Nikos can perform a double jump if you click/tap on the screen again while jumping.";
class hS extends Je {
  constructor() {
    super({
      label: "character-selection-screen",
      alpha: 0
    });
    const t = this.addComponent(
      new Qt({
        label: "text",
        text: lS,
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 13421772,
        position: { x: 20, y: 20 },
        wordWrap: !0,
        wordWrapWidth: st.screen.width - 40,
        align: "justify",
        lineHeight: 40
      })
    ), e = this.addComponent(
      new Qt({
        label: "choose-character",
        text: "Choose Character",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        anchor: { x: 0.5, y: 0 },
        position: {
          x: 0,
          y: t.y + t.height + 40
        },
        horizontalAlignment: "center"
      })
    ), i = this.addComponent(new aS());
    i.y = e.y + e.height + 40, this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    }), this._registerToSignal(
      tt.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onResize() {
    const t = this.components[0], e = this.components[1], i = this.components[2];
    t.wordWrapWidth = st.screen.width - 40, e.y = t.y + t.height + 40, i.y = e.y + e.height + 40;
  }
  async _onCharacterSelection() {
    await Promise.all([
      Ki(W.sounds.click),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 1,
        delay: 0.3
      })
    ]), this.parent.showFormScreen();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const s0 = function(n) {
  const t = [];
  let e = 0;
  for (let i = 0; i < n.length; i++) {
    let r = n.charCodeAt(i);
    r < 128 ? t[e++] = r : r < 2048 ? (t[e++] = r >> 6 | 192, t[e++] = r & 63 | 128) : (r & 64512) === 55296 && i + 1 < n.length && (n.charCodeAt(i + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (n.charCodeAt(++i) & 1023), t[e++] = r >> 18 | 240, t[e++] = r >> 12 & 63 | 128, t[e++] = r >> 6 & 63 | 128, t[e++] = r & 63 | 128) : (t[e++] = r >> 12 | 224, t[e++] = r >> 6 & 63 | 128, t[e++] = r & 63 | 128);
  }
  return t;
}, cS = function(n) {
  const t = [];
  let e = 0, i = 0;
  for (; e < n.length; ) {
    const r = n[e++];
    if (r < 128)
      t[i++] = String.fromCharCode(r);
    else if (r > 191 && r < 224) {
      const s = n[e++];
      t[i++] = String.fromCharCode((r & 31) << 6 | s & 63);
    } else if (r > 239 && r < 365) {
      const s = n[e++], o = n[e++], a = n[e++], l = ((r & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
      t[i++] = String.fromCharCode(55296 + (l >> 10)), t[i++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = n[e++], o = n[e++];
      t[i++] = String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | o & 63);
    }
  }
  return t.join("");
}, o0 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(n, t) {
    if (!Array.isArray(n))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const e = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = [];
    for (let r = 0; r < n.length; r += 3) {
      const s = n[r], o = r + 1 < n.length, a = o ? n[r + 1] : 0, l = r + 2 < n.length, h = l ? n[r + 2] : 0, c = s >> 2, p = (s & 3) << 4 | a >> 4;
      let f = (a & 15) << 2 | h >> 6, u = h & 63;
      l || (u = 64, o || (f = 64)), i.push(e[c], e[p], e[f], e[u]);
    }
    return i.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(n, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? btoa(n) : this.encodeByteArray(s0(n), t);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(n, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? atob(n) : cS(this.decodeStringToByteArray(n, t));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(n, t) {
    this.init_();
    const e = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = [];
    for (let r = 0; r < n.length; ) {
      const s = e[n.charAt(r++)], a = r < n.length ? e[n.charAt(r)] : 0;
      ++r;
      const h = r < n.length ? e[n.charAt(r)] : 64;
      ++r;
      const p = r < n.length ? e[n.charAt(r)] : 64;
      if (++r, s == null || a == null || h == null || p == null)
        throw new uS();
      const f = s << 2 | a >> 4;
      if (i.push(f), h !== 64) {
        const u = a << 4 & 240 | h >> 2;
        if (i.push(u), p !== 64) {
          const m = h << 6 & 192 | p;
          i.push(m);
        }
      }
    }
    return i;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let n = 0; n < this.ENCODED_VALS.length; n++)
        this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n), this.charToByteMap_[this.byteToCharMap_[n]] = n, this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n, n >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n);
    }
  }
};
class uS extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const dS = function(n) {
  const t = s0(n);
  return o0.encodeByteArray(t, !0);
}, Va = function(n) {
  return dS(n).replace(/\./g, "");
}, pS = function(n) {
  try {
    return o0.decodeString(n, !0);
  } catch (t) {
    console.error("base64Decode failed: ", t);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fS() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mS = () => fS().__FIREBASE_DEFAULTS__, gS = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const n = process.env.__FIREBASE_DEFAULTS__;
  if (n)
    return JSON.parse(n);
}, yS = () => {
  if (typeof document > "u")
    return;
  let n;
  try {
    n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const t = n && pS(n[1]);
  return t && JSON.parse(t);
}, Au = () => {
  try {
    return mS() || gS() || yS();
  } catch (n) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
    return;
  }
}, _S = (n) => {
  var t, e;
  return (e = (t = Au()) === null || t === void 0 ? void 0 : t.emulatorHosts) === null || e === void 0 ? void 0 : e[n];
}, vS = (n) => {
  const t = _S(n);
  if (!t)
    return;
  const e = t.lastIndexOf(":");
  if (e <= 0 || e + 1 === t.length)
    throw new Error(`Invalid host ${t} with no separate hostname and port!`);
  const i = parseInt(t.substring(e + 1), 10);
  return t[0] === "[" ? [t.substring(1, e - 1), i] : [t.substring(0, e), i];
}, a0 = () => {
  var n;
  return (n = Au()) === null || n === void 0 ? void 0 : n.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xS {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(t) {
    return (e, i) => {
      e ? this.reject(e) : this.resolve(i), typeof t == "function" && (this.promise.catch(() => {
      }), t.length === 1 ? t(e) : t(e, i));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bS(n, t) {
  if (n.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const e = {
    alg: "none",
    type: "JWT"
  }, i = t || "demo-project", r = n.iat || 0, s = n.sub || n.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const o = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${i}`,
    aud: i,
    iat: r,
    exp: r + 3600,
    auth_time: r,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, n);
  return [
    Va(JSON.stringify(e)),
    Va(JSON.stringify(o)),
    ""
  ].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wS() {
  return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function AS() {
  var n;
  const t = (n = Au()) === null || n === void 0 ? void 0 : n.forceEnvironment;
  if (t === "node")
    return !0;
  if (t === "browser")
    return !1;
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch {
    return !1;
  }
}
function TS() {
  return !AS() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
function SS() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function ES() {
  return new Promise((n, t) => {
    try {
      let e = !0;
      const i = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(i);
      r.onsuccess = () => {
        r.result.close(), e || self.indexedDB.deleteDatabase(i), n(!0);
      }, r.onupgradeneeded = () => {
        e = !1;
      }, r.onerror = () => {
        var s;
        t(((s = r.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (e) {
      t(e);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CS = "FirebaseError";
class Qr extends Error {
  constructor(t, e, i) {
    super(e), this.code = t, this.customData = i, this.name = CS, Object.setPrototypeOf(this, Qr.prototype), Error.captureStackTrace && Error.captureStackTrace(this, l0.prototype.create);
  }
}
class l0 {
  constructor(t, e, i) {
    this.service = t, this.serviceName = e, this.errors = i;
  }
  create(t, ...e) {
    const i = e[0] || {}, r = `${this.service}/${t}`, s = this.errors[t], o = s ? PS(s, i) : "Error", a = `${this.serviceName}: ${o} (${r}).`;
    return new Qr(r, a, i);
  }
}
function PS(n, t) {
  return n.replace(IS, (e, i) => {
    const r = t[i];
    return r != null ? String(r) : `<${i}?>`;
  });
}
const IS = /\{\$([^}]+)}/g;
function xc(n, t) {
  if (n === t)
    return !0;
  const e = Object.keys(n), i = Object.keys(t);
  for (const r of e) {
    if (!i.includes(r))
      return !1;
    const s = n[r], o = t[r];
    if (Af(s) && Af(o)) {
      if (!xc(s, o))
        return !1;
    } else if (s !== o)
      return !1;
  }
  for (const r of i)
    if (!e.includes(r))
      return !1;
  return !0;
}
function Af(n) {
  return n !== null && typeof n == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Or(n) {
  return n && n._delegate ? n._delegate : n;
}
class ao {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(t, e, i) {
    this.name = t, this.instanceFactory = e, this.type = i, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(t) {
    return this.instantiationMode = t, this;
  }
  setMultipleInstances(t) {
    return this.multipleInstances = t, this;
  }
  setServiceProps(t) {
    return this.serviceProps = t, this;
  }
  setInstanceCreatedCallback(t) {
    return this.onInstanceCreated = t, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ri = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RS {
  constructor(t, e) {
    this.name = t, this.container = e, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(t) {
    const e = this.normalizeInstanceIdentifier(t);
    if (!this.instancesDeferred.has(e)) {
      const i = new xS();
      if (this.instancesDeferred.set(e, i), this.isInitialized(e) || this.shouldAutoInitialize())
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: e
          });
          r && i.resolve(r);
        } catch {
        }
    }
    return this.instancesDeferred.get(e).promise;
  }
  getImmediate(t) {
    var e;
    const i = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier), r = (e = t == null ? void 0 : t.optional) !== null && e !== void 0 ? e : !1;
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: i
        });
      } catch (s) {
        if (r)
          return null;
        throw s;
      }
    else {
      if (r)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(t) {
    if (t.name !== this.name)
      throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = t, !!this.shouldAutoInitialize()) {
      if (MS(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: Ri });
        } catch {
        }
      for (const [e, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(e);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          i.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(t = Ri) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const t = Array.from(this.instances.values());
    await Promise.all([
      ...t.filter((e) => "INTERNAL" in e).map((e) => e.INTERNAL.delete()),
      ...t.filter((e) => "_delete" in e).map((e) => e._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(t = Ri) {
    return this.instances.has(t);
  }
  getOptions(t = Ri) {
    return this.instancesOptions.get(t) || {};
  }
  initialize(t = {}) {
    const { options: e = {} } = t, i = this.normalizeInstanceIdentifier(t.instanceIdentifier);
    if (this.isInitialized(i))
      throw Error(`${this.name}(${i}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: i,
      options: e
    });
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s);
      i === a && o.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(t, e) {
    var i;
    const r = this.normalizeInstanceIdentifier(e), s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set();
    s.add(t), this.onInitCallbacks.set(r, s);
    const o = this.instances.get(r);
    return o && t(o, r), () => {
      s.delete(t);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(t, e) {
    const i = this.onInitCallbacks.get(e);
    if (i)
      for (const r of i)
        try {
          r(t, e);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: t, options: e = {} }) {
    let i = this.instances.get(t);
    if (!i && this.component && (i = this.component.instanceFactory(this.container, {
      instanceIdentifier: kS(t),
      options: e
    }), this.instances.set(t, i), this.instancesOptions.set(t, e), this.invokeOnInitCallbacks(i, t), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, t, i);
      } catch {
      }
    return i || null;
  }
  normalizeInstanceIdentifier(t = Ri) {
    return this.component ? this.component.multipleInstances ? t : Ri : t;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function kS(n) {
  return n === Ri ? void 0 : n;
}
function MS(n) {
  return n.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VS {
  constructor(t) {
    this.name = t, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(t) {
    const e = this.getProvider(t.name);
    if (e.isComponentSet())
      throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
    e.setComponent(t);
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(t) {
    if (this.providers.has(t))
      return this.providers.get(t);
    const e = new RS(t, this);
    return this.providers.set(t, e), e;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ut;
(function(n) {
  n[n.DEBUG = 0] = "DEBUG", n[n.VERBOSE = 1] = "VERBOSE", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.SILENT = 5] = "SILENT";
})(ut || (ut = {}));
const DS = {
  debug: ut.DEBUG,
  verbose: ut.VERBOSE,
  info: ut.INFO,
  warn: ut.WARN,
  error: ut.ERROR,
  silent: ut.SILENT
}, BS = ut.INFO, OS = {
  [ut.DEBUG]: "log",
  [ut.VERBOSE]: "log",
  [ut.INFO]: "info",
  [ut.WARN]: "warn",
  [ut.ERROR]: "error"
}, FS = (n, t, ...e) => {
  if (t < n.logLevel)
    return;
  const i = (/* @__PURE__ */ new Date()).toISOString(), r = OS[t];
  if (r)
    console[r](`[${i}]  ${n.name}:`, ...e);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
};
class h0 {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(t) {
    this.name = t, this._logLevel = BS, this._logHandler = FS, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(t) {
    if (!(t in ut))
      throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
    this._logLevel = t;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(t) {
    this._logLevel = typeof t == "string" ? DS[t] : t;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(t) {
    if (typeof t != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = t;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(t) {
    this._userLogHandler = t;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, ut.DEBUG, ...t), this._logHandler(this, ut.DEBUG, ...t);
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, ut.VERBOSE, ...t), this._logHandler(this, ut.VERBOSE, ...t);
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, ut.INFO, ...t), this._logHandler(this, ut.INFO, ...t);
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, ut.WARN, ...t), this._logHandler(this, ut.WARN, ...t);
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, ut.ERROR, ...t), this._logHandler(this, ut.ERROR, ...t);
  }
}
const LS = (n, t) => t.some((e) => n instanceof e);
let Tf, Sf;
function NS() {
  return Tf || (Tf = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function US() {
  return Sf || (Sf = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const c0 = /* @__PURE__ */ new WeakMap(), bc = /* @__PURE__ */ new WeakMap(), u0 = /* @__PURE__ */ new WeakMap(), Ah = /* @__PURE__ */ new WeakMap(), Tu = /* @__PURE__ */ new WeakMap();
function zS(n) {
  const t = new Promise((e, i) => {
    const r = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", o);
    }, s = () => {
      e(ni(n.result)), r();
    }, o = () => {
      i(n.error), r();
    };
    n.addEventListener("success", s), n.addEventListener("error", o);
  });
  return t.then((e) => {
    e instanceof IDBCursor && c0.set(e, n);
  }).catch(() => {
  }), Tu.set(t, n), t;
}
function jS(n) {
  if (bc.has(n))
    return;
  const t = new Promise((e, i) => {
    const r = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", o), n.removeEventListener("abort", o);
    }, s = () => {
      e(), r();
    }, o = () => {
      i(n.error || new DOMException("AbortError", "AbortError")), r();
    };
    n.addEventListener("complete", s), n.addEventListener("error", o), n.addEventListener("abort", o);
  });
  bc.set(n, t);
}
let wc = {
  get(n, t, e) {
    if (n instanceof IDBTransaction) {
      if (t === "done")
        return bc.get(n);
      if (t === "objectStoreNames")
        return n.objectStoreNames || u0.get(n);
      if (t === "store")
        return e.objectStoreNames[1] ? void 0 : e.objectStore(e.objectStoreNames[0]);
    }
    return ni(n[t]);
  },
  set(n, t, e) {
    return n[t] = e, !0;
  },
  has(n, t) {
    return n instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in n;
  }
};
function GS(n) {
  wc = n(wc);
}
function HS(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...e) {
    const i = n.call(Th(this), t, ...e);
    return u0.set(i, t.sort ? t.sort() : [t]), ni(i);
  } : US().includes(n) ? function(...t) {
    return n.apply(Th(this), t), ni(c0.get(this));
  } : function(...t) {
    return ni(n.apply(Th(this), t));
  };
}
function qS(n) {
  return typeof n == "function" ? HS(n) : (n instanceof IDBTransaction && jS(n), LS(n, NS()) ? new Proxy(n, wc) : n);
}
function ni(n) {
  if (n instanceof IDBRequest)
    return zS(n);
  if (Ah.has(n))
    return Ah.get(n);
  const t = qS(n);
  return t !== n && (Ah.set(n, t), Tu.set(t, n)), t;
}
const Th = (n) => Tu.get(n);
function WS(n, t, { blocked: e, upgrade: i, blocking: r, terminated: s } = {}) {
  const o = indexedDB.open(n, t), a = ni(o);
  return i && o.addEventListener("upgradeneeded", (l) => {
    i(ni(o.result), l.oldVersion, l.newVersion, ni(o.transaction), l);
  }), e && o.addEventListener("blocked", (l) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), a.then((l) => {
    s && l.addEventListener("close", () => s()), r && l.addEventListener("versionchange", (h) => r(h.oldVersion, h.newVersion, h));
  }).catch(() => {
  }), a;
}
const YS = ["get", "getKey", "getAll", "getAllKeys", "count"], XS = ["put", "add", "delete", "clear"], Sh = /* @__PURE__ */ new Map();
function Ef(n, t) {
  if (!(n instanceof IDBDatabase && !(t in n) && typeof t == "string"))
    return;
  if (Sh.get(t))
    return Sh.get(t);
  const e = t.replace(/FromIndex$/, ""), i = t !== e, r = XS.includes(e);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(e in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || YS.includes(e))
  )
    return;
  const s = async function(o, ...a) {
    const l = this.transaction(o, r ? "readwrite" : "readonly");
    let h = l.store;
    return i && (h = h.index(a.shift())), (await Promise.all([
      h[e](...a),
      r && l.done
    ]))[0];
  };
  return Sh.set(t, s), s;
}
GS((n) => ({
  ...n,
  get: (t, e, i) => Ef(t, e) || n.get(t, e, i),
  has: (t, e) => !!Ef(t, e) || n.has(t, e)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KS {
  constructor(t) {
    this.container = t;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((e) => {
      if (QS(e)) {
        const i = e.getImmediate();
        return `${i.library}/${i.version}`;
      } else
        return null;
    }).filter((e) => e).join(" ");
  }
}
function QS(n) {
  const t = n.getComponent();
  return (t == null ? void 0 : t.type) === "VERSION";
}
const Ac = "@firebase/app", Cf = "0.10.16";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zn = new h0("@firebase/app"), JS = "@firebase/app-compat", ZS = "@firebase/analytics-compat", $S = "@firebase/analytics", tE = "@firebase/app-check-compat", eE = "@firebase/app-check", nE = "@firebase/auth", iE = "@firebase/auth-compat", rE = "@firebase/database", sE = "@firebase/data-connect", oE = "@firebase/database-compat", aE = "@firebase/functions", lE = "@firebase/functions-compat", hE = "@firebase/installations", cE = "@firebase/installations-compat", uE = "@firebase/messaging", dE = "@firebase/messaging-compat", pE = "@firebase/performance", fE = "@firebase/performance-compat", mE = "@firebase/remote-config", gE = "@firebase/remote-config-compat", yE = "@firebase/storage", _E = "@firebase/storage-compat", vE = "@firebase/firestore", xE = "@firebase/vertexai", bE = "@firebase/firestore-compat", wE = "firebase", AE = "11.0.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Tc = "[DEFAULT]", TE = {
  [Ac]: "fire-core",
  [JS]: "fire-core-compat",
  [$S]: "fire-analytics",
  [ZS]: "fire-analytics-compat",
  [eE]: "fire-app-check",
  [tE]: "fire-app-check-compat",
  [nE]: "fire-auth",
  [iE]: "fire-auth-compat",
  [rE]: "fire-rtdb",
  [sE]: "fire-data-connect",
  [oE]: "fire-rtdb-compat",
  [aE]: "fire-fn",
  [lE]: "fire-fn-compat",
  [hE]: "fire-iid",
  [cE]: "fire-iid-compat",
  [uE]: "fire-fcm",
  [dE]: "fire-fcm-compat",
  [pE]: "fire-perf",
  [fE]: "fire-perf-compat",
  [mE]: "fire-rc",
  [gE]: "fire-rc-compat",
  [yE]: "fire-gcs",
  [_E]: "fire-gcs-compat",
  [vE]: "fire-fst",
  [bE]: "fire-fst-compat",
  [xE]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [wE]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Da = /* @__PURE__ */ new Map(), SE = /* @__PURE__ */ new Map(), Sc = /* @__PURE__ */ new Map();
function Pf(n, t) {
  try {
    n.container.addComponent(t);
  } catch (e) {
    zn.debug(`Component ${t.name} failed to register with FirebaseApp ${n.name}`, e);
  }
}
function Ba(n) {
  const t = n.name;
  if (Sc.has(t))
    return zn.debug(`There were multiple attempts to register component ${t}.`), !1;
  Sc.set(t, n);
  for (const e of Da.values())
    Pf(e, n);
  for (const e of SE.values())
    Pf(e, n);
  return !0;
}
function EE(n, t) {
  const e = n.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return e && e.triggerHeartbeat(), n.container.getProvider(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CE = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, ii = new l0("app", "Firebase", CE);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PE {
  constructor(t, e, i) {
    this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, e), this._name = e.name, this._automaticDataCollectionEnabled = e.automaticDataCollectionEnabled, this._container = i, this.container.addComponent(new ao(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = t;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(t) {
    this._isDeleted = t;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw ii.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IE = AE;
function d0(n, t = {}) {
  let e = n;
  typeof t != "object" && (t = { name: t });
  const i = Object.assign({ name: Tc, automaticDataCollectionEnabled: !1 }, t), r = i.name;
  if (typeof r != "string" || !r)
    throw ii.create("bad-app-name", {
      appName: String(r)
    });
  if (e || (e = a0()), !e)
    throw ii.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Da.get(r);
  if (s) {
    if (xc(e, s.options) && xc(i, s.config))
      return s;
    throw ii.create("duplicate-app", { appName: r });
  }
  const o = new VS(r);
  for (const l of Sc.values())
    o.addComponent(l);
  const a = new PE(e, i, o);
  return Da.set(r, a), a;
}
function RE(n = Tc) {
  const t = Da.get(n);
  if (!t && n === Tc && a0())
    return d0();
  if (!t)
    throw ii.create("no-app", { appName: n });
  return t;
}
function Sr(n, t, e) {
  var i;
  let r = (i = TE[n]) !== null && i !== void 0 ? i : n;
  e && (r += `-${e}`);
  const s = r.match(/\s|\//), o = t.match(/\s|\//);
  if (s || o) {
    const a = [
      `Unable to register library "${r}" with version "${t}":`
    ];
    s && a.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${t}" contains illegal characters (whitespace or "/")`), zn.warn(a.join(" "));
    return;
  }
  Ba(new ao(
    `${r}-version`,
    () => ({ library: r, version: t }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kE = "firebase-heartbeat-database", ME = 1, lo = "firebase-heartbeat-store";
let Eh = null;
function p0() {
  return Eh || (Eh = WS(kE, ME, {
    upgrade: (n, t) => {
      switch (t) {
        case 0:
          try {
            n.createObjectStore(lo);
          } catch (e) {
            console.warn(e);
          }
      }
    }
  }).catch((n) => {
    throw ii.create("idb-open", {
      originalErrorMessage: n.message
    });
  })), Eh;
}
async function VE(n) {
  try {
    const e = (await p0()).transaction(lo), i = await e.objectStore(lo).get(f0(n));
    return await e.done, i;
  } catch (t) {
    if (t instanceof Qr)
      zn.warn(t.message);
    else {
      const e = ii.create("idb-get", {
        originalErrorMessage: t == null ? void 0 : t.message
      });
      zn.warn(e.message);
    }
  }
}
async function If(n, t) {
  try {
    const i = (await p0()).transaction(lo, "readwrite");
    await i.objectStore(lo).put(t, f0(n)), await i.done;
  } catch (e) {
    if (e instanceof Qr)
      zn.warn(e.message);
    else {
      const i = ii.create("idb-set", {
        originalErrorMessage: e == null ? void 0 : e.message
      });
      zn.warn(i.message);
    }
  }
}
function f0(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DE = 1024, BE = 30 * 24 * 60 * 60 * 1e3;
class OE {
  constructor(t) {
    this.container = t, this._heartbeatsCache = null;
    const e = this.container.getProvider("app").getImmediate();
    this._storage = new LE(e), this._heartbeatsCachePromise = this._storage.read().then((i) => (this._heartbeatsCache = i, i));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var t, e;
    try {
      const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = Rf();
      return ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((o) => o.date === s) ? void 0 : (this._heartbeatsCache.heartbeats.push({ date: s, agent: r }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((o) => {
        const a = new Date(o.date).valueOf();
        return Date.now() - a <= BE;
      }), this._storage.overwrite(this._heartbeatsCache));
    } catch (i) {
      zn.warn(i);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var t;
    try {
      if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
        return "";
      const e = Rf(), { heartbeatsToSend: i, unsentEntries: r } = FE(this._heartbeatsCache.heartbeats), s = Va(JSON.stringify({ version: 2, heartbeats: i }));
      return this._heartbeatsCache.lastSentHeartbeatDate = e, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
    } catch (e) {
      return zn.warn(e), "";
    }
  }
}
function Rf() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function FE(n, t = DE) {
  const e = [];
  let i = n.slice();
  for (const r of n) {
    const s = e.find((o) => o.agent === r.agent);
    if (s) {
      if (s.dates.push(r.date), kf(e) > t) {
        s.dates.pop();
        break;
      }
    } else if (e.push({
      agent: r.agent,
      dates: [r.date]
    }), kf(e) > t) {
      e.pop();
      break;
    }
    i = i.slice(1);
  }
  return {
    heartbeatsToSend: e,
    unsentEntries: i
  };
}
class LE {
  constructor(t) {
    this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return SS() ? ES().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const e = await VE(this.app);
      return e != null && e.heartbeats ? e : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(t) {
    var e;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return If(this.app, {
        lastSentHeartbeatDate: (e = t.lastSentHeartbeatDate) !== null && e !== void 0 ? e : r.lastSentHeartbeatDate,
        heartbeats: t.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(t) {
    var e;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return If(this.app, {
        lastSentHeartbeatDate: (e = t.lastSentHeartbeatDate) !== null && e !== void 0 ? e : r.lastSentHeartbeatDate,
        heartbeats: [
          ...r.heartbeats,
          ...t.heartbeats
        ]
      });
    } else
      return;
  }
}
function kf(n) {
  return Va(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: n })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NE(n) {
  Ba(new ao(
    "platform-logger",
    (t) => new KS(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Ba(new ao(
    "heartbeat",
    (t) => new OE(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Sr(Ac, Cf, n), Sr(Ac, Cf, "esm2017"), Sr("fire-js", "");
}
NE("");
var UE = "firebase", zE = "11.0.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Sr(UE, zE, "app");
var Mf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var ji, m0;
(function() {
  var n;
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  function t(w, _) {
    function x() {
    }
    x.prototype = _.prototype, w.D = _.prototype, w.prototype = new x(), w.prototype.constructor = w, w.C = function(A, R, M) {
      for (var k = Array(arguments.length - 2), B = 2; B < arguments.length; B++) k[B - 2] = arguments[B];
      return _.prototype[R].apply(A, k);
    };
  }
  function e() {
    this.blockSize = -1;
  }
  function i() {
    this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.B = Array(this.blockSize), this.o = this.h = 0, this.s();
  }
  t(i, e), i.prototype.s = function() {
    this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0;
  };
  function r(w, _, x) {
    x || (x = 0);
    var A = Array(16);
    if (typeof _ == "string") for (var R = 0; 16 > R; ++R) A[R] = _.charCodeAt(x++) | _.charCodeAt(x++) << 8 | _.charCodeAt(x++) << 16 | _.charCodeAt(x++) << 24;
    else for (R = 0; 16 > R; ++R) A[R] = _[x++] | _[x++] << 8 | _[x++] << 16 | _[x++] << 24;
    _ = w.g[0], x = w.g[1], R = w.g[2];
    var M = w.g[3], k = _ + (M ^ x & (R ^ M)) + A[0] + 3614090360 & 4294967295;
    _ = x + (k << 7 & 4294967295 | k >>> 25), k = M + (R ^ _ & (x ^ R)) + A[1] + 3905402710 & 4294967295, M = _ + (k << 12 & 4294967295 | k >>> 20), k = R + (x ^ M & (_ ^ x)) + A[2] + 606105819 & 4294967295, R = M + (k << 17 & 4294967295 | k >>> 15), k = x + (_ ^ R & (M ^ _)) + A[3] + 3250441966 & 4294967295, x = R + (k << 22 & 4294967295 | k >>> 10), k = _ + (M ^ x & (R ^ M)) + A[4] + 4118548399 & 4294967295, _ = x + (k << 7 & 4294967295 | k >>> 25), k = M + (R ^ _ & (x ^ R)) + A[5] + 1200080426 & 4294967295, M = _ + (k << 12 & 4294967295 | k >>> 20), k = R + (x ^ M & (_ ^ x)) + A[6] + 2821735955 & 4294967295, R = M + (k << 17 & 4294967295 | k >>> 15), k = x + (_ ^ R & (M ^ _)) + A[7] + 4249261313 & 4294967295, x = R + (k << 22 & 4294967295 | k >>> 10), k = _ + (M ^ x & (R ^ M)) + A[8] + 1770035416 & 4294967295, _ = x + (k << 7 & 4294967295 | k >>> 25), k = M + (R ^ _ & (x ^ R)) + A[9] + 2336552879 & 4294967295, M = _ + (k << 12 & 4294967295 | k >>> 20), k = R + (x ^ M & (_ ^ x)) + A[10] + 4294925233 & 4294967295, R = M + (k << 17 & 4294967295 | k >>> 15), k = x + (_ ^ R & (M ^ _)) + A[11] + 2304563134 & 4294967295, x = R + (k << 22 & 4294967295 | k >>> 10), k = _ + (M ^ x & (R ^ M)) + A[12] + 1804603682 & 4294967295, _ = x + (k << 7 & 4294967295 | k >>> 25), k = M + (R ^ _ & (x ^ R)) + A[13] + 4254626195 & 4294967295, M = _ + (k << 12 & 4294967295 | k >>> 20), k = R + (x ^ M & (_ ^ x)) + A[14] + 2792965006 & 4294967295, R = M + (k << 17 & 4294967295 | k >>> 15), k = x + (_ ^ R & (M ^ _)) + A[15] + 1236535329 & 4294967295, x = R + (k << 22 & 4294967295 | k >>> 10), k = _ + (R ^ M & (x ^ R)) + A[1] + 4129170786 & 4294967295, _ = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ R & (_ ^ x)) + A[6] + 3225465664 & 4294967295, M = _ + (k << 9 & 4294967295 | k >>> 23), k = R + (_ ^ x & (M ^ _)) + A[11] + 643717713 & 4294967295, R = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ _ & (R ^ M)) + A[0] + 3921069994 & 4294967295, x = R + (k << 20 & 4294967295 | k >>> 12), k = _ + (R ^ M & (x ^ R)) + A[5] + 3593408605 & 4294967295, _ = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ R & (_ ^ x)) + A[10] + 38016083 & 4294967295, M = _ + (k << 9 & 4294967295 | k >>> 23), k = R + (_ ^ x & (M ^ _)) + A[15] + 3634488961 & 4294967295, R = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ _ & (R ^ M)) + A[4] + 3889429448 & 4294967295, x = R + (k << 20 & 4294967295 | k >>> 12), k = _ + (R ^ M & (x ^ R)) + A[9] + 568446438 & 4294967295, _ = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ R & (_ ^ x)) + A[14] + 3275163606 & 4294967295, M = _ + (k << 9 & 4294967295 | k >>> 23), k = R + (_ ^ x & (M ^ _)) + A[3] + 4107603335 & 4294967295, R = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ _ & (R ^ M)) + A[8] + 1163531501 & 4294967295, x = R + (k << 20 & 4294967295 | k >>> 12), k = _ + (R ^ M & (x ^ R)) + A[13] + 2850285829 & 4294967295, _ = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ R & (_ ^ x)) + A[2] + 4243563512 & 4294967295, M = _ + (k << 9 & 4294967295 | k >>> 23), k = R + (_ ^ x & (M ^ _)) + A[7] + 1735328473 & 4294967295, R = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ _ & (R ^ M)) + A[12] + 2368359562 & 4294967295, x = R + (k << 20 & 4294967295 | k >>> 12), k = _ + (x ^ R ^ M) + A[5] + 4294588738 & 4294967295, _ = x + (k << 4 & 4294967295 | k >>> 28), k = M + (_ ^ x ^ R) + A[8] + 2272392833 & 4294967295, M = _ + (k << 11 & 4294967295 | k >>> 21), k = R + (M ^ _ ^ x) + A[11] + 1839030562 & 4294967295, R = M + (k << 16 & 4294967295 | k >>> 16), k = x + (R ^ M ^ _) + A[14] + 4259657740 & 4294967295, x = R + (k << 23 & 4294967295 | k >>> 9), k = _ + (x ^ R ^ M) + A[1] + 2763975236 & 4294967295, _ = x + (k << 4 & 4294967295 | k >>> 28), k = M + (_ ^ x ^ R) + A[4] + 1272893353 & 4294967295, M = _ + (k << 11 & 4294967295 | k >>> 21), k = R + (M ^ _ ^ x) + A[7] + 4139469664 & 4294967295, R = M + (k << 16 & 4294967295 | k >>> 16), k = x + (R ^ M ^ _) + A[10] + 3200236656 & 4294967295, x = R + (k << 23 & 4294967295 | k >>> 9), k = _ + (x ^ R ^ M) + A[13] + 681279174 & 4294967295, _ = x + (k << 4 & 4294967295 | k >>> 28), k = M + (_ ^ x ^ R) + A[0] + 3936430074 & 4294967295, M = _ + (k << 11 & 4294967295 | k >>> 21), k = R + (M ^ _ ^ x) + A[3] + 3572445317 & 4294967295, R = M + (k << 16 & 4294967295 | k >>> 16), k = x + (R ^ M ^ _) + A[6] + 76029189 & 4294967295, x = R + (k << 23 & 4294967295 | k >>> 9), k = _ + (x ^ R ^ M) + A[9] + 3654602809 & 4294967295, _ = x + (k << 4 & 4294967295 | k >>> 28), k = M + (_ ^ x ^ R) + A[12] + 3873151461 & 4294967295, M = _ + (k << 11 & 4294967295 | k >>> 21), k = R + (M ^ _ ^ x) + A[15] + 530742520 & 4294967295, R = M + (k << 16 & 4294967295 | k >>> 16), k = x + (R ^ M ^ _) + A[2] + 3299628645 & 4294967295, x = R + (k << 23 & 4294967295 | k >>> 9), k = _ + (R ^ (x | ~M)) + A[0] + 4096336452 & 4294967295, _ = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (_ | ~R)) + A[7] + 1126891415 & 4294967295, M = _ + (k << 10 & 4294967295 | k >>> 22), k = R + (_ ^ (M | ~x)) + A[14] + 2878612391 & 4294967295, R = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (R | ~_)) + A[5] + 4237533241 & 4294967295, x = R + (k << 21 & 4294967295 | k >>> 11), k = _ + (R ^ (x | ~M)) + A[12] + 1700485571 & 4294967295, _ = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (_ | ~R)) + A[3] + 2399980690 & 4294967295, M = _ + (k << 10 & 4294967295 | k >>> 22), k = R + (_ ^ (M | ~x)) + A[10] + 4293915773 & 4294967295, R = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (R | ~_)) + A[1] + 2240044497 & 4294967295, x = R + (k << 21 & 4294967295 | k >>> 11), k = _ + (R ^ (x | ~M)) + A[8] + 1873313359 & 4294967295, _ = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (_ | ~R)) + A[15] + 4264355552 & 4294967295, M = _ + (k << 10 & 4294967295 | k >>> 22), k = R + (_ ^ (M | ~x)) + A[6] + 2734768916 & 4294967295, R = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (R | ~_)) + A[13] + 1309151649 & 4294967295, x = R + (k << 21 & 4294967295 | k >>> 11), k = _ + (R ^ (x | ~M)) + A[4] + 4149444226 & 4294967295, _ = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (_ | ~R)) + A[11] + 3174756917 & 4294967295, M = _ + (k << 10 & 4294967295 | k >>> 22), k = R + (_ ^ (M | ~x)) + A[2] + 718787259 & 4294967295, R = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (R | ~_)) + A[9] + 3951481745 & 4294967295, w.g[0] = w.g[0] + _ & 4294967295, w.g[1] = w.g[1] + (R + (k << 21 & 4294967295 | k >>> 11)) & 4294967295, w.g[2] = w.g[2] + R & 4294967295, w.g[3] = w.g[3] + M & 4294967295;
  }
  i.prototype.u = function(w, _) {
    _ === void 0 && (_ = w.length);
    for (var x = _ - this.blockSize, A = this.B, R = this.h, M = 0; M < _; ) {
      if (R == 0) for (; M <= x; ) r(this, w, M), M += this.blockSize;
      if (typeof w == "string") {
        for (; M < _; )
          if (A[R++] = w.charCodeAt(M++), R == this.blockSize) {
            r(this, A), R = 0;
            break;
          }
      } else for (; M < _; ) if (A[R++] = w[M++], R == this.blockSize) {
        r(this, A), R = 0;
        break;
      }
    }
    this.h = R, this.o += _;
  }, i.prototype.v = function() {
    var w = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
    w[0] = 128;
    for (var _ = 1; _ < w.length - 8; ++_) w[_] = 0;
    var x = 8 * this.o;
    for (_ = w.length - 8; _ < w.length; ++_) w[_] = x & 255, x /= 256;
    for (this.u(w), w = Array(16), _ = x = 0; 4 > _; ++_) for (var A = 0; 32 > A; A += 8) w[x++] = this.g[_] >>> A & 255;
    return w;
  };
  function s(w, _) {
    var x = a;
    return Object.prototype.hasOwnProperty.call(x, w) ? x[w] : x[w] = _(w);
  }
  function o(w, _) {
    this.h = _;
    for (var x = [], A = !0, R = w.length - 1; 0 <= R; R--) {
      var M = w[R] | 0;
      A && M == _ || (x[R] = M, A = !1);
    }
    this.g = x;
  }
  var a = {};
  function l(w) {
    return -128 <= w && 128 > w ? s(w, function(_) {
      return new o([_ | 0], 0 > _ ? -1 : 0);
    }) : new o([w | 0], 0 > w ? -1 : 0);
  }
  function h(w) {
    if (isNaN(w) || !isFinite(w)) return p;
    if (0 > w) return y(h(-w));
    for (var _ = [], x = 1, A = 0; w >= x; A++) _[A] = w / x | 0, x *= 4294967296;
    return new o(_, 0);
  }
  function c(w, _) {
    if (w.length == 0) throw Error("number format error: empty string");
    if (_ = _ || 10, 2 > _ || 36 < _) throw Error("radix out of range: " + _);
    if (w.charAt(0) == "-") return y(c(w.substring(1), _));
    if (0 <= w.indexOf("-")) throw Error('number format error: interior "-" character');
    for (var x = h(Math.pow(_, 8)), A = p, R = 0; R < w.length; R += 8) {
      var M = Math.min(8, w.length - R), k = parseInt(w.substring(R, R + M), _);
      8 > M ? (M = h(Math.pow(_, M)), A = A.j(M).add(h(k))) : (A = A.j(x), A = A.add(h(k)));
    }
    return A;
  }
  var p = l(0), f = l(1), u = l(16777216);
  n = o.prototype, n.m = function() {
    if (g(this)) return -y(this).m();
    for (var w = 0, _ = 1, x = 0; x < this.g.length; x++) {
      var A = this.i(x);
      w += (0 <= A ? A : 4294967296 + A) * _, _ *= 4294967296;
    }
    return w;
  }, n.toString = function(w) {
    if (w = w || 10, 2 > w || 36 < w) throw Error("radix out of range: " + w);
    if (m(this)) return "0";
    if (g(this)) return "-" + y(this).toString(w);
    for (var _ = h(Math.pow(w, 6)), x = this, A = ""; ; ) {
      var R = P(x, _).g;
      x = b(x, R.j(_));
      var M = ((0 < x.g.length ? x.g[0] : x.h) >>> 0).toString(w);
      if (x = R, m(x)) return M + A;
      for (; 6 > M.length; ) M = "0" + M;
      A = M + A;
    }
  }, n.i = function(w) {
    return 0 > w ? 0 : w < this.g.length ? this.g[w] : this.h;
  };
  function m(w) {
    if (w.h != 0) return !1;
    for (var _ = 0; _ < w.g.length; _++) if (w.g[_] != 0) return !1;
    return !0;
  }
  function g(w) {
    return w.h == -1;
  }
  n.l = function(w) {
    return w = b(this, w), g(w) ? -1 : m(w) ? 0 : 1;
  };
  function y(w) {
    for (var _ = w.g.length, x = [], A = 0; A < _; A++) x[A] = ~w.g[A];
    return new o(x, ~w.h).add(f);
  }
  n.abs = function() {
    return g(this) ? y(this) : this;
  }, n.add = function(w) {
    for (var _ = Math.max(this.g.length, w.g.length), x = [], A = 0, R = 0; R <= _; R++) {
      var M = A + (this.i(R) & 65535) + (w.i(R) & 65535), k = (M >>> 16) + (this.i(R) >>> 16) + (w.i(R) >>> 16);
      A = k >>> 16, M &= 65535, k &= 65535, x[R] = k << 16 | M;
    }
    return new o(x, x[x.length - 1] & -2147483648 ? -1 : 0);
  };
  function b(w, _) {
    return w.add(y(_));
  }
  n.j = function(w) {
    if (m(this) || m(w)) return p;
    if (g(this)) return g(w) ? y(this).j(y(w)) : y(y(this).j(w));
    if (g(w)) return y(this.j(y(w)));
    if (0 > this.l(u) && 0 > w.l(u)) return h(this.m() * w.m());
    for (var _ = this.g.length + w.g.length, x = [], A = 0; A < 2 * _; A++) x[A] = 0;
    for (A = 0; A < this.g.length; A++) for (var R = 0; R < w.g.length; R++) {
      var M = this.i(A) >>> 16, k = this.i(A) & 65535, B = w.i(R) >>> 16, O = w.i(R) & 65535;
      x[2 * A + 2 * R] += k * O, T(x, 2 * A + 2 * R), x[2 * A + 2 * R + 1] += M * O, T(x, 2 * A + 2 * R + 1), x[2 * A + 2 * R + 1] += k * B, T(x, 2 * A + 2 * R + 1), x[2 * A + 2 * R + 2] += M * B, T(x, 2 * A + 2 * R + 2);
    }
    for (A = 0; A < _; A++) x[A] = x[2 * A + 1] << 16 | x[2 * A];
    for (A = _; A < 2 * _; A++) x[A] = 0;
    return new o(x, 0);
  };
  function T(w, _) {
    for (; (w[_] & 65535) != w[_]; ) w[_ + 1] += w[_] >>> 16, w[_] &= 65535, _++;
  }
  function C(w, _) {
    this.g = w, this.h = _;
  }
  function P(w, _) {
    if (m(_)) throw Error("division by zero");
    if (m(w)) return new C(p, p);
    if (g(w)) return _ = P(y(w), _), new C(y(_.g), y(_.h));
    if (g(_)) return _ = P(w, y(_)), new C(y(_.g), _.h);
    if (30 < w.g.length) {
      if (g(w) || g(_)) throw Error("slowDivide_ only works with positive integers.");
      for (var x = f, A = _; 0 >= A.l(w); ) x = S(x), A = S(A);
      var R = I(x, 1), M = I(A, 1);
      for (A = I(A, 2), x = I(x, 2); !m(A); ) {
        var k = M.add(A);
        0 >= k.l(w) && (R = R.add(x), M = k), A = I(A, 1), x = I(x, 1);
      }
      return _ = b(w, R.j(_)), new C(R, _);
    }
    for (R = p; 0 <= w.l(_); ) {
      for (x = Math.max(1, Math.floor(w.m() / _.m())), A = Math.ceil(Math.log(x) / Math.LN2), A = 48 >= A ? 1 : Math.pow(2, A - 48), M = h(x), k = M.j(_); g(k) || 0 < k.l(w); ) x -= A, M = h(x), k = M.j(_);
      m(M) && (M = f), R = R.add(M), w = b(w, k);
    }
    return new C(R, w);
  }
  n.A = function(w) {
    return P(this, w).h;
  }, n.and = function(w) {
    for (var _ = Math.max(this.g.length, w.g.length), x = [], A = 0; A < _; A++) x[A] = this.i(A) & w.i(A);
    return new o(x, this.h & w.h);
  }, n.or = function(w) {
    for (var _ = Math.max(this.g.length, w.g.length), x = [], A = 0; A < _; A++) x[A] = this.i(A) | w.i(A);
    return new o(x, this.h | w.h);
  }, n.xor = function(w) {
    for (var _ = Math.max(this.g.length, w.g.length), x = [], A = 0; A < _; A++) x[A] = this.i(A) ^ w.i(A);
    return new o(x, this.h ^ w.h);
  };
  function S(w) {
    for (var _ = w.g.length + 1, x = [], A = 0; A < _; A++) x[A] = w.i(A) << 1 | w.i(A - 1) >>> 31;
    return new o(x, w.h);
  }
  function I(w, _) {
    var x = _ >> 5;
    _ %= 32;
    for (var A = w.g.length - x, R = [], M = 0; M < A; M++) R[M] = 0 < _ ? w.i(M + x) >>> _ | w.i(M + x + 1) << 32 - _ : w.i(M + x);
    return new o(R, w.h);
  }
  i.prototype.digest = i.prototype.v, i.prototype.reset = i.prototype.s, i.prototype.update = i.prototype.u, m0 = i, o.prototype.add = o.prototype.add, o.prototype.multiply = o.prototype.j, o.prototype.modulo = o.prototype.A, o.prototype.compare = o.prototype.l, o.prototype.toNumber = o.prototype.m, o.prototype.toString = o.prototype.toString, o.prototype.getBits = o.prototype.i, o.fromNumber = h, o.fromString = c, ji = o;
}).apply(typeof Mf < "u" ? Mf : typeof self < "u" ? self : typeof window < "u" ? window : {});
var Jo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var g0, ks, y0, ua, Ec, _0, v0, x0;
(function() {
  var n, t = typeof Object.defineProperties == "function" ? Object.defineProperty : function(d, v, E) {
    return d == Array.prototype || d == Object.prototype || (d[v] = E.value), d;
  };
  function e(d) {
    d = [typeof globalThis == "object" && globalThis, d, typeof window == "object" && window, typeof self == "object" && self, typeof Jo == "object" && Jo];
    for (var v = 0; v < d.length; ++v) {
      var E = d[v];
      if (E && E.Math == Math) return E;
    }
    throw Error("Cannot find global object");
  }
  var i = e(this);
  function r(d, v) {
    if (v) t: {
      var E = i;
      d = d.split(".");
      for (var V = 0; V < d.length - 1; V++) {
        var D = d[V];
        if (!(D in E)) break t;
        E = E[D];
      }
      d = d[d.length - 1], V = E[d], v = v(V), v != V && v != null && t(E, d, { configurable: !0, writable: !0, value: v });
    }
  }
  function s(d, v) {
    d instanceof String && (d += "");
    var E = 0, V = !1, D = { next: function() {
      if (!V && E < d.length) {
        var F = E++;
        return { value: v(F, d[F]), done: !1 };
      }
      return V = !0, { done: !0, value: void 0 };
    } };
    return D[Symbol.iterator] = function() {
      return D;
    }, D;
  }
  r("Array.prototype.values", function(d) {
    return d || function() {
      return s(this, function(v, E) {
        return E;
      });
    };
  });
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  var o = o || {}, a = this || self;
  function l(d) {
    var v = typeof d;
    return v = v != "object" ? v : d ? Array.isArray(d) ? "array" : v : "null", v == "array" || v == "object" && typeof d.length == "number";
  }
  function h(d) {
    var v = typeof d;
    return v == "object" && d != null || v == "function";
  }
  function c(d, v, E) {
    return d.call.apply(d.bind, arguments);
  }
  function p(d, v, E) {
    if (!d) throw Error();
    if (2 < arguments.length) {
      var V = Array.prototype.slice.call(arguments, 2);
      return function() {
        var D = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(D, V), d.apply(v, D);
      };
    }
    return function() {
      return d.apply(v, arguments);
    };
  }
  function f(d, v, E) {
    return f = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? c : p, f.apply(null, arguments);
  }
  function u(d, v) {
    var E = Array.prototype.slice.call(arguments, 1);
    return function() {
      var V = E.slice();
      return V.push.apply(V, arguments), d.apply(this, V);
    };
  }
  function m(d, v) {
    function E() {
    }
    E.prototype = v.prototype, d.aa = v.prototype, d.prototype = new E(), d.prototype.constructor = d, d.Qb = function(V, D, F) {
      for (var G = Array(arguments.length - 2), xt = 2; xt < arguments.length; xt++) G[xt - 2] = arguments[xt];
      return v.prototype[D].apply(V, G);
    };
  }
  function g(d) {
    const v = d.length;
    if (0 < v) {
      const E = Array(v);
      for (let V = 0; V < v; V++) E[V] = d[V];
      return E;
    }
    return [];
  }
  function y(d, v) {
    for (let E = 1; E < arguments.length; E++) {
      const V = arguments[E];
      if (l(V)) {
        const D = d.length || 0, F = V.length || 0;
        d.length = D + F;
        for (let G = 0; G < F; G++) d[D + G] = V[G];
      } else d.push(V);
    }
  }
  class b {
    constructor(v, E) {
      this.i = v, this.j = E, this.h = 0, this.g = null;
    }
    get() {
      let v;
      return 0 < this.h ? (this.h--, v = this.g, this.g = v.next, v.next = null) : v = this.i(), v;
    }
  }
  function T(d) {
    return /^[\s\xa0]*$/.test(d);
  }
  function C() {
    var d = a.navigator;
    return d && (d = d.userAgent) ? d : "";
  }
  function P(d) {
    return P[" "](d), d;
  }
  P[" "] = function() {
  };
  var S = C().indexOf("Gecko") != -1 && !(C().toLowerCase().indexOf("webkit") != -1 && C().indexOf("Edge") == -1) && !(C().indexOf("Trident") != -1 || C().indexOf("MSIE") != -1) && C().indexOf("Edge") == -1;
  function I(d, v, E) {
    for (const V in d) v.call(E, d[V], V, d);
  }
  function w(d, v) {
    for (const E in d) v.call(void 0, d[E], E, d);
  }
  function _(d) {
    const v = {};
    for (const E in d) v[E] = d[E];
    return v;
  }
  const x = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function A(d, v) {
    let E, V;
    for (let D = 1; D < arguments.length; D++) {
      V = arguments[D];
      for (E in V) d[E] = V[E];
      for (let F = 0; F < x.length; F++) E = x[F], Object.prototype.hasOwnProperty.call(V, E) && (d[E] = V[E]);
    }
  }
  function R(d) {
    var v = 1;
    d = d.split(":");
    const E = [];
    for (; 0 < v && d.length; ) E.push(d.shift()), v--;
    return d.length && E.push(d.join(":")), E;
  }
  function M(d) {
    a.setTimeout(() => {
      throw d;
    }, 0);
  }
  function k() {
    var d = j;
    let v = null;
    return d.g && (v = d.g, d.g = d.g.next, d.g || (d.h = null), v.next = null), v;
  }
  class B {
    constructor() {
      this.h = this.g = null;
    }
    add(v, E) {
      const V = O.get();
      V.set(v, E), this.h ? this.h.next = V : this.g = V, this.h = V;
    }
  }
  var O = new b(() => new U(), (d) => d.reset());
  class U {
    constructor() {
      this.next = this.g = this.h = null;
    }
    set(v, E) {
      this.h = v, this.g = E, this.next = null;
    }
    reset() {
      this.next = this.g = this.h = null;
    }
  }
  let z, Q = !1, j = new B(), H = () => {
    const d = a.Promise.resolve(void 0);
    z = () => {
      d.then(_t);
    };
  };
  var _t = () => {
    for (var d; d = k(); ) {
      try {
        d.h.call(d.g);
      } catch (E) {
        M(E);
      }
      var v = O;
      v.j(d), 100 > v.h && (v.h++, d.next = v.g, v.g = d);
    }
    Q = !1;
  };
  function J() {
    this.s = this.s, this.C = this.C;
  }
  J.prototype.s = !1, J.prototype.ma = function() {
    this.s || (this.s = !0, this.N());
  }, J.prototype.N = function() {
    if (this.C) for (; this.C.length; ) this.C.shift()();
  };
  function $(d, v) {
    this.type = d, this.g = this.target = v, this.defaultPrevented = !1;
  }
  $.prototype.h = function() {
    this.defaultPrevented = !0;
  };
  var St = function() {
    if (!a.addEventListener || !Object.defineProperty) return !1;
    var d = !1, v = Object.defineProperty({}, "passive", { get: function() {
      d = !0;
    } });
    try {
      const E = () => {
      };
      a.addEventListener("test", E, v), a.removeEventListener("test", E, v);
    } catch {
    }
    return d;
  }();
  function Ct(d, v) {
    if ($.call(this, d ? d.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, d) {
      var E = this.type = d.type, V = d.changedTouches && d.changedTouches.length ? d.changedTouches[0] : null;
      if (this.target = d.target || d.srcElement, this.g = v, v = d.relatedTarget) {
        if (S) {
          t: {
            try {
              P(v.nodeName);
              var D = !0;
              break t;
            } catch {
            }
            D = !1;
          }
          D || (v = null);
        }
      } else E == "mouseover" ? v = d.fromElement : E == "mouseout" && (v = d.toElement);
      this.relatedTarget = v, V ? (this.clientX = V.clientX !== void 0 ? V.clientX : V.pageX, this.clientY = V.clientY !== void 0 ? V.clientY : V.pageY, this.screenX = V.screenX || 0, this.screenY = V.screenY || 0) : (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0), this.button = d.button, this.key = d.key || "", this.ctrlKey = d.ctrlKey, this.altKey = d.altKey, this.shiftKey = d.shiftKey, this.metaKey = d.metaKey, this.pointerId = d.pointerId || 0, this.pointerType = typeof d.pointerType == "string" ? d.pointerType : rt[d.pointerType] || "", this.state = d.state, this.i = d, d.defaultPrevented && Ct.aa.h.call(this);
    }
  }
  m(Ct, $);
  var rt = { 2: "touch", 3: "pen", 4: "mouse" };
  Ct.prototype.h = function() {
    Ct.aa.h.call(this);
    var d = this.i;
    d.preventDefault ? d.preventDefault() : d.returnValue = !1;
  };
  var Xt = "closure_listenable_" + (1e6 * Math.random() | 0), Pt = 0;
  function Ne(d, v, E, V, D) {
    this.listener = d, this.proxy = null, this.src = v, this.type = E, this.capture = !!V, this.ha = D, this.key = ++Pt, this.da = this.fa = !1;
  }
  function te(d) {
    d.da = !0, d.listener = null, d.proxy = null, d.src = null, d.ha = null;
  }
  function ee(d) {
    this.src = d, this.g = {}, this.h = 0;
  }
  ee.prototype.add = function(d, v, E, V, D) {
    var F = d.toString();
    d = this.g[F], d || (d = this.g[F] = [], this.h++);
    var G = fn(d, v, V, D);
    return -1 < G ? (v = d[G], E || (v.fa = !1)) : (v = new Ne(v, this.src, F, !!V, D), v.fa = E, d.push(v)), v;
  };
  function It(d, v) {
    var E = v.type;
    if (E in d.g) {
      var V = d.g[E], D = Array.prototype.indexOf.call(V, v, void 0), F;
      (F = 0 <= D) && Array.prototype.splice.call(V, D, 1), F && (te(v), d.g[E].length == 0 && (delete d.g[E], d.h--));
    }
  }
  function fn(d, v, E, V) {
    for (var D = 0; D < d.length; ++D) {
      var F = d[D];
      if (!F.da && F.listener == v && F.capture == !!E && F.ha == V) return D;
    }
    return -1;
  }
  var Cn = "closure_lm_" + (1e6 * Math.random() | 0), Ue = {};
  function ze(d, v, E, V, D) {
    if (Array.isArray(v)) {
      for (var F = 0; F < v.length; F++) ze(d, v[F], E, V, D);
      return null;
    }
    return E = ns(E), d && d[Xt] ? d.K(v, E, h(V) ? !!V.capture : !!V, D) : Ze(d, v, E, !1, V, D);
  }
  function Ze(d, v, E, V, D, F) {
    if (!v) throw Error("Invalid event type");
    var G = h(D) ? !!D.capture : !!D, xt = tr(d);
    if (xt || (d[Cn] = xt = new ee(d)), E = xt.add(v, E, V, G, F), E.proxy) return E;
    if (V = je(), E.proxy = V, V.src = d, V.listener = E, d.addEventListener) St || (D = G), D === void 0 && (D = !1), d.addEventListener(v.toString(), V, D);
    else if (d.attachEvent) d.attachEvent(qn(v.toString()), V);
    else if (d.addListener && d.removeListener) d.addListener(V);
    else throw Error("addEventListener and attachEvent are unavailable.");
    return E;
  }
  function je() {
    function d(E) {
      return v.call(d.src, d.listener, E);
    }
    const v = Ao;
    return d;
  }
  function Re(d, v, E, V, D) {
    if (Array.isArray(v)) for (var F = 0; F < v.length; F++) Re(d, v[F], E, V, D);
    else V = h(V) ? !!V.capture : !!V, E = ns(E), d && d[Xt] ? (d = d.i, v = String(v).toString(), v in d.g && (F = d.g[v], E = fn(F, E, V, D), -1 < E && (te(F[E]), Array.prototype.splice.call(F, E, 1), F.length == 0 && (delete d.g[v], d.h--)))) : d && (d = tr(d)) && (v = d.g[v.toString()], d = -1, v && (d = fn(v, E, V, D)), (E = -1 < d ? v[d] : null) && Pn(E));
  }
  function Pn(d) {
    if (typeof d != "number" && d && !d.da) {
      var v = d.src;
      if (v && v[Xt]) It(v.i, d);
      else {
        var E = d.type, V = d.proxy;
        v.removeEventListener ? v.removeEventListener(E, V, d.capture) : v.detachEvent ? v.detachEvent(qn(E), V) : v.addListener && v.removeListener && v.removeListener(V), (E = tr(v)) ? (It(E, d), E.h == 0 && (E.src = null, v[Cn] = null)) : te(d);
      }
    }
  }
  function qn(d) {
    return d in Ue ? Ue[d] : Ue[d] = "on" + d;
  }
  function Ao(d, v) {
    if (d.da) d = !0;
    else {
      v = new Ct(v, this);
      var E = d.listener, V = d.ha || d.src;
      d.fa && Pn(d), d = E.call(V, v);
    }
    return d;
  }
  function tr(d) {
    return d = d[Cn], d instanceof ee ? d : null;
  }
  var er = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function ns(d) {
    return typeof d == "function" ? d : (d[er] || (d[er] = function(v) {
      return d.handleEvent(v);
    }), d[er]);
  }
  function Nt() {
    J.call(this), this.i = new ee(this), this.M = this, this.F = null;
  }
  m(Nt, J), Nt.prototype[Xt] = !0, Nt.prototype.removeEventListener = function(d, v, E, V) {
    Re(this, d, v, E, V);
  };
  function ae(d, v) {
    var E, V = d.F;
    if (V) for (E = []; V; V = V.F) E.push(V);
    if (d = d.M, V = v.type || v, typeof v == "string") v = new $(v, d);
    else if (v instanceof $) v.target = v.target || d;
    else {
      var D = v;
      v = new $(V, d), A(v, D);
    }
    if (D = !0, E) for (var F = E.length - 1; 0 <= F; F--) {
      var G = v.g = E[F];
      D = nr(G, V, !0, v) && D;
    }
    if (G = v.g = d, D = nr(G, V, !0, v) && D, D = nr(G, V, !1, v) && D, E) for (F = 0; F < E.length; F++) G = v.g = E[F], D = nr(G, V, !1, v) && D;
  }
  Nt.prototype.N = function() {
    if (Nt.aa.N.call(this), this.i) {
      var d = this.i, v;
      for (v in d.g) {
        for (var E = d.g[v], V = 0; V < E.length; V++) te(E[V]);
        delete d.g[v], d.h--;
      }
    }
    this.F = null;
  }, Nt.prototype.K = function(d, v, E, V) {
    return this.i.add(String(d), v, !1, E, V);
  }, Nt.prototype.L = function(d, v, E, V) {
    return this.i.add(String(d), v, !0, E, V);
  };
  function nr(d, v, E, V) {
    if (v = d.i.g[String(v)], !v) return !0;
    v = v.concat();
    for (var D = !0, F = 0; F < v.length; ++F) {
      var G = v[F];
      if (G && !G.da && G.capture == E) {
        var xt = G.listener, le = G.ha || G.src;
        G.fa && It(d.i, G), D = xt.call(le, V) !== !1 && D;
      }
    }
    return D && !V.defaultPrevented;
  }
  function gi(d, v, E) {
    if (typeof d == "function") E && (d = f(d, E));
    else if (d && typeof d.handleEvent == "function") d = f(d.handleEvent, d);
    else throw Error("Invalid listener argument");
    return 2147483647 < Number(v) ? -1 : a.setTimeout(d, v || 0);
  }
  function yi(d) {
    d.g = gi(() => {
      d.g = null, d.i && (d.i = !1, yi(d));
    }, d.l);
    const v = d.h;
    d.h = null, d.m.apply(null, v);
  }
  class z_ extends J {
    constructor(v, E) {
      super(), this.m = v, this.l = E, this.h = null, this.i = !1, this.g = null;
    }
    j(v) {
      this.h = arguments, this.g ? this.i = !0 : yi(this);
    }
    N() {
      super.N(), this.g && (a.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null);
    }
  }
  function is(d) {
    J.call(this), this.h = d, this.g = {};
  }
  m(is, J);
  var od = [];
  function ad(d) {
    I(d.g, function(v, E) {
      this.g.hasOwnProperty(E) && Pn(v);
    }, d), d.g = {};
  }
  is.prototype.N = function() {
    is.aa.N.call(this), ad(this);
  }, is.prototype.handleEvent = function() {
    throw Error("EventHandler.handleEvent not implemented");
  };
  var Al = a.JSON.stringify, j_ = a.JSON.parse, G_ = class {
    stringify(d) {
      return a.JSON.stringify(d, void 0);
    }
    parse(d) {
      return a.JSON.parse(d, void 0);
    }
  };
  function Tl() {
  }
  Tl.prototype.h = null;
  function ld(d) {
    return d.h || (d.h = d.i());
  }
  function hd() {
  }
  var rs = { OPEN: "a", kb: "b", Ja: "c", wb: "d" };
  function Sl() {
    $.call(this, "d");
  }
  m(Sl, $);
  function El() {
    $.call(this, "c");
  }
  m(El, $);
  var _i = {}, cd = null;
  function To() {
    return cd = cd || new Nt();
  }
  _i.La = "serverreachability";
  function ud(d) {
    $.call(this, _i.La, d);
  }
  m(ud, $);
  function ss(d) {
    const v = To();
    ae(v, new ud(v));
  }
  _i.STAT_EVENT = "statevent";
  function dd(d, v) {
    $.call(this, _i.STAT_EVENT, d), this.stat = v;
  }
  m(dd, $);
  function Te(d) {
    const v = To();
    ae(v, new dd(v, d));
  }
  _i.Ma = "timingevent";
  function pd(d, v) {
    $.call(this, _i.Ma, d), this.size = v;
  }
  m(pd, $);
  function os(d, v) {
    if (typeof d != "function") throw Error("Fn must not be null and must be a function");
    return a.setTimeout(function() {
      d();
    }, v);
  }
  function as() {
    this.g = !0;
  }
  as.prototype.xa = function() {
    this.g = !1;
  };
  function H_(d, v, E, V, D, F) {
    d.info(function() {
      if (d.g) if (F)
        for (var G = "", xt = F.split("&"), le = 0; le < xt.length; le++) {
          var dt = xt[le].split("=");
          if (1 < dt.length) {
            var pe = dt[0];
            dt = dt[1];
            var fe = pe.split("_");
            G = 2 <= fe.length && fe[1] == "type" ? G + (pe + "=" + dt + "&") : G + (pe + "=redacted&");
          }
        }
      else G = null;
      else G = F;
      return "XMLHTTP REQ (" + V + ") [attempt " + D + "]: " + v + `
` + E + `
` + G;
    });
  }
  function q_(d, v, E, V, D, F, G) {
    d.info(function() {
      return "XMLHTTP RESP (" + V + ") [ attempt " + D + "]: " + v + `
` + E + `
` + F + " " + G;
    });
  }
  function ir(d, v, E, V) {
    d.info(function() {
      return "XMLHTTP TEXT (" + v + "): " + Y_(d, E) + (V ? " " + V : "");
    });
  }
  function W_(d, v) {
    d.info(function() {
      return "TIMEOUT: " + v;
    });
  }
  as.prototype.info = function() {
  };
  function Y_(d, v) {
    if (!d.g) return v;
    if (!v) return null;
    try {
      var E = JSON.parse(v);
      if (E) {
        for (d = 0; d < E.length; d++) if (Array.isArray(E[d])) {
          var V = E[d];
          if (!(2 > V.length)) {
            var D = V[1];
            if (Array.isArray(D) && !(1 > D.length)) {
              var F = D[0];
              if (F != "noop" && F != "stop" && F != "close") for (var G = 1; G < D.length; G++) D[G] = "";
            }
          }
        }
      }
      return Al(E);
    } catch {
      return v;
    }
  }
  var So = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 }, fd = { lb: "complete", Hb: "success", Ja: "error", Ia: "abort", zb: "ready", Ab: "readystatechange", TIMEOUT: "timeout", vb: "incrementaldata", yb: "progress", ob: "downloadprogress", Pb: "uploadprogress" }, Cl;
  function Eo() {
  }
  m(Eo, Tl), Eo.prototype.g = function() {
    return new XMLHttpRequest();
  }, Eo.prototype.i = function() {
    return {};
  }, Cl = new Eo();
  function Wn(d, v, E, V) {
    this.j = d, this.i = v, this.l = E, this.R = V || 1, this.U = new is(this), this.I = 45e3, this.H = null, this.o = !1, this.m = this.A = this.v = this.L = this.F = this.S = this.B = null, this.D = [], this.g = null, this.C = 0, this.s = this.u = null, this.X = -1, this.J = !1, this.O = 0, this.M = null, this.W = this.K = this.T = this.P = !1, this.h = new md();
  }
  function md() {
    this.i = null, this.g = "", this.h = !1;
  }
  var gd = {}, Pl = {};
  function Il(d, v, E) {
    d.L = 1, d.v = Ro(In(v)), d.m = E, d.P = !0, yd(d, null);
  }
  function yd(d, v) {
    d.F = Date.now(), Co(d), d.A = In(d.v);
    var E = d.A, V = d.R;
    Array.isArray(V) || (V = [String(V)]), kd(E.i, "t", V), d.C = 0, E = d.j.J, d.h = new md(), d.g = Kd(d.j, E ? v : null, !d.m), 0 < d.O && (d.M = new z_(f(d.Y, d, d.g), d.O)), v = d.U, E = d.g, V = d.ca;
    var D = "readystatechange";
    Array.isArray(D) || (D && (od[0] = D.toString()), D = od);
    for (var F = 0; F < D.length; F++) {
      var G = ze(E, D[F], V || v.handleEvent, !1, v.h || v);
      if (!G) break;
      v.g[G.key] = G;
    }
    v = d.H ? _(d.H) : {}, d.m ? (d.u || (d.u = "POST"), v["Content-Type"] = "application/x-www-form-urlencoded", d.g.ea(
      d.A,
      d.u,
      d.m,
      v
    )) : (d.u = "GET", d.g.ea(d.A, d.u, null, v)), ss(), H_(d.i, d.u, d.A, d.l, d.R, d.m);
  }
  Wn.prototype.ca = function(d) {
    d = d.target;
    const v = this.M;
    v && Rn(d) == 3 ? v.j() : this.Y(d);
  }, Wn.prototype.Y = function(d) {
    try {
      if (d == this.g) t: {
        const fe = Rn(this.g);
        var v = this.g.Ba();
        const or = this.g.Z();
        if (!(3 > fe) && (fe != 3 || this.g && (this.h.h || this.g.oa() || Ld(this.g)))) {
          this.J || fe != 4 || v == 7 || (v == 8 || 0 >= or ? ss(3) : ss(2)), Rl(this);
          var E = this.g.Z();
          this.X = E;
          e: if (_d(this)) {
            var V = Ld(this.g);
            d = "";
            var D = V.length, F = Rn(this.g) == 4;
            if (!this.h.i) {
              if (typeof TextDecoder > "u") {
                vi(this), ls(this);
                var G = "";
                break e;
              }
              this.h.i = new a.TextDecoder();
            }
            for (v = 0; v < D; v++) this.h.h = !0, d += this.h.i.decode(V[v], { stream: !(F && v == D - 1) });
            V.length = 0, this.h.g += d, this.C = 0, G = this.h.g;
          } else G = this.g.oa();
          if (this.o = E == 200, q_(this.i, this.u, this.A, this.l, this.R, fe, E), this.o) {
            if (this.T && !this.K) {
              e: {
                if (this.g) {
                  var xt, le = this.g;
                  if ((xt = le.g ? le.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !T(xt)) {
                    var dt = xt;
                    break e;
                  }
                }
                dt = null;
              }
              if (E = dt) ir(this.i, this.l, E, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, kl(this, E);
              else {
                this.o = !1, this.s = 3, Te(12), vi(this), ls(this);
                break t;
              }
            }
            if (this.P) {
              E = !0;
              let an;
              for (; !this.J && this.C < G.length; ) if (an = X_(this, G), an == Pl) {
                fe == 4 && (this.s = 4, Te(14), E = !1), ir(this.i, this.l, null, "[Incomplete Response]");
                break;
              } else if (an == gd) {
                this.s = 4, Te(15), ir(this.i, this.l, G, "[Invalid Chunk]"), E = !1;
                break;
              } else ir(this.i, this.l, an, null), kl(this, an);
              if (_d(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C), this.C = 0), fe != 4 || G.length != 0 || this.h.h || (this.s = 1, Te(16), E = !1), this.o = this.o && E, !E) ir(this.i, this.l, G, "[Invalid Chunked Response]"), vi(this), ls(this);
              else if (0 < G.length && !this.W) {
                this.W = !0;
                var pe = this.j;
                pe.g == this && pe.ba && !pe.M && (pe.j.info("Great, no buffering proxy detected. Bytes received: " + G.length), Fl(pe), pe.M = !0, Te(11));
              }
            } else ir(this.i, this.l, G, null), kl(this, G);
            fe == 4 && vi(this), this.o && !this.J && (fe == 4 ? qd(this.j, this) : (this.o = !1, Co(this)));
          } else uv(this.g), E == 400 && 0 < G.indexOf("Unknown SID") ? (this.s = 3, Te(12)) : (this.s = 0, Te(13)), vi(this), ls(this);
        }
      }
    } catch {
    } finally {
    }
  };
  function _d(d) {
    return d.g ? d.u == "GET" && d.L != 2 && d.j.Ca : !1;
  }
  function X_(d, v) {
    var E = d.C, V = v.indexOf(`
`, E);
    return V == -1 ? Pl : (E = Number(v.substring(E, V)), isNaN(E) ? gd : (V += 1, V + E > v.length ? Pl : (v = v.slice(V, V + E), d.C = V + E, v)));
  }
  Wn.prototype.cancel = function() {
    this.J = !0, vi(this);
  };
  function Co(d) {
    d.S = Date.now() + d.I, vd(d, d.I);
  }
  function vd(d, v) {
    if (d.B != null) throw Error("WatchDog timer not null");
    d.B = os(f(d.ba, d), v);
  }
  function Rl(d) {
    d.B && (a.clearTimeout(d.B), d.B = null);
  }
  Wn.prototype.ba = function() {
    this.B = null;
    const d = Date.now();
    0 <= d - this.S ? (W_(this.i, this.A), this.L != 2 && (ss(), Te(17)), vi(this), this.s = 2, ls(this)) : vd(this, this.S - d);
  };
  function ls(d) {
    d.j.G == 0 || d.J || qd(d.j, d);
  }
  function vi(d) {
    Rl(d);
    var v = d.M;
    v && typeof v.ma == "function" && v.ma(), d.M = null, ad(d.U), d.g && (v = d.g, d.g = null, v.abort(), v.ma());
  }
  function kl(d, v) {
    try {
      var E = d.j;
      if (E.G != 0 && (E.g == d || Ml(E.h, d))) {
        if (!d.K && Ml(E.h, d) && E.G == 3) {
          try {
            var V = E.Da.g.parse(v);
          } catch {
            V = null;
          }
          if (Array.isArray(V) && V.length == 3) {
            var D = V;
            if (D[0] == 0) {
              t:
                if (!E.u) {
                  if (E.g) if (E.g.F + 3e3 < d.F) Oo(E), Do(E);
                  else break t;
                  Ol(E), Te(18);
                }
            } else E.za = D[1], 0 < E.za - E.T && 37500 > D[2] && E.F && E.v == 0 && !E.C && (E.C = os(f(E.Za, E), 6e3));
            if (1 >= wd(E.h) && E.ca) {
              try {
                E.ca();
              } catch {
              }
              E.ca = void 0;
            }
          } else bi(E, 11);
        } else if ((d.K || E.g == d) && Oo(E), !T(v)) for (D = E.Da.g.parse(v), v = 0; v < D.length; v++) {
          let dt = D[v];
          if (E.T = dt[0], dt = dt[1], E.G == 2) if (dt[0] == "c") {
            E.K = dt[1], E.ia = dt[2];
            const pe = dt[3];
            pe != null && (E.la = pe, E.j.info("VER=" + E.la));
            const fe = dt[4];
            fe != null && (E.Aa = fe, E.j.info("SVER=" + E.Aa));
            const or = dt[5];
            or != null && typeof or == "number" && 0 < or && (V = 1.5 * or, E.L = V, E.j.info("backChannelRequestTimeoutMs_=" + V)), V = E;
            const an = d.g;
            if (an) {
              const Lo = an.g ? an.g.getResponseHeader("X-Client-Wire-Protocol") : null;
              if (Lo) {
                var F = V.h;
                F.g || Lo.indexOf("spdy") == -1 && Lo.indexOf("quic") == -1 && Lo.indexOf("h2") == -1 || (F.j = F.l, F.g = /* @__PURE__ */ new Set(), F.h && (Vl(F, F.h), F.h = null));
              }
              if (V.D) {
                const Ll = an.g ? an.g.getResponseHeader("X-HTTP-Session-Id") : null;
                Ll && (V.ya = Ll, At(V.I, V.D, Ll));
              }
            }
            E.G = 3, E.l && E.l.ua(), E.ba && (E.R = Date.now() - d.F, E.j.info("Handshake RTT: " + E.R + "ms")), V = E;
            var G = d;
            if (V.qa = Xd(V, V.J ? V.ia : null, V.W), G.K) {
              Ad(V.h, G);
              var xt = G, le = V.L;
              le && (xt.I = le), xt.B && (Rl(xt), Co(xt)), V.g = G;
            } else Gd(V);
            0 < E.i.length && Bo(E);
          } else dt[0] != "stop" && dt[0] != "close" || bi(E, 7);
          else E.G == 3 && (dt[0] == "stop" || dt[0] == "close" ? dt[0] == "stop" ? bi(E, 7) : Bl(E) : dt[0] != "noop" && E.l && E.l.ta(dt), E.v = 0);
        }
      }
      ss(4);
    } catch {
    }
  }
  var K_ = class {
    constructor(d, v) {
      this.g = d, this.map = v;
    }
  };
  function xd(d) {
    this.l = d || 10, a.PerformanceNavigationTiming ? (d = a.performance.getEntriesByType("navigation"), d = 0 < d.length && (d[0].nextHopProtocol == "hq" || d[0].nextHopProtocol == "h2")) : d = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy), this.j = d ? this.l : 1, this.g = null, 1 < this.j && (this.g = /* @__PURE__ */ new Set()), this.h = null, this.i = [];
  }
  function bd(d) {
    return d.h ? !0 : d.g ? d.g.size >= d.j : !1;
  }
  function wd(d) {
    return d.h ? 1 : d.g ? d.g.size : 0;
  }
  function Ml(d, v) {
    return d.h ? d.h == v : d.g ? d.g.has(v) : !1;
  }
  function Vl(d, v) {
    d.g ? d.g.add(v) : d.h = v;
  }
  function Ad(d, v) {
    d.h && d.h == v ? d.h = null : d.g && d.g.has(v) && d.g.delete(v);
  }
  xd.prototype.cancel = function() {
    if (this.i = Td(this), this.h) this.h.cancel(), this.h = null;
    else if (this.g && this.g.size !== 0) {
      for (const d of this.g.values()) d.cancel();
      this.g.clear();
    }
  };
  function Td(d) {
    if (d.h != null) return d.i.concat(d.h.D);
    if (d.g != null && d.g.size !== 0) {
      let v = d.i;
      for (const E of d.g.values()) v = v.concat(E.D);
      return v;
    }
    return g(d.i);
  }
  function Q_(d) {
    if (d.V && typeof d.V == "function") return d.V();
    if (typeof Map < "u" && d instanceof Map || typeof Set < "u" && d instanceof Set) return Array.from(d.values());
    if (typeof d == "string") return d.split("");
    if (l(d)) {
      for (var v = [], E = d.length, V = 0; V < E; V++) v.push(d[V]);
      return v;
    }
    v = [], E = 0;
    for (V in d) v[E++] = d[V];
    return v;
  }
  function J_(d) {
    if (d.na && typeof d.na == "function") return d.na();
    if (!d.V || typeof d.V != "function") {
      if (typeof Map < "u" && d instanceof Map) return Array.from(d.keys());
      if (!(typeof Set < "u" && d instanceof Set)) {
        if (l(d) || typeof d == "string") {
          var v = [];
          d = d.length;
          for (var E = 0; E < d; E++) v.push(E);
          return v;
        }
        v = [], E = 0;
        for (const V in d) v[E++] = V;
        return v;
      }
    }
  }
  function Sd(d, v) {
    if (d.forEach && typeof d.forEach == "function") d.forEach(v, void 0);
    else if (l(d) || typeof d == "string") Array.prototype.forEach.call(d, v, void 0);
    else for (var E = J_(d), V = Q_(d), D = V.length, F = 0; F < D; F++) v.call(void 0, V[F], E && E[F], d);
  }
  var Ed = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
  function Z_(d, v) {
    if (d) {
      d = d.split("&");
      for (var E = 0; E < d.length; E++) {
        var V = d[E].indexOf("="), D = null;
        if (0 <= V) {
          var F = d[E].substring(0, V);
          D = d[E].substring(V + 1);
        } else F = d[E];
        v(F, D ? decodeURIComponent(D.replace(/\+/g, " ")) : "");
      }
    }
  }
  function xi(d) {
    if (this.g = this.o = this.j = "", this.s = null, this.m = this.l = "", this.h = !1, d instanceof xi) {
      this.h = d.h, Po(this, d.j), this.o = d.o, this.g = d.g, Io(this, d.s), this.l = d.l;
      var v = d.i, E = new us();
      E.i = v.i, v.g && (E.g = new Map(v.g), E.h = v.h), Cd(this, E), this.m = d.m;
    } else d && (v = String(d).match(Ed)) ? (this.h = !1, Po(this, v[1] || "", !0), this.o = hs(v[2] || ""), this.g = hs(v[3] || "", !0), Io(this, v[4]), this.l = hs(v[5] || "", !0), Cd(this, v[6] || "", !0), this.m = hs(v[7] || "")) : (this.h = !1, this.i = new us(null, this.h));
  }
  xi.prototype.toString = function() {
    var d = [], v = this.j;
    v && d.push(cs(v, Pd, !0), ":");
    var E = this.g;
    return (E || v == "file") && (d.push("//"), (v = this.o) && d.push(cs(v, Pd, !0), "@"), d.push(encodeURIComponent(String(E)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), E = this.s, E != null && d.push(":", String(E))), (E = this.l) && (this.g && E.charAt(0) != "/" && d.push("/"), d.push(cs(E, E.charAt(0) == "/" ? ev : tv, !0))), (E = this.i.toString()) && d.push("?", E), (E = this.m) && d.push("#", cs(E, iv)), d.join("");
  };
  function In(d) {
    return new xi(d);
  }
  function Po(d, v, E) {
    d.j = E ? hs(v, !0) : v, d.j && (d.j = d.j.replace(/:$/, ""));
  }
  function Io(d, v) {
    if (v) {
      if (v = Number(v), isNaN(v) || 0 > v) throw Error("Bad port number " + v);
      d.s = v;
    } else d.s = null;
  }
  function Cd(d, v, E) {
    v instanceof us ? (d.i = v, rv(d.i, d.h)) : (E || (v = cs(v, nv)), d.i = new us(v, d.h));
  }
  function At(d, v, E) {
    d.i.set(v, E);
  }
  function Ro(d) {
    return At(d, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), d;
  }
  function hs(d, v) {
    return d ? v ? decodeURI(d.replace(/%25/g, "%2525")) : decodeURIComponent(d) : "";
  }
  function cs(d, v, E) {
    return typeof d == "string" ? (d = encodeURI(d).replace(v, $_), E && (d = d.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), d) : null;
  }
  function $_(d) {
    return d = d.charCodeAt(0), "%" + (d >> 4 & 15).toString(16) + (d & 15).toString(16);
  }
  var Pd = /[#\/\?@]/g, tv = /[#\?:]/g, ev = /[#\?]/g, nv = /[#\?@]/g, iv = /#/g;
  function us(d, v) {
    this.h = this.g = null, this.i = d || null, this.j = !!v;
  }
  function Yn(d) {
    d.g || (d.g = /* @__PURE__ */ new Map(), d.h = 0, d.i && Z_(d.i, function(v, E) {
      d.add(decodeURIComponent(v.replace(/\+/g, " ")), E);
    }));
  }
  n = us.prototype, n.add = function(d, v) {
    Yn(this), this.i = null, d = rr(this, d);
    var E = this.g.get(d);
    return E || this.g.set(d, E = []), E.push(v), this.h += 1, this;
  };
  function Id(d, v) {
    Yn(d), v = rr(d, v), d.g.has(v) && (d.i = null, d.h -= d.g.get(v).length, d.g.delete(v));
  }
  function Rd(d, v) {
    return Yn(d), v = rr(d, v), d.g.has(v);
  }
  n.forEach = function(d, v) {
    Yn(this), this.g.forEach(function(E, V) {
      E.forEach(function(D) {
        d.call(v, D, V, this);
      }, this);
    }, this);
  }, n.na = function() {
    Yn(this);
    const d = Array.from(this.g.values()), v = Array.from(this.g.keys()), E = [];
    for (let V = 0; V < v.length; V++) {
      const D = d[V];
      for (let F = 0; F < D.length; F++) E.push(v[V]);
    }
    return E;
  }, n.V = function(d) {
    Yn(this);
    let v = [];
    if (typeof d == "string") Rd(this, d) && (v = v.concat(this.g.get(rr(this, d))));
    else {
      d = Array.from(this.g.values());
      for (let E = 0; E < d.length; E++) v = v.concat(d[E]);
    }
    return v;
  }, n.set = function(d, v) {
    return Yn(this), this.i = null, d = rr(this, d), Rd(this, d) && (this.h -= this.g.get(d).length), this.g.set(d, [v]), this.h += 1, this;
  }, n.get = function(d, v) {
    return d ? (d = this.V(d), 0 < d.length ? String(d[0]) : v) : v;
  };
  function kd(d, v, E) {
    Id(d, v), 0 < E.length && (d.i = null, d.g.set(rr(d, v), g(E)), d.h += E.length);
  }
  n.toString = function() {
    if (this.i) return this.i;
    if (!this.g) return "";
    const d = [], v = Array.from(this.g.keys());
    for (var E = 0; E < v.length; E++) {
      var V = v[E];
      const F = encodeURIComponent(String(V)), G = this.V(V);
      for (V = 0; V < G.length; V++) {
        var D = F;
        G[V] !== "" && (D += "=" + encodeURIComponent(String(G[V]))), d.push(D);
      }
    }
    return this.i = d.join("&");
  };
  function rr(d, v) {
    return v = String(v), d.j && (v = v.toLowerCase()), v;
  }
  function rv(d, v) {
    v && !d.j && (Yn(d), d.i = null, d.g.forEach(function(E, V) {
      var D = V.toLowerCase();
      V != D && (Id(this, V), kd(this, D, E));
    }, d)), d.j = v;
  }
  function sv(d, v) {
    const E = new as();
    if (a.Image) {
      const V = new Image();
      V.onload = u(Xn, E, "TestLoadImage: loaded", !0, v, V), V.onerror = u(Xn, E, "TestLoadImage: error", !1, v, V), V.onabort = u(Xn, E, "TestLoadImage: abort", !1, v, V), V.ontimeout = u(Xn, E, "TestLoadImage: timeout", !1, v, V), a.setTimeout(function() {
        V.ontimeout && V.ontimeout();
      }, 1e4), V.src = d;
    } else v(!1);
  }
  function ov(d, v) {
    const E = new as(), V = new AbortController(), D = setTimeout(() => {
      V.abort(), Xn(E, "TestPingServer: timeout", !1, v);
    }, 1e4);
    fetch(d, { signal: V.signal }).then((F) => {
      clearTimeout(D), F.ok ? Xn(E, "TestPingServer: ok", !0, v) : Xn(E, "TestPingServer: server error", !1, v);
    }).catch(() => {
      clearTimeout(D), Xn(E, "TestPingServer: error", !1, v);
    });
  }
  function Xn(d, v, E, V, D) {
    try {
      D && (D.onload = null, D.onerror = null, D.onabort = null, D.ontimeout = null), V(E);
    } catch {
    }
  }
  function av() {
    this.g = new G_();
  }
  function lv(d, v, E) {
    const V = E || "";
    try {
      Sd(d, function(D, F) {
        let G = D;
        h(D) && (G = Al(D)), v.push(V + F + "=" + encodeURIComponent(G));
      });
    } catch (D) {
      throw v.push(V + "type=" + encodeURIComponent("_badmap")), D;
    }
  }
  function ko(d) {
    this.l = d.Ub || null, this.j = d.eb || !1;
  }
  m(ko, Tl), ko.prototype.g = function() {
    return new Mo(this.l, this.j);
  }, ko.prototype.i = /* @__PURE__ */ function(d) {
    return function() {
      return d;
    };
  }({});
  function Mo(d, v) {
    Nt.call(this), this.D = d, this.o = v, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.u = new Headers(), this.h = null, this.B = "GET", this.A = "", this.g = !1, this.v = this.j = this.l = null;
  }
  m(Mo, Nt), n = Mo.prototype, n.open = function(d, v) {
    if (this.readyState != 0) throw this.abort(), Error("Error reopening a connection");
    this.B = d, this.A = v, this.readyState = 1, ps(this);
  }, n.send = function(d) {
    if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
    this.g = !0;
    const v = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 };
    d && (v.body = d), (this.D || a).fetch(new Request(this.A, v)).then(this.Sa.bind(this), this.ga.bind(this));
  }, n.abort = function() {
    this.response = this.responseText = "", this.u = new Headers(), this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {
    }), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, ds(this)), this.readyState = 0;
  }, n.Sa = function(d) {
    if (this.g && (this.l = d, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = d.headers, this.readyState = 2, ps(this)), this.g && (this.readyState = 3, ps(this), this.g))) if (this.responseType === "arraybuffer") d.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
    else if (typeof a.ReadableStream < "u" && "body" in d) {
      if (this.j = d.body.getReader(), this.o) {
        if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else this.response = this.responseText = "", this.v = new TextDecoder();
      Md(this);
    } else d.text().then(this.Ra.bind(this), this.ga.bind(this));
  };
  function Md(d) {
    d.j.read().then(d.Pa.bind(d)).catch(d.ga.bind(d));
  }
  n.Pa = function(d) {
    if (this.g) {
      if (this.o && d.value) this.response.push(d.value);
      else if (!this.o) {
        var v = d.value ? d.value : new Uint8Array(0);
        (v = this.v.decode(v, { stream: !d.done })) && (this.response = this.responseText += v);
      }
      d.done ? ds(this) : ps(this), this.readyState == 3 && Md(this);
    }
  }, n.Ra = function(d) {
    this.g && (this.response = this.responseText = d, ds(this));
  }, n.Qa = function(d) {
    this.g && (this.response = d, ds(this));
  }, n.ga = function() {
    this.g && ds(this);
  };
  function ds(d) {
    d.readyState = 4, d.l = null, d.j = null, d.v = null, ps(d);
  }
  n.setRequestHeader = function(d, v) {
    this.u.append(d, v);
  }, n.getResponseHeader = function(d) {
    return this.h && this.h.get(d.toLowerCase()) || "";
  }, n.getAllResponseHeaders = function() {
    if (!this.h) return "";
    const d = [], v = this.h.entries();
    for (var E = v.next(); !E.done; ) E = E.value, d.push(E[0] + ": " + E[1]), E = v.next();
    return d.join(`\r
`);
  };
  function ps(d) {
    d.onreadystatechange && d.onreadystatechange.call(d);
  }
  Object.defineProperty(Mo.prototype, "withCredentials", { get: function() {
    return this.m === "include";
  }, set: function(d) {
    this.m = d ? "include" : "same-origin";
  } });
  function Vd(d) {
    let v = "";
    return I(d, function(E, V) {
      v += V, v += ":", v += E, v += `\r
`;
    }), v;
  }
  function Dl(d, v, E) {
    t: {
      for (V in E) {
        var V = !1;
        break t;
      }
      V = !0;
    }
    V || (E = Vd(E), typeof d == "string" ? E != null && encodeURIComponent(String(E)) : At(d, v, E));
  }
  function Ft(d) {
    Nt.call(this), this.headers = /* @__PURE__ */ new Map(), this.o = d || null, this.h = !1, this.v = this.g = null, this.D = "", this.m = 0, this.l = "", this.j = this.B = this.u = this.A = !1, this.I = null, this.H = "", this.J = !1;
  }
  m(Ft, Nt);
  var hv = /^https?$/i, cv = ["POST", "PUT"];
  n = Ft.prototype, n.Ha = function(d) {
    this.J = d;
  }, n.ea = function(d, v, E, V) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + d);
    v = v ? v.toUpperCase() : "GET", this.D = d, this.l = "", this.m = 0, this.A = !1, this.h = !0, this.g = this.o ? this.o.g() : Cl.g(), this.v = this.o ? ld(this.o) : ld(Cl), this.g.onreadystatechange = f(this.Ea, this);
    try {
      this.B = !0, this.g.open(v, String(d), !0), this.B = !1;
    } catch (F) {
      Dd(this, F);
      return;
    }
    if (d = E || "", E = new Map(this.headers), V) if (Object.getPrototypeOf(V) === Object.prototype) for (var D in V) E.set(D, V[D]);
    else if (typeof V.keys == "function" && typeof V.get == "function") for (const F of V.keys()) E.set(F, V.get(F));
    else throw Error("Unknown input type for opt_headers: " + String(V));
    V = Array.from(E.keys()).find((F) => F.toLowerCase() == "content-type"), D = a.FormData && d instanceof a.FormData, !(0 <= Array.prototype.indexOf.call(cv, v, void 0)) || V || D || E.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [F, G] of E) this.g.setRequestHeader(F, G);
    this.H && (this.g.responseType = this.H), "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
    try {
      Fd(this), this.u = !0, this.g.send(d), this.u = !1;
    } catch (F) {
      Dd(this, F);
    }
  };
  function Dd(d, v) {
    d.h = !1, d.g && (d.j = !0, d.g.abort(), d.j = !1), d.l = v, d.m = 5, Bd(d), Vo(d);
  }
  function Bd(d) {
    d.A || (d.A = !0, ae(d, "complete"), ae(d, "error"));
  }
  n.abort = function(d) {
    this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.m = d || 7, ae(this, "complete"), ae(this, "abort"), Vo(this));
  }, n.N = function() {
    this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), Vo(this, !0)), Ft.aa.N.call(this);
  }, n.Ea = function() {
    this.s || (this.B || this.u || this.j ? Od(this) : this.bb());
  }, n.bb = function() {
    Od(this);
  };
  function Od(d) {
    if (d.h && typeof o < "u" && (!d.v[1] || Rn(d) != 4 || d.Z() != 2)) {
      if (d.u && Rn(d) == 4) gi(d.Ea, 0, d);
      else if (ae(d, "readystatechange"), Rn(d) == 4) {
        d.h = !1;
        try {
          const G = d.Z();
          t: switch (G) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var v = !0;
              break t;
            default:
              v = !1;
          }
          var E;
          if (!(E = v)) {
            var V;
            if (V = G === 0) {
              var D = String(d.D).match(Ed)[1] || null;
              !D && a.self && a.self.location && (D = a.self.location.protocol.slice(0, -1)), V = !hv.test(D ? D.toLowerCase() : "");
            }
            E = V;
          }
          if (E) ae(d, "complete"), ae(d, "success");
          else {
            d.m = 6;
            try {
              var F = 2 < Rn(d) ? d.g.statusText : "";
            } catch {
              F = "";
            }
            d.l = F + " [" + d.Z() + "]", Bd(d);
          }
        } finally {
          Vo(d);
        }
      }
    }
  }
  function Vo(d, v) {
    if (d.g) {
      Fd(d);
      const E = d.g, V = d.v[0] ? () => {
      } : null;
      d.g = null, d.v = null, v || ae(d, "ready");
      try {
        E.onreadystatechange = V;
      } catch {
      }
    }
  }
  function Fd(d) {
    d.I && (a.clearTimeout(d.I), d.I = null);
  }
  n.isActive = function() {
    return !!this.g;
  };
  function Rn(d) {
    return d.g ? d.g.readyState : 0;
  }
  n.Z = function() {
    try {
      return 2 < Rn(this) ? this.g.status : -1;
    } catch {
      return -1;
    }
  }, n.oa = function() {
    try {
      return this.g ? this.g.responseText : "";
    } catch {
      return "";
    }
  }, n.Oa = function(d) {
    if (this.g) {
      var v = this.g.responseText;
      return d && v.indexOf(d) == 0 && (v = v.substring(d.length)), j_(v);
    }
  };
  function Ld(d) {
    try {
      if (!d.g) return null;
      if ("response" in d.g) return d.g.response;
      switch (d.H) {
        case "":
        case "text":
          return d.g.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in d.g) return d.g.mozResponseArrayBuffer;
      }
      return null;
    } catch {
      return null;
    }
  }
  function uv(d) {
    const v = {};
    d = (d.g && 2 <= Rn(d) && d.g.getAllResponseHeaders() || "").split(`\r
`);
    for (let V = 0; V < d.length; V++) {
      if (T(d[V])) continue;
      var E = R(d[V]);
      const D = E[0];
      if (E = E[1], typeof E != "string") continue;
      E = E.trim();
      const F = v[D] || [];
      v[D] = F, F.push(E);
    }
    w(v, function(V) {
      return V.join(", ");
    });
  }
  n.Ba = function() {
    return this.m;
  }, n.Ka = function() {
    return typeof this.l == "string" ? this.l : String(this.l);
  };
  function fs(d, v, E) {
    return E && E.internalChannelParams && E.internalChannelParams[d] || v;
  }
  function Nd(d) {
    this.Aa = 0, this.i = [], this.j = new as(), this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null, this.Ya = this.U = 0, this.Va = fs("failFast", !1, d), this.F = this.C = this.u = this.s = this.l = null, this.X = !0, this.za = this.T = -1, this.Y = this.v = this.B = 0, this.Ta = fs("baseRetryDelayMs", 5e3, d), this.cb = fs("retryDelaySeedMs", 1e4, d), this.Wa = fs("forwardChannelMaxRetries", 2, d), this.wa = fs("forwardChannelRequestTimeoutMs", 2e4, d), this.pa = d && d.xmlHttpFactory || void 0, this.Xa = d && d.Tb || void 0, this.Ca = d && d.useFetchStreams || !1, this.L = void 0, this.J = d && d.supportsCrossDomainXhr || !1, this.K = "", this.h = new xd(d && d.concurrentRequestLimit), this.Da = new av(), this.P = d && d.fastHandshake || !1, this.O = d && d.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.Ua = d && d.Rb || !1, d && d.xa && this.j.xa(), d && d.forceLongPolling && (this.X = !1), this.ba = !this.P && this.X && d && d.detectBufferingProxy || !1, this.ja = void 0, d && d.longPollingTimeout && 0 < d.longPollingTimeout && (this.ja = d.longPollingTimeout), this.ca = void 0, this.R = 0, this.M = !1, this.ka = this.A = null;
  }
  n = Nd.prototype, n.la = 8, n.G = 1, n.connect = function(d, v, E, V) {
    Te(0), this.W = d, this.H = v || {}, E && V !== void 0 && (this.H.OSID = E, this.H.OAID = V), this.F = this.X, this.I = Xd(this, null, this.W), Bo(this);
  };
  function Bl(d) {
    if (Ud(d), d.G == 3) {
      var v = d.U++, E = In(d.I);
      if (At(E, "SID", d.K), At(E, "RID", v), At(E, "TYPE", "terminate"), ms(d, E), v = new Wn(d, d.j, v), v.L = 2, v.v = Ro(In(E)), E = !1, a.navigator && a.navigator.sendBeacon) try {
        E = a.navigator.sendBeacon(v.v.toString(), "");
      } catch {
      }
      !E && a.Image && (new Image().src = v.v, E = !0), E || (v.g = Kd(v.j, null), v.g.ea(v.v)), v.F = Date.now(), Co(v);
    }
    Yd(d);
  }
  function Do(d) {
    d.g && (Fl(d), d.g.cancel(), d.g = null);
  }
  function Ud(d) {
    Do(d), d.u && (a.clearTimeout(d.u), d.u = null), Oo(d), d.h.cancel(), d.s && (typeof d.s == "number" && a.clearTimeout(d.s), d.s = null);
  }
  function Bo(d) {
    if (!bd(d.h) && !d.s) {
      d.s = !0;
      var v = d.Ga;
      z || H(), Q || (z(), Q = !0), j.add(v, d), d.B = 0;
    }
  }
  function dv(d, v) {
    return wd(d.h) >= d.h.j - (d.s ? 1 : 0) ? !1 : d.s ? (d.i = v.D.concat(d.i), !0) : d.G == 1 || d.G == 2 || d.B >= (d.Va ? 0 : d.Wa) ? !1 : (d.s = os(f(d.Ga, d, v), Wd(d, d.B)), d.B++, !0);
  }
  n.Ga = function(d) {
    if (this.s) if (this.s = null, this.G == 1) {
      if (!d) {
        this.U = Math.floor(1e5 * Math.random()), d = this.U++;
        const D = new Wn(this, this.j, d);
        let F = this.o;
        if (this.S && (F ? (F = _(F), A(F, this.S)) : F = this.S), this.m !== null || this.O || (D.H = F, F = null), this.P) t: {
          for (var v = 0, E = 0; E < this.i.length; E++) {
            e: {
              var V = this.i[E];
              if ("__data__" in V.map && (V = V.map.__data__, typeof V == "string")) {
                V = V.length;
                break e;
              }
              V = void 0;
            }
            if (V === void 0) break;
            if (v += V, 4096 < v) {
              v = E;
              break t;
            }
            if (v === 4096 || E === this.i.length - 1) {
              v = E + 1;
              break t;
            }
          }
          v = 1e3;
        }
        else v = 1e3;
        v = jd(this, D, v), E = In(this.I), At(E, "RID", d), At(E, "CVER", 22), this.D && At(E, "X-HTTP-Session-Id", this.D), ms(this, E), F && (this.O ? v = "headers=" + encodeURIComponent(String(Vd(F))) + "&" + v : this.m && Dl(E, this.m, F)), Vl(this.h, D), this.Ua && At(E, "TYPE", "init"), this.P ? (At(E, "$req", v), At(E, "SID", "null"), D.T = !0, Il(D, E, null)) : Il(D, E, v), this.G = 2;
      }
    } else this.G == 3 && (d ? zd(this, d) : this.i.length == 0 || bd(this.h) || zd(this));
  };
  function zd(d, v) {
    var E;
    v ? E = v.l : E = d.U++;
    const V = In(d.I);
    At(V, "SID", d.K), At(V, "RID", E), At(V, "AID", d.T), ms(d, V), d.m && d.o && Dl(V, d.m, d.o), E = new Wn(d, d.j, E, d.B + 1), d.m === null && (E.H = d.o), v && (d.i = v.D.concat(d.i)), v = jd(d, E, 1e3), E.I = Math.round(0.5 * d.wa) + Math.round(0.5 * d.wa * Math.random()), Vl(d.h, E), Il(E, V, v);
  }
  function ms(d, v) {
    d.H && I(d.H, function(E, V) {
      At(v, V, E);
    }), d.l && Sd({}, function(E, V) {
      At(v, V, E);
    });
  }
  function jd(d, v, E) {
    E = Math.min(d.i.length, E);
    var V = d.l ? f(d.l.Na, d.l, d) : null;
    t: {
      var D = d.i;
      let F = -1;
      for (; ; ) {
        const G = ["count=" + E];
        F == -1 ? 0 < E ? (F = D[0].g, G.push("ofs=" + F)) : F = 0 : G.push("ofs=" + F);
        let xt = !0;
        for (let le = 0; le < E; le++) {
          let dt = D[le].g;
          const pe = D[le].map;
          if (dt -= F, 0 > dt) F = Math.max(0, D[le].g - 100), xt = !1;
          else try {
            lv(pe, G, "req" + dt + "_");
          } catch {
            V && V(pe);
          }
        }
        if (xt) {
          V = G.join("&");
          break t;
        }
      }
    }
    return d = d.i.splice(0, E), v.D = d, V;
  }
  function Gd(d) {
    if (!d.g && !d.u) {
      d.Y = 1;
      var v = d.Fa;
      z || H(), Q || (z(), Q = !0), j.add(v, d), d.v = 0;
    }
  }
  function Ol(d) {
    return d.g || d.u || 3 <= d.v ? !1 : (d.Y++, d.u = os(f(d.Fa, d), Wd(d, d.v)), d.v++, !0);
  }
  n.Fa = function() {
    if (this.u = null, Hd(this), this.ba && !(this.M || this.g == null || 0 >= this.R)) {
      var d = 2 * this.R;
      this.j.info("BP detection timer enabled: " + d), this.A = os(f(this.ab, this), d);
    }
  }, n.ab = function() {
    this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.M = !0, Te(10), Do(this), Hd(this));
  };
  function Fl(d) {
    d.A != null && (a.clearTimeout(d.A), d.A = null);
  }
  function Hd(d) {
    d.g = new Wn(d, d.j, "rpc", d.Y), d.m === null && (d.g.H = d.o), d.g.O = 0;
    var v = In(d.qa);
    At(v, "RID", "rpc"), At(v, "SID", d.K), At(v, "AID", d.T), At(v, "CI", d.F ? "0" : "1"), !d.F && d.ja && At(v, "TO", d.ja), At(v, "TYPE", "xmlhttp"), ms(d, v), d.m && d.o && Dl(v, d.m, d.o), d.L && (d.g.I = d.L);
    var E = d.g;
    d = d.ia, E.L = 1, E.v = Ro(In(v)), E.m = null, E.P = !0, yd(E, d);
  }
  n.Za = function() {
    this.C != null && (this.C = null, Do(this), Ol(this), Te(19));
  };
  function Oo(d) {
    d.C != null && (a.clearTimeout(d.C), d.C = null);
  }
  function qd(d, v) {
    var E = null;
    if (d.g == v) {
      Oo(d), Fl(d), d.g = null;
      var V = 2;
    } else if (Ml(d.h, v)) E = v.D, Ad(d.h, v), V = 1;
    else return;
    if (d.G != 0) {
      if (v.o) if (V == 1) {
        E = v.m ? v.m.length : 0, v = Date.now() - v.F;
        var D = d.B;
        V = To(), ae(V, new pd(V, E)), Bo(d);
      } else Gd(d);
      else if (D = v.s, D == 3 || D == 0 && 0 < v.X || !(V == 1 && dv(d, v) || V == 2 && Ol(d))) switch (E && 0 < E.length && (v = d.h, v.i = v.i.concat(E)), D) {
        case 1:
          bi(d, 5);
          break;
        case 4:
          bi(d, 10);
          break;
        case 3:
          bi(d, 6);
          break;
        default:
          bi(d, 2);
      }
    }
  }
  function Wd(d, v) {
    let E = d.Ta + Math.floor(Math.random() * d.cb);
    return d.isActive() || (E *= 2), E * v;
  }
  function bi(d, v) {
    if (d.j.info("Error code " + v), v == 2) {
      var E = f(d.fb, d), V = d.Xa;
      const D = !V;
      V = new xi(V || "//www.google.com/images/cleardot.gif"), a.location && a.location.protocol == "http" || Po(V, "https"), Ro(V), D ? sv(V.toString(), E) : ov(V.toString(), E);
    } else Te(2);
    d.G = 0, d.l && d.l.sa(v), Yd(d), Ud(d);
  }
  n.fb = function(d) {
    d ? (this.j.info("Successfully pinged google.com"), Te(2)) : (this.j.info("Failed to ping google.com"), Te(1));
  };
  function Yd(d) {
    if (d.G = 0, d.ka = [], d.l) {
      const v = Td(d.h);
      (v.length != 0 || d.i.length != 0) && (y(d.ka, v), y(d.ka, d.i), d.h.i.length = 0, g(d.i), d.i.length = 0), d.l.ra();
    }
  }
  function Xd(d, v, E) {
    var V = E instanceof xi ? In(E) : new xi(E);
    if (V.g != "") v && (V.g = v + "." + V.g), Io(V, V.s);
    else {
      var D = a.location;
      V = D.protocol, v = v ? v + "." + D.hostname : D.hostname, D = +D.port;
      var F = new xi(null);
      V && Po(F, V), v && (F.g = v), D && Io(F, D), E && (F.l = E), V = F;
    }
    return E = d.D, v = d.ya, E && v && At(V, E, v), At(V, "VER", d.la), ms(d, V), V;
  }
  function Kd(d, v, E) {
    if (v && !d.J) throw Error("Can't create secondary domain capable XhrIo object.");
    return v = d.Ca && !d.pa ? new Ft(new ko({ eb: E })) : new Ft(d.pa), v.Ha(d.J), v;
  }
  n.isActive = function() {
    return !!this.l && this.l.isActive(this);
  };
  function Qd() {
  }
  n = Qd.prototype, n.ua = function() {
  }, n.ta = function() {
  }, n.sa = function() {
  }, n.ra = function() {
  }, n.isActive = function() {
    return !0;
  }, n.Na = function() {
  };
  function Fo() {
  }
  Fo.prototype.g = function(d, v) {
    return new Ge(d, v);
  };
  function Ge(d, v) {
    Nt.call(this), this.g = new Nd(v), this.l = d, this.h = v && v.messageUrlParams || null, d = v && v.messageHeaders || null, v && v.clientProtocolHeaderRequired && (d ? d["X-Client-Protocol"] = "webchannel" : d = { "X-Client-Protocol": "webchannel" }), this.g.o = d, d = v && v.initMessageHeaders || null, v && v.messageContentType && (d ? d["X-WebChannel-Content-Type"] = v.messageContentType : d = { "X-WebChannel-Content-Type": v.messageContentType }), v && v.va && (d ? d["X-WebChannel-Client-Profile"] = v.va : d = { "X-WebChannel-Client-Profile": v.va }), this.g.S = d, (d = v && v.Sb) && !T(d) && (this.g.m = d), this.v = v && v.supportsCrossDomainXhr || !1, this.u = v && v.sendRawJson || !1, (v = v && v.httpSessionIdParam) && !T(v) && (this.g.D = v, d = this.h, d !== null && v in d && (d = this.h, v in d && delete d[v])), this.j = new sr(this);
  }
  m(Ge, Nt), Ge.prototype.m = function() {
    this.g.l = this.j, this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0);
  }, Ge.prototype.close = function() {
    Bl(this.g);
  }, Ge.prototype.o = function(d) {
    var v = this.g;
    if (typeof d == "string") {
      var E = {};
      E.__data__ = d, d = E;
    } else this.u && (E = {}, E.__data__ = Al(d), d = E);
    v.i.push(new K_(v.Ya++, d)), v.G == 3 && Bo(v);
  }, Ge.prototype.N = function() {
    this.g.l = null, delete this.j, Bl(this.g), delete this.g, Ge.aa.N.call(this);
  };
  function Jd(d) {
    Sl.call(this), d.__headers__ && (this.headers = d.__headers__, this.statusCode = d.__status__, delete d.__headers__, delete d.__status__);
    var v = d.__sm__;
    if (v) {
      t: {
        for (const E in v) {
          d = E;
          break t;
        }
        d = void 0;
      }
      (this.i = d) && (d = this.i, v = v !== null && d in v ? v[d] : void 0), this.data = v;
    } else this.data = d;
  }
  m(Jd, Sl);
  function Zd() {
    El.call(this), this.status = 1;
  }
  m(Zd, El);
  function sr(d) {
    this.g = d;
  }
  m(sr, Qd), sr.prototype.ua = function() {
    ae(this.g, "a");
  }, sr.prototype.ta = function(d) {
    ae(this.g, new Jd(d));
  }, sr.prototype.sa = function(d) {
    ae(this.g, new Zd());
  }, sr.prototype.ra = function() {
    ae(this.g, "b");
  }, Fo.prototype.createWebChannel = Fo.prototype.g, Ge.prototype.send = Ge.prototype.o, Ge.prototype.open = Ge.prototype.m, Ge.prototype.close = Ge.prototype.close, x0 = function() {
    return new Fo();
  }, v0 = function() {
    return To();
  }, _0 = _i, Ec = { mb: 0, pb: 1, qb: 2, Jb: 3, Ob: 4, Lb: 5, Mb: 6, Kb: 7, Ib: 8, Nb: 9, PROXY: 10, NOPROXY: 11, Gb: 12, Cb: 13, Db: 14, Bb: 15, Eb: 16, Fb: 17, ib: 18, hb: 19, jb: 20 }, So.NO_ERROR = 0, So.TIMEOUT = 8, So.HTTP_ERROR = 6, ua = So, fd.COMPLETE = "complete", y0 = fd, hd.EventType = rs, rs.OPEN = "a", rs.CLOSE = "b", rs.ERROR = "c", rs.MESSAGE = "d", Nt.prototype.listen = Nt.prototype.K, ks = hd, Ft.prototype.listenOnce = Ft.prototype.L, Ft.prototype.getLastError = Ft.prototype.Ka, Ft.prototype.getLastErrorCode = Ft.prototype.Ba, Ft.prototype.getStatus = Ft.prototype.Z, Ft.prototype.getResponseJson = Ft.prototype.Oa, Ft.prototype.getResponseText = Ft.prototype.oa, Ft.prototype.send = Ft.prototype.ea, Ft.prototype.setWithCredentials = Ft.prototype.Ha, g0 = Ft;
}).apply(typeof Jo < "u" ? Jo : typeof self < "u" ? self : typeof window < "u" ? window : {});
const Vf = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ge {
  constructor(t) {
    this.uid = t;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t) {
    return t.uid === this.uid;
  }
}
ge.UNAUTHENTICATED = new ge(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
ge.GOOGLE_CREDENTIALS = new ge("google-credentials-uid"), ge.FIRST_PARTY = new ge("first-party-uid"), ge.MOCK_USER = new ge("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Jr = "11.0.2";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yi = new h0("@firebase/firestore");
function ur() {
  return Yi.logLevel;
}
function q(n, ...t) {
  if (Yi.logLevel <= ut.DEBUG) {
    const e = t.map(Su);
    Yi.debug(`Firestore (${Jr}): ${n}`, ...e);
  }
}
function jn(n, ...t) {
  if (Yi.logLevel <= ut.ERROR) {
    const e = t.map(Su);
    Yi.error(`Firestore (${Jr}): ${n}`, ...e);
  }
}
function Fr(n, ...t) {
  if (Yi.logLevel <= ut.WARN) {
    const e = t.map(Su);
    Yi.warn(`Firestore (${Jr}): ${n}`, ...e);
  }
}
function Su(n) {
  if (typeof n == "string") return n;
  try {
    /**
    * @license
    * Copyright 2020 Google LLC
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    return function(e) {
      return JSON.stringify(e);
    }(n);
  } catch {
    return n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function et(n = "Unexpected state") {
  const t = `FIRESTORE (${Jr}) INTERNAL ASSERTION FAILED: ` + n;
  throw jn(t), new Error(t);
}
function yt(n, t) {
  n || et();
}
function it(n, t) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const N = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller cannot be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
class Y extends Qr {
  /** @hideconstructor */
  constructor(t, e) {
    super(t, e), this.code = t, this.message = e, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ri {
  constructor() {
    this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class b0 {
  constructor(t, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t}`);
  }
}
class jE {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
    t.enqueueRetryable(() => e(ge.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class GE {
  constructor(t) {
    this.token = t, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t, e) {
    this.changeListener = e, // Fire with initial user.
    t.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class HE {
  constructor(t) {
    this.t = t, /** Tracks the current User. */
    this.currentUser = ge.UNAUTHENTICATED, /**
     * Counter used to detect if the token changed while a getToken request was
     * outstanding.
     */
    this.i = 0, this.forceRefresh = !1, this.auth = null;
  }
  start(t, e) {
    yt(this.o === void 0);
    let i = this.i;
    const r = (l) => this.i !== i ? (i = this.i, e(l)) : Promise.resolve();
    let s = new ri();
    this.o = () => {
      this.i++, this.currentUser = this.u(), s.resolve(), s = new ri(), t.enqueueRetryable(() => r(this.currentUser));
    };
    const o = () => {
      const l = s;
      t.enqueueRetryable(async () => {
        await l.promise, await r(this.currentUser);
      });
    }, a = (l) => {
      q("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.o && (this.auth.addAuthTokenListener(this.o), o());
    };
    this.t.onInit((l) => a(l)), // Our users can initialize Auth right after Firestore, so we give it
    // a chance to register itself with the component framework before we
    // determine whether to start up in unauthenticated mode.
    setTimeout(() => {
      if (!this.auth) {
        const l = this.t.getImmediate({
          optional: !0
        });
        l ? a(l) : (
          // If auth is still not available, proceed with `null` user
          (q("FirebaseAuthCredentialsProvider", "Auth not yet detected"), s.resolve(), s = new ri())
        );
      }
    }, 0), o();
  }
  getToken() {
    const t = this.i, e = this.forceRefresh;
    return this.forceRefresh = !1, this.auth ? this.auth.getToken(e).then((i) => (
      // Cancel the request since the token changed while the request was
      // outstanding so the response is potentially for a previous user (which
      // user, we can't be sure).
      this.i !== t ? (q("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : i ? (yt(typeof i.accessToken == "string"), new b0(i.accessToken, this.currentUser)) : null
    )) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0;
  }
  // Auth.getUid() can return null even with a user logged in. It is because
  // getUid() is synchronous, but the auth code populating Uid is asynchronous.
  // This method should only be called in the AuthTokenListener callback
  // to guarantee to get the actual user.
  u() {
    const t = this.auth && this.auth.getUid();
    return yt(t === null || typeof t == "string"), new ge(t);
  }
}
class qE {
  constructor(t, e, i) {
    this.l = t, this.h = e, this.P = i, this.type = "FirstParty", this.user = ge.FIRST_PARTY, this.T = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  I() {
    return this.P ? this.P() : null;
  }
  get headers() {
    this.T.set("X-Goog-AuthUser", this.l);
    const t = this.I();
    return t && this.T.set("Authorization", t), this.h && this.T.set("X-Goog-Iam-Authorization-Token", this.h), this.T;
  }
}
class WE {
  constructor(t, e, i) {
    this.l = t, this.h = e, this.P = i;
  }
  getToken() {
    return Promise.resolve(new qE(this.l, this.h, this.P));
  }
  start(t, e) {
    t.enqueueRetryable(() => e(ge.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class YE {
  constructor(t) {
    this.value = t, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class XE {
  constructor(t) {
    this.A = t, this.forceRefresh = !1, this.appCheck = null, this.R = null;
  }
  start(t, e) {
    yt(this.o === void 0);
    const i = (s) => {
      s.error != null && q("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`);
      const o = s.token !== this.R;
      return this.R = s.token, q("FirebaseAppCheckTokenProvider", `Received ${o ? "new" : "existing"} token.`), o ? e(s.token) : Promise.resolve();
    };
    this.o = (s) => {
      t.enqueueRetryable(() => i(s));
    };
    const r = (s) => {
      q("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = s, this.o && this.appCheck.addTokenListener(this.o);
    };
    this.A.onInit((s) => r(s)), // Our users can initialize AppCheck after Firestore, so we give it
    // a chance to register itself with the component framework.
    setTimeout(() => {
      if (!this.appCheck) {
        const s = this.A.getImmediate({
          optional: !0
        });
        s ? r(s) : (
          // If AppCheck is still not available, proceed without it.
          q("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
        );
      }
    }, 0);
  }
  getToken() {
    const t = this.forceRefresh;
    return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(t).then((e) => e ? (yt(typeof e.token == "string"), this.R = e.token, new YE(e.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function KE(n) {
  const t = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), e = new Uint8Array(n);
  if (t && typeof t.getRandomValues == "function") t.getRandomValues(e);
  else
    for (let i = 0; i < n; i++) e[i] = Math.floor(256 * Math.random());
  return e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class w0 {
  static newId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t.length) * t.length;
    let i = "";
    for (; i.length < 20; ) {
      const r = KE(40);
      for (let s = 0; s < r.length; ++s)
        i.length < 20 && r[s] < e && (i += t.charAt(r[s] % t.length));
    }
    return i;
  }
}
function lt(n, t) {
  return n < t ? -1 : n > t ? 1 : 0;
}
function Lr(n, t, e) {
  return n.length === t.length && n.every((i, r) => e(i, t[r]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zt {
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Zt.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(t) {
    return Zt.fromMillis(t.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(t) {
    const e = Math.floor(t / 1e3), i = Math.floor(1e6 * (t - 1e3 * e));
    return new Zt(e, i);
  }
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(t, e) {
    if (this.seconds = t, this.nanoseconds = e, e < 0) throw new Y(N.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9) throw new Y(N.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t < -62135596800) throw new Y(N.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
    if (t >= 253402300800) throw new Y(N.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? lt(this.nanoseconds, t.nanoseconds) : lt(this.seconds, t.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const t = this.seconds - -62135596800;
    return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nt {
  static fromTimestamp(t) {
    return new nt(t);
  }
  static min() {
    return new nt(new Zt(0, 0));
  }
  static max() {
    return new nt(new Zt(253402300799, 999999999));
  }
  constructor(t) {
    this.timestamp = t;
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp);
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ho {
  constructor(t, e, i) {
    e === void 0 ? e = 0 : e > t.length && et(), i === void 0 ? i = t.length - e : i > t.length - e && et(), this.segments = t, this.offset = e, this.len = i;
  }
  get length() {
    return this.len;
  }
  isEqual(t) {
    return ho.comparator(this, t) === 0;
  }
  child(t) {
    const e = this.segments.slice(this.offset, this.limit());
    return t instanceof ho ? t.forEach((i) => {
      e.push(i);
    }) : e.push(t), this.construct(e);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(t) {
    return t = t === void 0 ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.segments[this.offset + t];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t) {
    if (t.length < this.length) return !1;
    for (let e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;
    return !0;
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length) return !1;
    for (let e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;
    return !0;
  }
  forEach(t) {
    for (let e = this.offset, i = this.limit(); e < i; e++) t(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t, e) {
    const i = Math.min(t.length, e.length);
    for (let r = 0; r < i; r++) {
      const s = t.get(r), o = e.get(r);
      if (s < o) return -1;
      if (s > o) return 1;
    }
    return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;
  }
}
class Tt extends ho {
  construct(t, e, i) {
    return new Tt(t, e, i);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns a string representation of this path
   * where each path segment has been encoded with
   * `encodeURIComponent`.
   */
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join("/");
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...t) {
    const e = [];
    for (const i of t) {
      if (i.indexOf("//") >= 0) throw new Y(N.INVALID_ARGUMENT, `Invalid segment (${i}). Paths must not contain // in them.`);
      e.push(...i.split("/").filter((r) => r.length > 0));
    }
    return new Tt(e);
  }
  static emptyPath() {
    return new Tt([]);
  }
}
const QE = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class ce extends ho {
  construct(t, e, i) {
    return new ce(t, e, i);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(t) {
    return QE.test(t);
  }
  canonicalString() {
    return this.toArray().map((t) => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ce.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new ce(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(t) {
    const e = [];
    let i = "", r = 0;
    const s = () => {
      if (i.length === 0) throw new Y(N.INVALID_ARGUMENT, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(i), i = "";
    };
    let o = !1;
    for (; r < t.length; ) {
      const a = t[r];
      if (a === "\\") {
        if (r + 1 === t.length) throw new Y(N.INVALID_ARGUMENT, "Path has trailing escape character: " + t);
        const l = t[r + 1];
        if (l !== "\\" && l !== "." && l !== "`") throw new Y(N.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t);
        i += l, r += 2;
      } else a === "`" ? (o = !o, r++) : a !== "." || o ? (i += a, r++) : (s(), r++);
    }
    if (s(), o) throw new Y(N.INVALID_ARGUMENT, "Unterminated ` in path: " + t);
    return new ce(e);
  }
  static emptyPath() {
    return new ce([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Z {
  constructor(t) {
    this.path = t;
  }
  static fromPath(t) {
    return new Z(Tt.fromString(t));
  }
  static fromName(t) {
    return new Z(Tt.fromString(t).popFirst(5));
  }
  static empty() {
    return new Z(Tt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t) {
    return t !== null && Tt.comparator(this.path, t.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t, e) {
    return Tt.comparator(t.path, e.path);
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(t) {
    return new Z(new Tt(t.slice()));
  }
}
function JE(n, t) {
  const e = n.toTimestamp().seconds, i = n.toTimestamp().nanoseconds + 1, r = nt.fromTimestamp(i === 1e9 ? new Zt(e + 1, 0) : new Zt(e, i));
  return new hi(r, Z.empty(), t);
}
function ZE(n) {
  return new hi(n.readTime, n.key, -1);
}
class hi {
  constructor(t, e, i) {
    this.readTime = t, this.documentKey = e, this.largestBatchId = i;
  }
  /** Returns an offset that sorts before all regular offsets. */
  static min() {
    return new hi(nt.min(), Z.empty(), -1);
  }
  /** Returns an offset that sorts after all regular offsets. */
  static max() {
    return new hi(nt.max(), Z.empty(), -1);
  }
}
function $E(n, t) {
  let e = n.readTime.compareTo(t.readTime);
  return e !== 0 ? e : (e = Z.comparator(n.documentKey, t.documentKey), e !== 0 ? e : lt(n.largestBatchId, t.largestBatchId));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tC = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class eC {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t) {
    this.onCommittedListeners.push(t);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t) => t());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Zr(n) {
  if (n.code !== N.FAILED_PRECONDITION || n.message !== tC) throw n;
  q("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class L {
  constructor(t) {
    this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
    this.result = void 0, this.error = void 0, this.isDone = !1, // Set to true when .then() or .catch() are called and prevents additional
    // chaining.
    this.callbackAttached = !1, t((e) => {
      this.isDone = !0, this.result = e, this.nextCallback && // value should be defined unless T is Void, but we can't express
      // that in the type system.
      this.nextCallback(e);
    }, (e) => {
      this.isDone = !0, this.error = e, this.catchCallback && this.catchCallback(e);
    });
  }
  catch(t) {
    return this.next(void 0, t);
  }
  next(t, e) {
    return this.callbackAttached && et(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t, this.result) : new L((i, r) => {
      this.nextCallback = (s) => {
        this.wrapSuccess(t, s).next(i, r);
      }, this.catchCallback = (s) => {
        this.wrapFailure(e, s).next(i, r);
      };
    });
  }
  toPromise() {
    return new Promise((t, e) => {
      this.next(t, e);
    });
  }
  wrapUserFunction(t) {
    try {
      const e = t();
      return e instanceof L ? e : L.resolve(e);
    } catch (e) {
      return L.reject(e);
    }
  }
  wrapSuccess(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : L.resolve(e);
  }
  wrapFailure(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : L.reject(e);
  }
  static resolve(t) {
    return new L((e, i) => {
      e(t);
    });
  }
  static reject(t) {
    return new L((e, i) => {
      i(t);
    });
  }
  static waitFor(t) {
    return new L((e, i) => {
      let r = 0, s = 0, o = !1;
      t.forEach((a) => {
        ++r, a.next(() => {
          ++s, o && s === r && e();
        }, (l) => i(l));
      }), o = !0, s === r && e();
    });
  }
  /**
   * Given an array of predicate functions that asynchronously evaluate to a
   * boolean, implements a short-circuiting `or` between the results. Predicates
   * will be evaluated until one of them returns `true`, then stop. The final
   * result will be whether any of them returned `true`.
   */
  static or(t) {
    let e = L.resolve(!1);
    for (const i of t) e = e.next((r) => r ? L.resolve(r) : i());
    return e;
  }
  static forEach(t, e) {
    const i = [];
    return t.forEach((r, s) => {
      i.push(e.call(this, r, s));
    }), this.waitFor(i);
  }
  /**
   * Concurrently map all array elements through asynchronous function.
   */
  static mapArray(t, e) {
    return new L((i, r) => {
      const s = t.length, o = new Array(s);
      let a = 0;
      for (let l = 0; l < s; l++) {
        const h = l;
        e(t[h]).next((c) => {
          o[h] = c, ++a, a === s && i(o);
        }, (c) => r(c));
      }
    });
  }
  /**
   * An alternative to recursive PersistencePromise calls, that avoids
   * potential memory problems from unbounded chains of promises.
   *
   * The `action` will be called repeatedly while `condition` is true.
   */
  static doWhile(t, e) {
    return new L((i, r) => {
      const s = () => {
        t() === !0 ? e().next(() => {
          s();
        }, r) : i();
      };
      s();
    });
  }
}
function nC(n) {
  const t = n.match(/Android ([\d.]+)/i), e = t ? t[1].split(".").slice(0, 2).join(".") : "-1";
  return Number(e);
}
function $r(n) {
  return n.name === "IndexedDbTransactionError";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hl {
  constructor(t, e) {
    this.previousValue = t, e && (e.sequenceNumberHandler = (i) => this.ie(i), this.se = (i) => e.writeSequenceNumber(i));
  }
  ie(t) {
    return this.previousValue = Math.max(t, this.previousValue), this.previousValue;
  }
  next() {
    const t = ++this.previousValue;
    return this.se && this.se(t), t;
  }
}
hl.oe = -1;
function cl(n) {
  return n == null;
}
function Oa(n) {
  return n === 0 && 1 / n == -1 / 0;
}
function iC(n) {
  return typeof n == "number" && Number.isInteger(n) && !Oa(n) && n <= Number.MAX_SAFE_INTEGER && n >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rC(n) {
  let t = "";
  for (let e = 0; e < n.length; e++) t.length > 0 && (t = Df(t)), t = sC(n.get(e), t);
  return Df(t);
}
function sC(n, t) {
  let e = t;
  const i = n.length;
  for (let r = 0; r < i; r++) {
    const s = n.charAt(r);
    switch (s) {
      case "\0":
        e += "";
        break;
      case "":
        e += "";
        break;
      default:
        e += s;
    }
  }
  return e;
}
function Df(n) {
  return n + "";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Bf(n) {
  let t = 0;
  for (const e in n) Object.prototype.hasOwnProperty.call(n, e) && t++;
  return t;
}
function Qi(n, t) {
  for (const e in n) Object.prototype.hasOwnProperty.call(n, e) && t(e, n[e]);
}
function A0(n) {
  for (const t in n) if (Object.prototype.hasOwnProperty.call(n, t)) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ot {
  constructor(t, e) {
    this.comparator = t, this.root = e || he.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(t, e) {
    return new Ot(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, he.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(t) {
    return new Ot(this.comparator, this.root.remove(t, this.comparator).copy(null, null, he.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(t) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const i = this.comparator(t, e.key);
      if (i === 0) return e.value;
      i < 0 ? e = e.left : i > 0 && (e = e.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(t) {
    let e = 0, i = this.root;
    for (; !i.isEmpty(); ) {
      const r = this.comparator(t, i.key);
      if (r === 0) return e + i.left.size;
      r < 0 ? i = i.left : (
        // Count all nodes left of the node plus the node itself
        (e += i.left.size + 1, i = i.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.root.inorderTraversal(t);
  }
  forEach(t) {
    this.inorderTraversal((e, i) => (t(e, i), !1));
  }
  toString() {
    const t = [];
    return this.inorderTraversal((e, i) => (t.push(`${e}:${i}`), !1)), `{${t.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.root.reverseTraversal(t);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new Zo(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(t) {
    return new Zo(this.root, t, this.comparator, !1);
  }
  getReverseIterator() {
    return new Zo(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(t) {
    return new Zo(this.root, t, this.comparator, !0);
  }
}
class Zo {
  constructor(t, e, i, r) {
    this.isReverse = r, this.nodeStack = [];
    let s = 1;
    for (; !t.isEmpty(); ) if (s = e ? i(t.key, e) : 1, // flip the comparison if we're going in reverse
    e && r && (s *= -1), s < 0)
      t = this.isReverse ? t.left : t.right;
    else {
      if (s === 0) {
        this.nodeStack.push(t);
        break;
      }
      this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;
    }
  }
  getNext() {
    let t = this.nodeStack.pop();
    const e = {
      key: t.key,
      value: t.value
    };
    if (this.isReverse) for (t = t.left; !t.isEmpty(); ) this.nodeStack.push(t), t = t.right;
    else for (t = t.right; !t.isEmpty(); ) this.nodeStack.push(t), t = t.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) return null;
    const t = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t.key,
      value: t.value
    };
  }
}
class he {
  constructor(t, e, i, r, s) {
    this.key = t, this.value = e, this.color = i ?? he.RED, this.left = r ?? he.EMPTY, this.right = s ?? he.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(t, e, i, r, s) {
    return new he(t ?? this.key, e ?? this.value, i ?? this.color, r ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(t, e, i) {
    let r = this;
    const s = i(t, r.key);
    return r = s < 0 ? r.copy(null, null, null, r.left.insert(t, e, i), null) : s === 0 ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, i)), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return he.EMPTY;
    let t = this;
    return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(t, e) {
    let i, r = this;
    if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);
    else {
      if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), e(t, r.key) === 0) {
        if (r.right.isEmpty()) return he.EMPTY;
        i = r.right.min(), r = r.copy(i.key, i.value, null, null, r.right.removeMin());
      }
      r = r.copy(null, null, null, null, r.right.remove(t, e));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let t = this;
    return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;
  }
  moveRedLeft() {
    let t = this.colorFlip();
    return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t;
  }
  moveRedRight() {
    let t = this.colorFlip();
    return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t;
  }
  rotateLeft() {
    const t = this.copy(null, null, he.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t, null);
  }
  rotateRight() {
    const t = this.copy(null, null, he.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t);
  }
  colorFlip() {
    const t = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t, e);
  }
  // For testing.
  checkMaxDepth() {
    const t = this.check();
    return Math.pow(2, t) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed()) throw et();
    const t = this.left.check();
    if (t !== this.right.check()) throw et();
    return t + (this.isRed() ? 0 : 1);
  }
}
he.EMPTY = null, he.RED = !0, he.BLACK = !1;
he.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw et();
  }
  get value() {
    throw et();
  }
  get color() {
    throw et();
  }
  get left() {
    throw et();
  }
  get right() {
    throw et();
  }
  // Returns a copy of the current node.
  copy(t, e, i, r, s) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(t, e, i) {
    return new he(t, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(t, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(t) {
    return !1;
  }
  reverseTraversal(t) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $t {
  constructor(t) {
    this.comparator = t, this.data = new Ot(this.comparator);
  }
  has(t) {
    return this.data.get(t) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t) {
    return this.data.indexOf(t);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(t) {
    this.data.inorderTraversal((e, i) => (t(e), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(t, e) {
    const i = this.data.getIteratorFrom(t[0]);
    for (; i.hasNext(); ) {
      const r = i.getNext();
      if (this.comparator(r.key, t[1]) >= 0) return;
      e(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(t, e) {
    let i;
    for (i = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); i.hasNext(); )
      if (!t(i.getNext().key)) return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(t) {
    const e = this.data.getIteratorFrom(t);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Of(this.data.getIterator());
  }
  getIteratorFrom(t) {
    return new Of(this.data.getIteratorFrom(t));
  }
  /** Inserts or updates an element */
  add(t) {
    return this.copy(this.data.remove(t).insert(t, !0));
  }
  /** Deletes an element */
  delete(t) {
    return this.has(t) ? this.copy(this.data.remove(t)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t) {
    let e = this;
    return e.size < t.size && (e = t, t = this), t.forEach((i) => {
      e = e.add(i);
    }), e;
  }
  isEqual(t) {
    if (!(t instanceof $t) || this.size !== t.size) return !1;
    const e = this.data.getIterator(), i = t.data.getIterator();
    for (; e.hasNext(); ) {
      const r = e.getNext().key, s = i.getNext().key;
      if (this.comparator(r, s) !== 0) return !1;
    }
    return !0;
  }
  toArray() {
    const t = [];
    return this.forEach((e) => {
      t.push(e);
    }), t;
  }
  toString() {
    const t = [];
    return this.forEach((e) => t.push(e)), "SortedSet(" + t.toString() + ")";
  }
  copy(t) {
    const e = new $t(this.comparator);
    return e.data = t, e;
  }
}
class Of {
  constructor(t) {
    this.iter = t;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class un {
  constructor(t) {
    this.fields = t, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    t.sort(ce.comparator);
  }
  static empty() {
    return new un([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(t) {
    let e = new $t(ce.comparator);
    for (const i of this.fields) e = e.add(i);
    for (const i of t) e = e.add(i);
    return new un(e.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(t) {
    for (const e of this.fields) if (e.isPrefixOf(t)) return !0;
    return !1;
  }
  isEqual(t) {
    return Lr(this.fields, t.fields, (e, i) => e.isEqual(i));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class T0 extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class de {
  constructor(t) {
    this.binaryString = t;
  }
  static fromBase64String(t) {
    const e = function(r) {
      try {
        return atob(r);
      } catch (s) {
        throw typeof DOMException < "u" && s instanceof DOMException ? new T0("Invalid base64 string: " + s) : s;
      }
    }(t);
    return new de(e);
  }
  static fromUint8Array(t) {
    const e = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(r) {
        let s = "";
        for (let o = 0; o < r.length; ++o) s += String.fromCharCode(r[o]);
        return s;
      }(t)
    );
    return new de(e);
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return function(e) {
      return btoa(e);
    }(this.binaryString);
  }
  toUint8Array() {
    return function(e) {
      const i = new Uint8Array(e.length);
      for (let r = 0; r < e.length; r++) i[r] = e.charCodeAt(r);
      return i;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t) {
    return lt(this.binaryString, t.binaryString);
  }
  isEqual(t) {
    return this.binaryString === t.binaryString;
  }
}
de.EMPTY_BYTE_STRING = new de("");
const oC = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function ci(n) {
  if (yt(!!n), typeof n == "string") {
    let t = 0;
    const e = oC.exec(n);
    if (yt(!!e), e[1]) {
      let r = e[1];
      r = (r + "000000000").substr(0, 9), t = Number(r);
    }
    const i = new Date(n);
    return {
      seconds: Math.floor(i.getTime() / 1e3),
      nanos: t
    };
  }
  return {
    seconds: zt(n.seconds),
    nanos: zt(n.nanos)
  };
}
function zt(n) {
  return typeof n == "number" ? n : typeof n == "string" ? Number(n) : 0;
}
function ui(n) {
  return typeof n == "string" ? de.fromBase64String(n) : de.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Eu(n) {
  var t, e;
  return ((e = (((t = n == null ? void 0 : n.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) === null || e === void 0 ? void 0 : e.stringValue) === "server_timestamp";
}
function ul(n) {
  const t = n.mapValue.fields.__previous_value__;
  return Eu(t) ? ul(t) : t;
}
function co(n) {
  const t = ci(n.mapValue.fields.__local_write_time__.timestampValue);
  return new Zt(t.seconds, t.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aC {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(t, e, i, r, s, o, a, l, h) {
    this.databaseId = t, this.appId = e, this.persistenceKey = i, this.host = r, this.ssl = s, this.forceLongPolling = o, this.autoDetectLongPolling = a, this.longPollingOptions = l, this.useFetchStreams = h;
  }
}
class uo {
  constructor(t, e) {
    this.projectId = t, this.database = e || "(default)";
  }
  static empty() {
    return new uo("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t) {
    return t instanceof uo && t.projectId === this.projectId && t.database === this.database;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $o = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
function di(n) {
  return "nullValue" in n ? 0 : "booleanValue" in n ? 1 : "integerValue" in n || "doubleValue" in n ? 2 : "timestampValue" in n ? 3 : "stringValue" in n ? 5 : "bytesValue" in n ? 6 : "referenceValue" in n ? 7 : "geoPointValue" in n ? 8 : "arrayValue" in n ? 9 : "mapValue" in n ? Eu(n) ? 4 : hC(n) ? 9007199254740991 : lC(n) ? 10 : 11 : et();
}
function Sn(n, t) {
  if (n === t) return !0;
  const e = di(n);
  if (e !== di(t)) return !1;
  switch (e) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === t.booleanValue;
    case 4:
      return co(n).isEqual(co(t));
    case 3:
      return function(r, s) {
        if (typeof r.timestampValue == "string" && typeof s.timestampValue == "string" && r.timestampValue.length === s.timestampValue.length)
          return r.timestampValue === s.timestampValue;
        const o = ci(r.timestampValue), a = ci(s.timestampValue);
        return o.seconds === a.seconds && o.nanos === a.nanos;
      }(n, t);
    case 5:
      return n.stringValue === t.stringValue;
    case 6:
      return function(r, s) {
        return ui(r.bytesValue).isEqual(ui(s.bytesValue));
      }(n, t);
    case 7:
      return n.referenceValue === t.referenceValue;
    case 8:
      return function(r, s) {
        return zt(r.geoPointValue.latitude) === zt(s.geoPointValue.latitude) && zt(r.geoPointValue.longitude) === zt(s.geoPointValue.longitude);
      }(n, t);
    case 2:
      return function(r, s) {
        if ("integerValue" in r && "integerValue" in s) return zt(r.integerValue) === zt(s.integerValue);
        if ("doubleValue" in r && "doubleValue" in s) {
          const o = zt(r.doubleValue), a = zt(s.doubleValue);
          return o === a ? Oa(o) === Oa(a) : isNaN(o) && isNaN(a);
        }
        return !1;
      }(n, t);
    case 9:
      return Lr(n.arrayValue.values || [], t.arrayValue.values || [], Sn);
    case 10:
    case 11:
      return function(r, s) {
        const o = r.mapValue.fields || {}, a = s.mapValue.fields || {};
        if (Bf(o) !== Bf(a)) return !1;
        for (const l in o) if (o.hasOwnProperty(l) && (a[l] === void 0 || !Sn(o[l], a[l]))) return !1;
        return !0;
      }(n, t);
    default:
      return et();
  }
}
function po(n, t) {
  return (n.values || []).find((e) => Sn(e, t)) !== void 0;
}
function Nr(n, t) {
  if (n === t) return 0;
  const e = di(n), i = di(t);
  if (e !== i) return lt(e, i);
  switch (e) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return lt(n.booleanValue, t.booleanValue);
    case 2:
      return function(s, o) {
        const a = zt(s.integerValue || s.doubleValue), l = zt(o.integerValue || o.doubleValue);
        return a < l ? -1 : a > l ? 1 : a === l ? 0 : (
          // one or both are NaN.
          isNaN(a) ? isNaN(l) ? 0 : -1 : 1
        );
      }(n, t);
    case 3:
      return Ff(n.timestampValue, t.timestampValue);
    case 4:
      return Ff(co(n), co(t));
    case 5:
      return lt(n.stringValue, t.stringValue);
    case 6:
      return function(s, o) {
        const a = ui(s), l = ui(o);
        return a.compareTo(l);
      }(n.bytesValue, t.bytesValue);
    case 7:
      return function(s, o) {
        const a = s.split("/"), l = o.split("/");
        for (let h = 0; h < a.length && h < l.length; h++) {
          const c = lt(a[h], l[h]);
          if (c !== 0) return c;
        }
        return lt(a.length, l.length);
      }(n.referenceValue, t.referenceValue);
    case 8:
      return function(s, o) {
        const a = lt(zt(s.latitude), zt(o.latitude));
        return a !== 0 ? a : lt(zt(s.longitude), zt(o.longitude));
      }(n.geoPointValue, t.geoPointValue);
    case 9:
      return Lf(n.arrayValue, t.arrayValue);
    case 10:
      return function(s, o) {
        var a, l, h, c;
        const p = s.fields || {}, f = o.fields || {}, u = (a = p.value) === null || a === void 0 ? void 0 : a.arrayValue, m = (l = f.value) === null || l === void 0 ? void 0 : l.arrayValue, g = lt(((h = u == null ? void 0 : u.values) === null || h === void 0 ? void 0 : h.length) || 0, ((c = m == null ? void 0 : m.values) === null || c === void 0 ? void 0 : c.length) || 0);
        return g !== 0 ? g : Lf(u, m);
      }(n.mapValue, t.mapValue);
    case 11:
      return function(s, o) {
        if (s === $o.mapValue && o === $o.mapValue) return 0;
        if (s === $o.mapValue) return 1;
        if (o === $o.mapValue) return -1;
        const a = s.fields || {}, l = Object.keys(a), h = o.fields || {}, c = Object.keys(h);
        l.sort(), c.sort();
        for (let p = 0; p < l.length && p < c.length; ++p) {
          const f = lt(l[p], c[p]);
          if (f !== 0) return f;
          const u = Nr(a[l[p]], h[c[p]]);
          if (u !== 0) return u;
        }
        return lt(l.length, c.length);
      }(n.mapValue, t.mapValue);
    default:
      throw et();
  }
}
function Ff(n, t) {
  if (typeof n == "string" && typeof t == "string" && n.length === t.length) return lt(n, t);
  const e = ci(n), i = ci(t), r = lt(e.seconds, i.seconds);
  return r !== 0 ? r : lt(e.nanos, i.nanos);
}
function Lf(n, t) {
  const e = n.values || [], i = t.values || [];
  for (let r = 0; r < e.length && r < i.length; ++r) {
    const s = Nr(e[r], i[r]);
    if (s) return s;
  }
  return lt(e.length, i.length);
}
function Ur(n) {
  return Cc(n);
}
function Cc(n) {
  return "nullValue" in n ? "null" : "booleanValue" in n ? "" + n.booleanValue : "integerValue" in n ? "" + n.integerValue : "doubleValue" in n ? "" + n.doubleValue : "timestampValue" in n ? function(e) {
    const i = ci(e);
    return `time(${i.seconds},${i.nanos})`;
  }(n.timestampValue) : "stringValue" in n ? n.stringValue : "bytesValue" in n ? function(e) {
    return ui(e).toBase64();
  }(n.bytesValue) : "referenceValue" in n ? function(e) {
    return Z.fromName(e).toString();
  }(n.referenceValue) : "geoPointValue" in n ? function(e) {
    return `geo(${e.latitude},${e.longitude})`;
  }(n.geoPointValue) : "arrayValue" in n ? function(e) {
    let i = "[", r = !0;
    for (const s of e.values || []) r ? r = !1 : i += ",", i += Cc(s);
    return i + "]";
  }(n.arrayValue) : "mapValue" in n ? function(e) {
    const i = Object.keys(e.fields || {}).sort();
    let r = "{", s = !0;
    for (const o of i) s ? s = !1 : r += ",", r += `${o}:${Cc(e.fields[o])}`;
    return r + "}";
  }(n.mapValue) : et();
}
function da(n) {
  switch (di(n)) {
    case 0:
    case 1:
      return 4;
    case 2:
      return 8;
    case 3:
    case 8:
      return 16;
    case 4:
      const t = ul(n);
      return t ? 16 + da(t) : 16;
    case 5:
      return 2 * n.stringValue.length;
    case 6:
      return ui(n.bytesValue).approximateByteSize();
    case 7:
      return n.referenceValue.length;
    case 9:
      return function(i) {
        return (i.values || []).reduce((r, s) => r + da(s), 0);
      }(n.arrayValue);
    case 10:
    case 11:
      return function(i) {
        let r = 0;
        return Qi(i.fields, (s, o) => {
          r += s.length + da(o);
        }), r;
      }(n.mapValue);
    default:
      throw et();
  }
}
function Nf(n, t) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${t.path.canonicalString()}`
  };
}
function Pc(n) {
  return !!n && "integerValue" in n;
}
function Cu(n) {
  return !!n && "arrayValue" in n;
}
function Uf(n) {
  return !!n && "nullValue" in n;
}
function zf(n) {
  return !!n && "doubleValue" in n && isNaN(Number(n.doubleValue));
}
function pa(n) {
  return !!n && "mapValue" in n;
}
function lC(n) {
  var t, e;
  return ((e = (((t = n == null ? void 0 : n.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) === null || e === void 0 ? void 0 : e.stringValue) === "__vector__";
}
function zs(n) {
  if (n.geoPointValue) return {
    geoPointValue: Object.assign({}, n.geoPointValue)
  };
  if (n.timestampValue && typeof n.timestampValue == "object") return {
    timestampValue: Object.assign({}, n.timestampValue)
  };
  if (n.mapValue) {
    const t = {
      mapValue: {
        fields: {}
      }
    };
    return Qi(n.mapValue.fields, (e, i) => t.mapValue.fields[e] = zs(i)), t;
  }
  if (n.arrayValue) {
    const t = {
      arrayValue: {
        values: []
      }
    };
    for (let e = 0; e < (n.arrayValue.values || []).length; ++e) t.arrayValue.values[e] = zs(n.arrayValue.values[e]);
    return t;
  }
  return Object.assign({}, n);
}
function hC(n) {
  return (((n.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class en {
  constructor(t) {
    this.value = t;
  }
  static empty() {
    return new en({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(t) {
    if (t.isEmpty()) return this.value;
    {
      let e = this.value;
      for (let i = 0; i < t.length - 1; ++i) if (e = (e.mapValue.fields || {})[t.get(i)], !pa(e)) return null;
      return e = (e.mapValue.fields || {})[t.lastSegment()], e || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(t, e) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = zs(e);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(t) {
    let e = ce.emptyPath(), i = {}, r = [];
    t.forEach((o, a) => {
      if (!e.isImmediateParentOf(a)) {
        const l = this.getFieldsMap(e);
        this.applyChanges(l, i, r), i = {}, r = [], e = a.popLast();
      }
      o ? i[a.lastSegment()] = zs(o) : r.push(a.lastSegment());
    });
    const s = this.getFieldsMap(e);
    this.applyChanges(s, i, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(t) {
    const e = this.field(t.popLast());
    pa(e) && e.mapValue.fields && delete e.mapValue.fields[t.lastSegment()];
  }
  isEqual(t) {
    return Sn(this.value, t.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(t) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let i = 0; i < t.length; ++i) {
      let r = e.mapValue.fields[t.get(i)];
      pa(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t.get(i)] = r), e = r;
    }
    return e.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(t, e, i) {
    Qi(e, (r, s) => t[r] = s);
    for (const r of i) delete t[r];
  }
  clone() {
    return new en(zs(this.value));
  }
}
function S0(n) {
  const t = [];
  return Qi(n.fields, (e, i) => {
    const r = new ce([e]);
    if (pa(i)) {
      const s = S0(i.mapValue).fields;
      if (s.length === 0)
        t.push(r);
      else
        for (const o of s) t.push(r.child(o));
    } else
      t.push(r);
  }), new un(t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ye {
  constructor(t, e, i, r, s, o, a) {
    this.key = t, this.documentType = e, this.version = i, this.readTime = r, this.createTime = s, this.data = o, this.documentState = a;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(t) {
    return new ye(
      t,
      0,
      /* version */
      nt.min(),
      /* readTime */
      nt.min(),
      /* createTime */
      nt.min(),
      en.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(t, e, i, r) {
    return new ye(
      t,
      1,
      /* version */
      e,
      /* readTime */
      nt.min(),
      /* createTime */
      i,
      r,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(t, e) {
    return new ye(
      t,
      2,
      /* version */
      e,
      /* readTime */
      nt.min(),
      /* createTime */
      nt.min(),
      en.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(t, e) {
    return new ye(
      t,
      3,
      /* version */
      e,
      /* readTime */
      nt.min(),
      /* createTime */
      nt.min(),
      en.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(t, e) {
    return !this.createTime.isEqual(nt.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = t), this.version = t, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(t) {
    return this.version = t, this.documentType = 2, this.data = en.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(t) {
    return this.version = t, this.documentType = 3, this.data = en.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = nt.min(), this;
  }
  setReadTime(t) {
    return this.readTime = t, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t) {
    return t instanceof ye && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);
  }
  mutableCopy() {
    return new ye(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fa {
  constructor(t, e) {
    this.position = t, this.inclusive = e;
  }
}
function jf(n, t, e) {
  let i = 0;
  for (let r = 0; r < n.position.length; r++) {
    const s = t[r], o = n.position[r];
    if (s.field.isKeyField() ? i = Z.comparator(Z.fromName(o.referenceValue), e.key) : i = Nr(o, e.data.field(s.field)), s.dir === "desc" && (i *= -1), i !== 0) break;
  }
  return i;
}
function Gf(n, t) {
  if (n === null) return t === null;
  if (t === null || n.inclusive !== t.inclusive || n.position.length !== t.position.length) return !1;
  for (let e = 0; e < n.position.length; e++)
    if (!Sn(n.position[e], t.position[e])) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fo {
  constructor(t, e = "asc") {
    this.field = t, this.dir = e;
  }
}
function cC(n, t) {
  return n.dir === t.dir && n.field.isEqual(t.field);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class E0 {
}
class qt extends E0 {
  constructor(t, e, i) {
    super(), this.field = t, this.op = e, this.value = i;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e, i) {
    return t.isKeyField() ? e === "in" || e === "not-in" ? this.createKeyFieldInFilter(t, e, i) : new dC(t, e, i) : e === "array-contains" ? new mC(t, i) : e === "in" ? new gC(t, i) : e === "not-in" ? new yC(t, i) : e === "array-contains-any" ? new _C(t, i) : new qt(t, e, i);
  }
  static createKeyFieldInFilter(t, e, i) {
    return e === "in" ? new pC(t, i) : new fC(t, i);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return this.op === "!=" ? e !== null && this.matchesComparison(Nr(e, this.value)) : e !== null && di(this.value) === di(e) && this.matchesComparison(Nr(e, this.value));
  }
  matchesComparison(t) {
    switch (this.op) {
      case "<":
        return t < 0;
      case "<=":
        return t <= 0;
      case "==":
        return t === 0;
      case "!=":
        return t !== 0;
      case ">":
        return t > 0;
      case ">=":
        return t >= 0;
      default:
        return et();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
}
class dn extends E0 {
  constructor(t, e) {
    super(), this.filters = t, this.op = e, this.ae = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e) {
    return new dn(t, e);
  }
  matches(t) {
    return C0(this) ? this.filters.find((e) => !e.matches(t)) === void 0 : this.filters.find((e) => e.matches(t)) !== void 0;
  }
  getFlattenedFilters() {
    return this.ae !== null || (this.ae = this.filters.reduce((t, e) => t.concat(e.getFlattenedFilters()), [])), this.ae;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
}
function C0(n) {
  return n.op === "and";
}
function P0(n) {
  return uC(n) && C0(n);
}
function uC(n) {
  for (const t of n.filters) if (t instanceof dn) return !1;
  return !0;
}
function Ic(n) {
  if (n instanceof qt)
    return n.field.canonicalString() + n.op.toString() + Ur(n.value);
  if (P0(n))
    return n.filters.map((t) => Ic(t)).join(",");
  {
    const t = n.filters.map((e) => Ic(e)).join(",");
    return `${n.op}(${t})`;
  }
}
function I0(n, t) {
  return n instanceof qt ? function(i, r) {
    return r instanceof qt && i.op === r.op && i.field.isEqual(r.field) && Sn(i.value, r.value);
  }(n, t) : n instanceof dn ? function(i, r) {
    return r instanceof dn && i.op === r.op && i.filters.length === r.filters.length ? i.filters.reduce((s, o, a) => s && I0(o, r.filters[a]), !0) : !1;
  }(n, t) : void et();
}
function R0(n) {
  return n instanceof qt ? function(e) {
    return `${e.field.canonicalString()} ${e.op} ${Ur(e.value)}`;
  }(n) : n instanceof dn ? function(e) {
    return e.op.toString() + " {" + e.getFilters().map(R0).join(" ,") + "}";
  }(n) : "Filter";
}
class dC extends qt {
  constructor(t, e, i) {
    super(t, e, i), this.key = Z.fromName(i.referenceValue);
  }
  matches(t) {
    const e = Z.comparator(t.key, this.key);
    return this.matchesComparison(e);
  }
}
class pC extends qt {
  constructor(t, e) {
    super(t, "in", e), this.keys = k0("in", e);
  }
  matches(t) {
    return this.keys.some((e) => e.isEqual(t.key));
  }
}
class fC extends qt {
  constructor(t, e) {
    super(t, "not-in", e), this.keys = k0("not-in", e);
  }
  matches(t) {
    return !this.keys.some((e) => e.isEqual(t.key));
  }
}
function k0(n, t) {
  var e;
  return (((e = t.arrayValue) === null || e === void 0 ? void 0 : e.values) || []).map((i) => Z.fromName(i.referenceValue));
}
class mC extends qt {
  constructor(t, e) {
    super(t, "array-contains", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return Cu(e) && po(e.arrayValue, this.value);
  }
}
class gC extends qt {
  constructor(t, e) {
    super(t, "in", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return e !== null && po(this.value.arrayValue, e);
  }
}
class yC extends qt {
  constructor(t, e) {
    super(t, "not-in", e);
  }
  matches(t) {
    if (po(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    })) return !1;
    const e = t.data.field(this.field);
    return e !== null && !po(this.value.arrayValue, e);
  }
}
class _C extends qt {
  constructor(t, e) {
    super(t, "array-contains-any", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return !(!Cu(e) || !e.arrayValue.values) && e.arrayValue.values.some((i) => po(this.value.arrayValue, i));
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vC {
  constructor(t, e = null, i = [], r = [], s = null, o = null, a = null) {
    this.path = t, this.collectionGroup = e, this.orderBy = i, this.filters = r, this.limit = s, this.startAt = o, this.endAt = a, this.ue = null;
  }
}
function Hf(n, t = null, e = [], i = [], r = null, s = null, o = null) {
  return new vC(n, t, e, i, r, s, o);
}
function Pu(n) {
  const t = it(n);
  if (t.ue === null) {
    let e = t.path.canonicalString();
    t.collectionGroup !== null && (e += "|cg:" + t.collectionGroup), e += "|f:", e += t.filters.map((i) => Ic(i)).join(","), e += "|ob:", e += t.orderBy.map((i) => function(s) {
      return s.field.canonicalString() + s.dir;
    }(i)).join(","), cl(t.limit) || (e += "|l:", e += t.limit), t.startAt && (e += "|lb:", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map((i) => Ur(i)).join(",")), t.endAt && (e += "|ub:", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map((i) => Ur(i)).join(",")), t.ue = e;
  }
  return t.ue;
}
function Iu(n, t) {
  if (n.limit !== t.limit || n.orderBy.length !== t.orderBy.length) return !1;
  for (let e = 0; e < n.orderBy.length; e++) if (!cC(n.orderBy[e], t.orderBy[e])) return !1;
  if (n.filters.length !== t.filters.length) return !1;
  for (let e = 0; e < n.filters.length; e++) if (!I0(n.filters[e], t.filters[e])) return !1;
  return n.collectionGroup === t.collectionGroup && !!n.path.isEqual(t.path) && !!Gf(n.startAt, t.startAt) && Gf(n.endAt, t.endAt);
}
function Rc(n) {
  return Z.isDocumentKey(n.path) && n.collectionGroup === null && n.filters.length === 0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ts {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(t, e = null, i = [], r = [], s = null, o = "F", a = null, l = null) {
    this.path = t, this.collectionGroup = e, this.explicitOrderBy = i, this.filters = r, this.limit = s, this.limitType = o, this.startAt = a, this.endAt = l, this.ce = null, // The corresponding `Target` of this `Query` instance, for use with
    // non-aggregate queries.
    this.le = null, // The corresponding `Target` of this `Query` instance, for use with
    // aggregate queries. Unlike targets for non-aggregate queries,
    // aggregate query targets do not contain normalized order-bys, they only
    // contain explicit order-bys.
    this.he = null, this.startAt, this.endAt;
  }
}
function xC(n, t, e, i, r, s, o, a) {
  return new ts(n, t, e, i, r, s, o, a);
}
function M0(n) {
  return new ts(n);
}
function qf(n) {
  return n.filters.length === 0 && n.limit === null && n.startAt == null && n.endAt == null && (n.explicitOrderBy.length === 0 || n.explicitOrderBy.length === 1 && n.explicitOrderBy[0].field.isKeyField());
}
function V0(n) {
  return n.collectionGroup !== null;
}
function js(n) {
  const t = it(n);
  if (t.ce === null) {
    t.ce = [];
    const e = /* @__PURE__ */ new Set();
    for (const s of t.explicitOrderBy) t.ce.push(s), e.add(s.field.canonicalString());
    const i = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc";
    (function(o) {
      let a = new $t(ce.comparator);
      return o.filters.forEach((l) => {
        l.getFlattenedFilters().forEach((h) => {
          h.isInequality() && (a = a.add(h.field));
        });
      }), a;
    })(t).forEach((s) => {
      e.has(s.canonicalString()) || s.isKeyField() || t.ce.push(new fo(s, i));
    }), // Add the document key field to the last if it is not explicitly ordered.
    e.has(ce.keyField().canonicalString()) || t.ce.push(new fo(ce.keyField(), i));
  }
  return t.ce;
}
function wn(n) {
  const t = it(n);
  return t.le || (t.le = bC(t, js(n))), t.le;
}
function bC(n, t) {
  if (n.limitType === "F") return Hf(n.path, n.collectionGroup, t, n.filters, n.limit, n.startAt, n.endAt);
  {
    t = t.map((r) => {
      const s = r.dir === "desc" ? "asc" : "desc";
      return new fo(r.field, s);
    });
    const e = n.endAt ? new Fa(n.endAt.position, n.endAt.inclusive) : null, i = n.startAt ? new Fa(n.startAt.position, n.startAt.inclusive) : null;
    return Hf(n.path, n.collectionGroup, t, n.filters, n.limit, e, i);
  }
}
function kc(n, t) {
  const e = n.filters.concat([t]);
  return new ts(n.path, n.collectionGroup, n.explicitOrderBy.slice(), e, n.limit, n.limitType, n.startAt, n.endAt);
}
function La(n, t, e) {
  return new ts(n.path, n.collectionGroup, n.explicitOrderBy.slice(), n.filters.slice(), t, e, n.startAt, n.endAt);
}
function dl(n, t) {
  return Iu(wn(n), wn(t)) && n.limitType === t.limitType;
}
function D0(n) {
  return `${Pu(wn(n))}|lt:${n.limitType}`;
}
function dr(n) {
  return `Query(target=${function(e) {
    let i = e.path.canonicalString();
    return e.collectionGroup !== null && (i += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (i += `, filters: [${e.filters.map((r) => R0(r)).join(", ")}]`), cl(e.limit) || (i += ", limit: " + e.limit), e.orderBy.length > 0 && (i += `, orderBy: [${e.orderBy.map((r) => function(o) {
      return `${o.field.canonicalString()} (${o.dir})`;
    }(r)).join(", ")}]`), e.startAt && (i += ", startAt: ", i += e.startAt.inclusive ? "b:" : "a:", i += e.startAt.position.map((r) => Ur(r)).join(",")), e.endAt && (i += ", endAt: ", i += e.endAt.inclusive ? "a:" : "b:", i += e.endAt.position.map((r) => Ur(r)).join(",")), `Target(${i})`;
  }(wn(n))}; limitType=${n.limitType})`;
}
function pl(n, t) {
  return t.isFoundDocument() && function(i, r) {
    const s = r.key.path;
    return i.collectionGroup !== null ? r.key.hasCollectionId(i.collectionGroup) && i.path.isPrefixOf(s) : Z.isDocumentKey(i.path) ? i.path.isEqual(s) : i.path.isImmediateParentOf(s);
  }(n, t) && function(i, r) {
    for (const s of js(i))
      if (!s.field.isKeyField() && r.data.field(s.field) === null) return !1;
    return !0;
  }(n, t) && function(i, r) {
    for (const s of i.filters) if (!s.matches(r)) return !1;
    return !0;
  }(n, t) && function(i, r) {
    return !(i.startAt && !/**
    * Returns true if a document sorts before a bound using the provided sort
    * order.
    */
    function(o, a, l) {
      const h = jf(o, a, l);
      return o.inclusive ? h <= 0 : h < 0;
    }(i.startAt, js(i), r) || i.endAt && !function(o, a, l) {
      const h = jf(o, a, l);
      return o.inclusive ? h >= 0 : h > 0;
    }(i.endAt, js(i), r));
  }(n, t);
}
function wC(n) {
  return n.collectionGroup || (n.path.length % 2 == 1 ? n.path.lastSegment() : n.path.get(n.path.length - 2));
}
function B0(n) {
  return (t, e) => {
    let i = !1;
    for (const r of js(n)) {
      const s = AC(r, t, e);
      if (s !== 0) return s;
      i = i || r.field.isKeyField();
    }
    return 0;
  };
}
function AC(n, t, e) {
  const i = n.field.isKeyField() ? Z.comparator(t.key, e.key) : function(s, o, a) {
    const l = o.data.field(s), h = a.data.field(s);
    return l !== null && h !== null ? Nr(l, h) : et();
  }(n.field, t, e);
  switch (n.dir) {
    case "asc":
      return i;
    case "desc":
      return -1 * i;
    default:
      return et();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ji {
  constructor(t, e) {
    this.mapKeyFn = t, this.equalsFn = e, /**
     * The inner map for a key/value pair. Due to the possibility of collisions we
     * keep a list of entries that we do a linear search through to find an actual
     * match. Note that collisions should be rare, so we still expect near
     * constant time lookups in practice.
     */
    this.inner = {}, /** The number of entries stored in the map */
    this.innerSize = 0;
  }
  /** Get a value for this key, or undefined if it does not exist. */
  get(t) {
    const e = this.mapKeyFn(t), i = this.inner[e];
    if (i !== void 0) {
      for (const [r, s] of i) if (this.equalsFn(r, t)) return s;
    }
  }
  has(t) {
    return this.get(t) !== void 0;
  }
  /** Put this key and value in the map. */
  set(t, e) {
    const i = this.mapKeyFn(t), r = this.inner[i];
    if (r === void 0) return this.inner[i] = [[t, e]], void this.innerSize++;
    for (let s = 0; s < r.length; s++) if (this.equalsFn(r[s][0], t))
      return void (r[s] = [t, e]);
    r.push([t, e]), this.innerSize++;
  }
  /**
   * Remove this key from the map. Returns a boolean if anything was deleted.
   */
  delete(t) {
    const e = this.mapKeyFn(t), i = this.inner[e];
    if (i === void 0) return !1;
    for (let r = 0; r < i.length; r++) if (this.equalsFn(i[r][0], t)) return i.length === 1 ? delete this.inner[e] : i.splice(r, 1), this.innerSize--, !0;
    return !1;
  }
  forEach(t) {
    Qi(this.inner, (e, i) => {
      for (const [r, s] of i) t(r, s);
    });
  }
  isEmpty() {
    return A0(this.inner);
  }
  size() {
    return this.innerSize;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TC = new Ot(Z.comparator);
function Gn() {
  return TC;
}
const O0 = new Ot(Z.comparator);
function Ms(...n) {
  let t = O0;
  for (const e of n) t = t.insert(e.key, e);
  return t;
}
function F0(n) {
  let t = O0;
  return n.forEach((e, i) => t = t.insert(e, i.overlayedDocument)), t;
}
function Fi() {
  return Gs();
}
function L0() {
  return Gs();
}
function Gs() {
  return new Ji((n) => n.toString(), (n, t) => n.isEqual(t));
}
const SC = new Ot(Z.comparator), EC = new $t(Z.comparator);
function at(...n) {
  let t = EC;
  for (const e of n) t = t.add(e);
  return t;
}
const CC = new $t(lt);
function PC() {
  return CC;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ru(n, t) {
  if (n.useProto3Json) {
    if (isNaN(t)) return {
      doubleValue: "NaN"
    };
    if (t === 1 / 0) return {
      doubleValue: "Infinity"
    };
    if (t === -1 / 0) return {
      doubleValue: "-Infinity"
    };
  }
  return {
    doubleValue: Oa(t) ? "-0" : t
  };
}
function N0(n) {
  return {
    integerValue: "" + n
  };
}
function IC(n, t) {
  return iC(t) ? N0(t) : Ru(n, t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fl {
  constructor() {
    this._ = void 0;
  }
}
function RC(n, t, e) {
  return n instanceof Na ? function(r, s) {
    const o = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: r.seconds,
            nanos: r.nanoseconds
          }
        }
      }
    };
    return s && Eu(s) && (s = ul(s)), s && (o.fields.__previous_value__ = s), {
      mapValue: o
    };
  }(e, t) : n instanceof mo ? z0(n, t) : n instanceof go ? j0(n, t) : function(r, s) {
    const o = U0(r, s), a = Wf(o) + Wf(r.Pe);
    return Pc(o) && Pc(r.Pe) ? N0(a) : Ru(r.serializer, a);
  }(n, t);
}
function kC(n, t, e) {
  return n instanceof mo ? z0(n, t) : n instanceof go ? j0(n, t) : e;
}
function U0(n, t) {
  return n instanceof Ua ? (
    /** Returns true if `value` is either an IntegerValue or a DoubleValue. */
    function(i) {
      return Pc(i) || function(s) {
        return !!s && "doubleValue" in s;
      }(i);
    }(t) ? t : {
      integerValue: 0
    }
  ) : null;
}
class Na extends fl {
}
class mo extends fl {
  constructor(t) {
    super(), this.elements = t;
  }
}
function z0(n, t) {
  const e = G0(t);
  for (const i of n.elements) e.some((r) => Sn(r, i)) || e.push(i);
  return {
    arrayValue: {
      values: e
    }
  };
}
class go extends fl {
  constructor(t) {
    super(), this.elements = t;
  }
}
function j0(n, t) {
  let e = G0(t);
  for (const i of n.elements) e = e.filter((r) => !Sn(r, i));
  return {
    arrayValue: {
      values: e
    }
  };
}
class Ua extends fl {
  constructor(t, e) {
    super(), this.serializer = t, this.Pe = e;
  }
}
function Wf(n) {
  return zt(n.integerValue || n.doubleValue);
}
function G0(n) {
  return Cu(n) && n.arrayValue.values ? n.arrayValue.values.slice() : [];
}
function MC(n, t) {
  return n.field.isEqual(t.field) && function(i, r) {
    return i instanceof mo && r instanceof mo || i instanceof go && r instanceof go ? Lr(i.elements, r.elements, Sn) : i instanceof Ua && r instanceof Ua ? Sn(i.Pe, r.Pe) : i instanceof Na && r instanceof Na;
  }(n.transform, t.transform);
}
class VC {
  constructor(t, e) {
    this.version = t, this.transformResults = e;
  }
}
class Ln {
  constructor(t, e) {
    this.updateTime = t, this.exists = e;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new Ln();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(t) {
    return new Ln(void 0, t);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(t) {
    return new Ln(t);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t) {
    return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);
  }
}
function fa(n, t) {
  return n.updateTime !== void 0 ? t.isFoundDocument() && t.version.isEqual(n.updateTime) : n.exists === void 0 || n.exists === t.isFoundDocument();
}
class ml {
}
function H0(n, t) {
  if (!n.hasLocalMutations || t && t.fields.length === 0) return null;
  if (t === null) return n.isNoDocument() ? new W0(n.key, Ln.none()) : new vo(n.key, n.data, Ln.none());
  {
    const e = n.data, i = en.empty();
    let r = new $t(ce.comparator);
    for (let s of t.fields) if (!r.has(s)) {
      let o = e.field(s);
      o === null && s.length > 1 && (s = s.popLast(), o = e.field(s)), o === null ? i.delete(s) : i.set(s, o), r = r.add(s);
    }
    return new Zi(n.key, i, new un(r.toArray()), Ln.none());
  }
}
function DC(n, t, e) {
  n instanceof vo ? function(r, s, o) {
    const a = r.value.clone(), l = Xf(r.fieldTransforms, s, o.transformResults);
    a.setAll(l), s.convertToFoundDocument(o.version, a).setHasCommittedMutations();
  }(n, t, e) : n instanceof Zi ? function(r, s, o) {
    if (!fa(r.precondition, s))
      return void s.convertToUnknownDocument(o.version);
    const a = Xf(r.fieldTransforms, s, o.transformResults), l = s.data;
    l.setAll(q0(r)), l.setAll(a), s.convertToFoundDocument(o.version, l).setHasCommittedMutations();
  }(n, t, e) : function(r, s, o) {
    s.convertToNoDocument(o.version).setHasCommittedMutations();
  }(0, t, e);
}
function Hs(n, t, e, i) {
  return n instanceof vo ? function(s, o, a, l) {
    if (!fa(s.precondition, o))
      return a;
    const h = s.value.clone(), c = Kf(s.fieldTransforms, l, o);
    return h.setAll(c), o.convertToFoundDocument(o.version, h).setHasLocalMutations(), null;
  }(n, t, e, i) : n instanceof Zi ? function(s, o, a, l) {
    if (!fa(s.precondition, o)) return a;
    const h = Kf(s.fieldTransforms, l, o), c = o.data;
    return c.setAll(q0(s)), c.setAll(h), o.convertToFoundDocument(o.version, c).setHasLocalMutations(), a === null ? null : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map((p) => p.field));
  }(n, t, e, i) : function(s, o, a) {
    return fa(s.precondition, o) ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null) : a;
  }(n, t, e);
}
function BC(n, t) {
  let e = null;
  for (const i of n.fieldTransforms) {
    const r = t.data.field(i.field), s = U0(i.transform, r || null);
    s != null && (e === null && (e = en.empty()), e.set(i.field, s));
  }
  return e || null;
}
function Yf(n, t) {
  return n.type === t.type && !!n.key.isEqual(t.key) && !!n.precondition.isEqual(t.precondition) && !!function(i, r) {
    return i === void 0 && r === void 0 || !(!i || !r) && Lr(i, r, (s, o) => MC(s, o));
  }(n.fieldTransforms, t.fieldTransforms) && (n.type === 0 ? n.value.isEqual(t.value) : n.type !== 1 || n.data.isEqual(t.data) && n.fieldMask.isEqual(t.fieldMask));
}
class vo extends ml {
  constructor(t, e, i, r = []) {
    super(), this.key = t, this.value = e, this.precondition = i, this.fieldTransforms = r, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class Zi extends ml {
  constructor(t, e, i, r, s = []) {
    super(), this.key = t, this.data = e, this.fieldMask = i, this.precondition = r, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
function q0(n) {
  const t = /* @__PURE__ */ new Map();
  return n.fieldMask.fields.forEach((e) => {
    if (!e.isEmpty()) {
      const i = n.data.field(e);
      t.set(e, i);
    }
  }), t;
}
function Xf(n, t, e) {
  const i = /* @__PURE__ */ new Map();
  yt(n.length === e.length);
  for (let r = 0; r < e.length; r++) {
    const s = n[r], o = s.transform, a = t.data.field(s.field);
    i.set(s.field, kC(o, a, e[r]));
  }
  return i;
}
function Kf(n, t, e) {
  const i = /* @__PURE__ */ new Map();
  for (const r of n) {
    const s = r.transform, o = e.data.field(r.field);
    i.set(r.field, RC(s, o, t));
  }
  return i;
}
class W0 extends ml {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class OC extends ml {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FC {
  /**
   * @param batchId - The unique ID of this mutation batch.
   * @param localWriteTime - The original write time of this mutation.
   * @param baseMutations - Mutations that are used to populate the base
   * values when this mutation is applied locally. This can be used to locally
   * overwrite values that are persisted in the remote document cache. Base
   * mutations are never sent to the backend.
   * @param mutations - The user-provided mutations in this mutation batch.
   * User-provided mutations are applied both locally and remotely on the
   * backend.
   */
  constructor(t, e, i, r) {
    this.batchId = t, this.localWriteTime = e, this.baseMutations = i, this.mutations = r;
  }
  /**
   * Applies all the mutations in this MutationBatch to the specified document
   * to compute the state of the remote document
   *
   * @param document - The document to apply mutations to.
   * @param batchResult - The result of applying the MutationBatch to the
   * backend.
   */
  applyToRemoteDocument(t, e) {
    const i = e.mutationResults;
    for (let r = 0; r < this.mutations.length; r++) {
      const s = this.mutations[r];
      s.key.isEqual(t.key) && DC(s, t, i[r]);
    }
  }
  /**
   * Computes the local view of a document given all the mutations in this
   * batch.
   *
   * @param document - The document to apply mutations to.
   * @param mutatedFields - Fields that have been updated before applying this mutation batch.
   * @returns A `FieldMask` representing all the fields that are mutated.
   */
  applyToLocalView(t, e) {
    for (const i of this.baseMutations) i.key.isEqual(t.key) && (e = Hs(i, t, e, this.localWriteTime));
    for (const i of this.mutations) i.key.isEqual(t.key) && (e = Hs(i, t, e, this.localWriteTime));
    return e;
  }
  /**
   * Computes the local view for all provided documents given the mutations in
   * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to
   * replace all the mutation applications.
   */
  applyToLocalDocumentSet(t, e) {
    const i = L0();
    return this.mutations.forEach((r) => {
      const s = t.get(r.key), o = s.overlayedDocument;
      let a = this.applyToLocalView(o, s.mutatedFields);
      a = e.has(r.key) ? null : a;
      const l = H0(o, a);
      l !== null && i.set(r.key, l), o.isValidDocument() || o.convertToNoDocument(nt.min());
    }), i;
  }
  keys() {
    return this.mutations.reduce((t, e) => t.add(e.key), at());
  }
  isEqual(t) {
    return this.batchId === t.batchId && Lr(this.mutations, t.mutations, (e, i) => Yf(e, i)) && Lr(this.baseMutations, t.baseMutations, (e, i) => Yf(e, i));
  }
}
class ku {
  constructor(t, e, i, r) {
    this.batch = t, this.commitVersion = e, this.mutationResults = i, this.docVersions = r;
  }
  /**
   * Creates a new MutationBatchResult for the given batch and results. There
   * must be one result for each mutation in the batch. This static factory
   * caches a document=&gt;version mapping (docVersions).
   */
  static from(t, e, i) {
    yt(t.mutations.length === i.length);
    let r = /* @__PURE__ */ function() {
      return SC;
    }();
    const s = t.mutations;
    for (let o = 0; o < s.length; o++) r = r.insert(s[o].key, i[o].version);
    return new ku(t, e, i, r);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LC {
  constructor(t, e) {
    this.largestBatchId = t, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t) {
    return t !== null && this.mutation === t.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NC {
  constructor(t, e) {
    this.count = t, this.unchangedNames = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Gt, ct;
function UC(n) {
  switch (n) {
    default:
      return et();
    case N.CANCELLED:
    case N.UNKNOWN:
    case N.DEADLINE_EXCEEDED:
    case N.RESOURCE_EXHAUSTED:
    case N.INTERNAL:
    case N.UNAVAILABLE:
    case N.UNAUTHENTICATED:
      return !1;
    case N.INVALID_ARGUMENT:
    case N.NOT_FOUND:
    case N.ALREADY_EXISTS:
    case N.PERMISSION_DENIED:
    case N.FAILED_PRECONDITION:
    case N.ABORTED:
    case N.OUT_OF_RANGE:
    case N.UNIMPLEMENTED:
    case N.DATA_LOSS:
      return !0;
  }
}
function Y0(n) {
  if (n === void 0)
    return jn("GRPC error has no .code"), N.UNKNOWN;
  switch (n) {
    case Gt.OK:
      return N.OK;
    case Gt.CANCELLED:
      return N.CANCELLED;
    case Gt.UNKNOWN:
      return N.UNKNOWN;
    case Gt.DEADLINE_EXCEEDED:
      return N.DEADLINE_EXCEEDED;
    case Gt.RESOURCE_EXHAUSTED:
      return N.RESOURCE_EXHAUSTED;
    case Gt.INTERNAL:
      return N.INTERNAL;
    case Gt.UNAVAILABLE:
      return N.UNAVAILABLE;
    case Gt.UNAUTHENTICATED:
      return N.UNAUTHENTICATED;
    case Gt.INVALID_ARGUMENT:
      return N.INVALID_ARGUMENT;
    case Gt.NOT_FOUND:
      return N.NOT_FOUND;
    case Gt.ALREADY_EXISTS:
      return N.ALREADY_EXISTS;
    case Gt.PERMISSION_DENIED:
      return N.PERMISSION_DENIED;
    case Gt.FAILED_PRECONDITION:
      return N.FAILED_PRECONDITION;
    case Gt.ABORTED:
      return N.ABORTED;
    case Gt.OUT_OF_RANGE:
      return N.OUT_OF_RANGE;
    case Gt.UNIMPLEMENTED:
      return N.UNIMPLEMENTED;
    case Gt.DATA_LOSS:
      return N.DATA_LOSS;
    default:
      return et();
  }
}
(ct = Gt || (Gt = {}))[ct.OK = 0] = "OK", ct[ct.CANCELLED = 1] = "CANCELLED", ct[ct.UNKNOWN = 2] = "UNKNOWN", ct[ct.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ct[ct.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ct[ct.NOT_FOUND = 5] = "NOT_FOUND", ct[ct.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ct[ct.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ct[ct.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ct[ct.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ct[ct.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ct[ct.ABORTED = 10] = "ABORTED", ct[ct.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ct[ct.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ct[ct.INTERNAL = 13] = "INTERNAL", ct[ct.UNAVAILABLE = 14] = "UNAVAILABLE", ct[ct.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zC() {
  return new TextEncoder();
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jC = new ji([4294967295, 4294967295], 0);
function Qf(n) {
  const t = zC().encode(n), e = new m0();
  return e.update(t), new Uint8Array(e.digest());
}
function Jf(n) {
  const t = new DataView(n.buffer), e = t.getUint32(
    0,
    /* littleEndian= */
    !0
  ), i = t.getUint32(
    4,
    /* littleEndian= */
    !0
  ), r = t.getUint32(
    8,
    /* littleEndian= */
    !0
  ), s = t.getUint32(
    12,
    /* littleEndian= */
    !0
  );
  return [new ji([e, i], 0), new ji([r, s], 0)];
}
class Mu {
  constructor(t, e, i) {
    if (this.bitmap = t, this.padding = e, this.hashCount = i, e < 0 || e >= 8) throw new Vs(`Invalid padding: ${e}`);
    if (i < 0) throw new Vs(`Invalid hash count: ${i}`);
    if (t.length > 0 && this.hashCount === 0)
      throw new Vs(`Invalid hash count: ${i}`);
    if (t.length === 0 && e !== 0)
      throw new Vs(`Invalid padding when bitmap length is 0: ${e}`);
    this.Te = 8 * t.length - e, // Set the bit count in Integer to avoid repetition in mightContain().
    this.Ie = ji.fromNumber(this.Te);
  }
  // Calculate the ith hash value based on the hashed 64bit integers,
  // and calculate its corresponding bit index in the bitmap to be checked.
  Ee(t, e, i) {
    let r = t.add(e.multiply(ji.fromNumber(i)));
    return r.compare(jC) === 1 && (r = new ji([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Ie).toNumber();
  }
  // Return whether the bit on the given index in the bitmap is set to 1.
  de(t) {
    return (this.bitmap[Math.floor(t / 8)] & 1 << t % 8) != 0;
  }
  mightContain(t) {
    if (this.Te === 0) return !1;
    const e = Qf(t), [i, r] = Jf(e);
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(i, r, s);
      if (!this.de(o)) return !1;
    }
    return !0;
  }
  /** Create bloom filter for testing purposes only. */
  static create(t, e, i) {
    const r = t % 8 == 0 ? 0 : 8 - t % 8, s = new Uint8Array(Math.ceil(t / 8)), o = new Mu(s, r, e);
    return i.forEach((a) => o.insert(a)), o;
  }
  insert(t) {
    if (this.Te === 0) return;
    const e = Qf(t), [i, r] = Jf(e);
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(i, r, s);
      this.Ae(o);
    }
  }
  Ae(t) {
    const e = Math.floor(t / 8), i = t % 8;
    this.bitmap[e] |= 1 << i;
  }
}
class Vs extends Error {
  constructor() {
    super(...arguments), this.name = "BloomFilterError";
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gl {
  constructor(t, e, i, r, s) {
    this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = i, this.documentUpdates = r, this.resolvedLimboDocuments = s;
  }
  /**
   * HACK: Views require RemoteEvents in order to determine whether the view is
   * CURRENT, but secondary tabs don't receive remote events. So this method is
   * used to create a synthesized RemoteEvent that can be used to apply a
   * CURRENT status change to a View, for queries executed in a different tab.
   */
  // PORTING NOTE: Multi-tab only
  static createSynthesizedRemoteEventForCurrentChange(t, e, i) {
    const r = /* @__PURE__ */ new Map();
    return r.set(t, xo.createSynthesizedTargetChangeForCurrentChange(t, e, i)), new gl(nt.min(), r, new Ot(lt), Gn(), at());
  }
}
class xo {
  constructor(t, e, i, r, s) {
    this.resumeToken = t, this.current = e, this.addedDocuments = i, this.modifiedDocuments = r, this.removedDocuments = s;
  }
  /**
   * This method is used to create a synthesized TargetChanges that can be used to
   * apply a CURRENT status change to a View (for queries executed in a different
   * tab) or for new queries (to raise snapshots with correct CURRENT status).
   */
  static createSynthesizedTargetChangeForCurrentChange(t, e, i) {
    return new xo(i, e, at(), at(), at());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ma {
  constructor(t, e, i, r) {
    this.Re = t, this.removedTargetIds = e, this.key = i, this.Ve = r;
  }
}
class X0 {
  constructor(t, e) {
    this.targetId = t, this.me = e;
  }
}
class K0 {
  constructor(t, e, i = de.EMPTY_BYTE_STRING, r = null) {
    this.state = t, this.targetIds = e, this.resumeToken = i, this.cause = r;
  }
}
class Zf {
  constructor() {
    this.fe = 0, /**
     * Keeps track of the document changes since the last raised snapshot.
     *
     * These changes are continuously updated as we receive document updates and
     * always reflect the current set of changes against the last issued snapshot.
     */
    this.ge = $f(), /** See public getters for explanations of these fields. */
    this.pe = de.EMPTY_BYTE_STRING, this.ye = !1, /**
     * Whether this target state should be included in the next snapshot. We
     * initialize to true so that newly-added targets are included in the next
     * RemoteEvent.
     */
    this.we = !0;
  }
  /**
   * Whether this target has been marked 'current'.
   *
   * 'Current' has special meaning in the RPC protocol: It implies that the
   * Watch backend has sent us all changes up to the point at which the target
   * was added and that the target is consistent with the rest of the watch
   * stream.
   */
  get current() {
    return this.ye;
  }
  /** The last resume token sent to us for this target. */
  get resumeToken() {
    return this.pe;
  }
  /** Whether this target has pending target adds or target removes. */
  get Se() {
    return this.fe !== 0;
  }
  /** Whether we have modified any state that should trigger a snapshot. */
  get be() {
    return this.we;
  }
  /**
   * Applies the resume token to the TargetChange, but only when it has a new
   * value. Empty resumeTokens are discarded.
   */
  De(t) {
    t.approximateByteSize() > 0 && (this.we = !0, this.pe = t);
  }
  /**
   * Creates a target change from the current set of changes.
   *
   * To reset the document changes after raising this snapshot, call
   * `clearPendingChanges()`.
   */
  ve() {
    let t = at(), e = at(), i = at();
    return this.ge.forEach((r, s) => {
      switch (s) {
        case 0:
          t = t.add(r);
          break;
        case 2:
          e = e.add(r);
          break;
        case 1:
          i = i.add(r);
          break;
        default:
          et();
      }
    }), new xo(this.pe, this.ye, t, e, i);
  }
  /**
   * Resets the document changes and sets `hasPendingChanges` to false.
   */
  Ce() {
    this.we = !1, this.ge = $f();
  }
  Fe(t, e) {
    this.we = !0, this.ge = this.ge.insert(t, e);
  }
  Me(t) {
    this.we = !0, this.ge = this.ge.remove(t);
  }
  xe() {
    this.fe += 1;
  }
  Oe() {
    this.fe -= 1, yt(this.fe >= 0);
  }
  Ne() {
    this.we = !0, this.ye = !0;
  }
}
class GC {
  constructor(t) {
    this.Le = t, /** The internal state of all tracked targets. */
    this.Be = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
    this.ke = Gn(), this.qe = ta(), /** A mapping of document keys to their set of target IDs. */
    this.Qe = ta(), /**
     * A map of targets with existence filter mismatches. These targets are
     * known to be inconsistent and their listens needs to be re-established by
     * RemoteStore.
     */
    this.Ke = new Ot(lt);
  }
  /**
   * Processes and adds the DocumentWatchChange to the current set of changes.
   */
  $e(t) {
    for (const e of t.Re) t.Ve && t.Ve.isFoundDocument() ? this.Ue(e, t.Ve) : this.We(e, t.key, t.Ve);
    for (const e of t.removedTargetIds) this.We(e, t.key, t.Ve);
  }
  /** Processes and adds the WatchTargetChange to the current set of changes. */
  Ge(t) {
    this.forEachTarget(t, (e) => {
      const i = this.ze(e);
      switch (t.state) {
        case 0:
          this.je(e) && i.De(t.resumeToken);
          break;
        case 1:
          i.Oe(), i.Se || // We have a freshly added target, so we need to reset any state
          // that we had previously. This can happen e.g. when remove and add
          // back a target for existence filter mismatches.
          i.Ce(), i.De(t.resumeToken);
          break;
        case 2:
          i.Oe(), i.Se || this.removeTarget(e);
          break;
        case 3:
          this.je(e) && (i.Ne(), i.De(t.resumeToken));
          break;
        case 4:
          this.je(e) && // Reset the target and synthesizes removes for all existing
          // documents. The backend will re-add any documents that still
          // match the target before it sends the next global snapshot.
          (this.He(e), i.De(t.resumeToken));
          break;
        default:
          et();
      }
    });
  }
  /**
   * Iterates over all targetIds that the watch change applies to: either the
   * targetIds explicitly listed in the change or the targetIds of all currently
   * active targets.
   */
  forEachTarget(t, e) {
    t.targetIds.length > 0 ? t.targetIds.forEach(e) : this.Be.forEach((i, r) => {
      this.je(r) && e(r);
    });
  }
  /**
   * Handles existence filters and synthesizes deletes for filter mismatches.
   * Targets that are invalidated by filter mismatches are added to
   * `pendingTargetResets`.
   */
  Je(t) {
    const e = t.targetId, i = t.me.count, r = this.Ye(e);
    if (r) {
      const s = r.target;
      if (Rc(s)) if (i === 0) {
        const o = new Z(s.path);
        this.We(e, o, ye.newNoDocument(o, nt.min()));
      } else yt(i === 1);
      else {
        const o = this.Ze(e);
        if (o !== i) {
          const a = this.Xe(t), l = a ? this.et(a, t, o) : 1;
          if (l !== 0) {
            this.He(e);
            const h = l === 2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
            this.Ke = this.Ke.insert(e, h);
          }
        }
      }
    }
  }
  /**
   * Parse the bloom filter from the "unchanged_names" field of an existence
   * filter.
   */
  Xe(t) {
    const e = t.me.unchangedNames;
    if (!e || !e.bits) return null;
    const { bits: { bitmap: i = "", padding: r = 0 }, hashCount: s = 0 } = e;
    let o, a;
    try {
      o = ui(i).toUint8Array();
    } catch (l) {
      if (l instanceof T0) return Fr("Decoding the base64 bloom filter in existence filter failed (" + l.message + "); ignoring the bloom filter and falling back to full re-query."), null;
      throw l;
    }
    try {
      a = new Mu(o, r, s);
    } catch (l) {
      return Fr(l instanceof Vs ? "BloomFilter error: " : "Applying bloom filter failed: ", l), null;
    }
    return a.Te === 0 ? null : a;
  }
  /**
   * Apply bloom filter to remove the deleted documents, and return the
   * application status.
   */
  et(t, e, i) {
    return e.me.count === i - this.rt(t, e.targetId) ? 0 : 2;
  }
  /**
   * Filter out removed documents based on bloom filter membership result and
   * return number of documents removed.
   */
  rt(t, e) {
    const i = this.Le.getRemoteKeysForTarget(e);
    let r = 0;
    return i.forEach((s) => {
      const o = this.Le.nt(), a = `projects/${o.projectId}/databases/${o.database}/documents/${s.path.canonicalString()}`;
      t.mightContain(a) || (this.We(
        e,
        s,
        /*updatedDocument=*/
        null
      ), r++);
    }), r;
  }
  /**
   * Converts the currently accumulated state into a remote event at the
   * provided snapshot version. Resets the accumulated changes before returning.
   */
  it(t) {
    const e = /* @__PURE__ */ new Map();
    this.Be.forEach((s, o) => {
      const a = this.Ye(o);
      if (a) {
        if (s.current && Rc(a.target)) {
          const l = new Z(a.target.path);
          this.st(l).has(o) || this.ot(o, l) || this.We(o, l, ye.newNoDocument(l, t));
        }
        s.be && (e.set(o, s.ve()), s.Ce());
      }
    });
    let i = at();
    this.Qe.forEach((s, o) => {
      let a = !0;
      o.forEachWhile((l) => {
        const h = this.Ye(l);
        return !h || h.purpose === "TargetPurposeLimboResolution" || (a = !1, !1);
      }), a && (i = i.add(s));
    }), this.ke.forEach((s, o) => o.setReadTime(t));
    const r = new gl(t, e, this.Ke, this.ke, i);
    return this.ke = Gn(), this.qe = ta(), this.Qe = ta(), this.Ke = new Ot(lt), r;
  }
  /**
   * Adds the provided document to the internal list of document updates and
   * its document key to the given target's mapping.
   */
  // Visible for testing.
  Ue(t, e) {
    if (!this.je(t)) return;
    const i = this.ot(t, e.key) ? 2 : 0;
    this.ze(t).Fe(e.key, i), this.ke = this.ke.insert(e.key, e), this.qe = this.qe.insert(e.key, this.st(e.key).add(t)), this.Qe = this.Qe.insert(e.key, this._t(e.key).add(t));
  }
  /**
   * Removes the provided document from the target mapping. If the
   * document no longer matches the target, but the document's state is still
   * known (e.g. we know that the document was deleted or we received the change
   * that caused the filter mismatch), the new document can be provided
   * to update the remote document cache.
   */
  // Visible for testing.
  We(t, e, i) {
    if (!this.je(t)) return;
    const r = this.ze(t);
    this.ot(t, e) ? r.Fe(
      e,
      1
      /* ChangeType.Removed */
    ) : (
      // The document may have entered and left the target before we raised a
      // snapshot, so we can just ignore the change.
      r.Me(e)
    ), this.Qe = this.Qe.insert(e, this._t(e).delete(t)), this.Qe = this.Qe.insert(e, this._t(e).add(t)), i && (this.ke = this.ke.insert(e, i));
  }
  removeTarget(t) {
    this.Be.delete(t);
  }
  /**
   * Returns the current count of documents in the target. This includes both
   * the number of documents that the LocalStore considers to be part of the
   * target as well as any accumulated changes.
   */
  Ze(t) {
    const e = this.ze(t).ve();
    return this.Le.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  /**
   * Increment the number of acks needed from watch before we can consider the
   * server to be 'in-sync' with the client's active targets.
   */
  xe(t) {
    this.ze(t).xe();
  }
  ze(t) {
    let e = this.Be.get(t);
    return e || (e = new Zf(), this.Be.set(t, e)), e;
  }
  _t(t) {
    let e = this.Qe.get(t);
    return e || (e = new $t(lt), this.Qe = this.Qe.insert(t, e)), e;
  }
  st(t) {
    let e = this.qe.get(t);
    return e || (e = new $t(lt), this.qe = this.qe.insert(t, e)), e;
  }
  /**
   * Verifies that the user is still interested in this target (by calling
   * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
   * from watch.
   */
  je(t) {
    const e = this.Ye(t) !== null;
    return e || q("WatchChangeAggregator", "Detected inactive target", t), e;
  }
  /**
   * Returns the TargetData for an active target (i.e. a target that the user
   * is still interested in that has no outstanding target change requests).
   */
  Ye(t) {
    const e = this.Be.get(t);
    return e && e.Se ? null : this.Le.ut(t);
  }
  /**
   * Resets the state of a Watch target to its initial state (e.g. sets
   * 'current' to false, clears the resume token and removes its target mapping
   * from all documents).
   */
  He(t) {
    this.Be.set(t, new Zf()), this.Le.getRemoteKeysForTarget(t).forEach((e) => {
      this.We(
        t,
        e,
        /*updatedDocument=*/
        null
      );
    });
  }
  /**
   * Returns whether the LocalStore considers the document to be part of the
   * specified target.
   */
  ot(t, e) {
    return this.Le.getRemoteKeysForTarget(t).has(e);
  }
}
function ta() {
  return new Ot(Z.comparator);
}
function $f() {
  return new Ot(Z.comparator);
}
const HC = {
  asc: "ASCENDING",
  desc: "DESCENDING"
}, qC = {
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
}, WC = {
  and: "AND",
  or: "OR"
};
class YC {
  constructor(t, e) {
    this.databaseId = t, this.useProto3Json = e;
  }
}
function Mc(n, t) {
  return n.useProto3Json || cl(t) ? t : {
    value: t
  };
}
function za(n, t) {
  return n.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : {
    seconds: "" + t.seconds,
    nanos: t.nanoseconds
  };
}
function Q0(n, t) {
  return n.useProto3Json ? t.toBase64() : t.toUint8Array();
}
function XC(n, t) {
  return za(n, t.toTimestamp());
}
function An(n) {
  return yt(!!n), nt.fromTimestamp(function(e) {
    const i = ci(e);
    return new Zt(i.seconds, i.nanos);
  }(n));
}
function Vu(n, t) {
  return Vc(n, t).canonicalString();
}
function Vc(n, t) {
  const e = function(r) {
    return new Tt(["projects", r.projectId, "databases", r.database]);
  }(n).child("documents");
  return t === void 0 ? e : e.child(t);
}
function J0(n) {
  const t = Tt.fromString(n);
  return yt(n_(t)), t;
}
function Dc(n, t) {
  return Vu(n.databaseId, t.path);
}
function Ch(n, t) {
  const e = J0(t);
  if (e.get(1) !== n.databaseId.projectId) throw new Y(N.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + e.get(1) + " vs " + n.databaseId.projectId);
  if (e.get(3) !== n.databaseId.database) throw new Y(N.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + e.get(3) + " vs " + n.databaseId.database);
  return new Z($0(e));
}
function Z0(n, t) {
  return Vu(n.databaseId, t);
}
function KC(n) {
  const t = J0(n);
  return t.length === 4 ? Tt.emptyPath() : $0(t);
}
function Bc(n) {
  return new Tt(["projects", n.databaseId.projectId, "databases", n.databaseId.database]).canonicalString();
}
function $0(n) {
  return yt(n.length > 4 && n.get(4) === "documents"), n.popFirst(5);
}
function tm(n, t, e) {
  return {
    name: Dc(n, t),
    fields: e.value.mapValue.fields
  };
}
function QC(n, t) {
  let e;
  if ("targetChange" in t) {
    t.targetChange;
    const i = function(h) {
      return h === "NO_CHANGE" ? 0 : h === "ADD" ? 1 : h === "REMOVE" ? 2 : h === "CURRENT" ? 3 : h === "RESET" ? 4 : et();
    }(t.targetChange.targetChangeType || "NO_CHANGE"), r = t.targetChange.targetIds || [], s = function(h, c) {
      return h.useProto3Json ? (yt(c === void 0 || typeof c == "string"), de.fromBase64String(c || "")) : (yt(c === void 0 || // Check if the value is an instance of both Buffer and Uint8Array,
      // despite the fact that Buffer extends Uint8Array. In some
      // environments, such as jsdom, the prototype chain of Buffer
      // does not indicate that it extends Uint8Array.
      c instanceof Buffer || c instanceof Uint8Array), de.fromUint8Array(c || new Uint8Array()));
    }(n, t.targetChange.resumeToken), o = t.targetChange.cause, a = o && function(h) {
      const c = h.code === void 0 ? N.UNKNOWN : Y0(h.code);
      return new Y(c, h.message || "");
    }(o);
    e = new K0(i, r, s, a || null);
  } else if ("documentChange" in t) {
    t.documentChange;
    const i = t.documentChange;
    i.document, i.document.name, i.document.updateTime;
    const r = Ch(n, i.document.name), s = An(i.document.updateTime), o = i.document.createTime ? An(i.document.createTime) : nt.min(), a = new en({
      mapValue: {
        fields: i.document.fields
      }
    }), l = ye.newFoundDocument(r, s, o, a), h = i.targetIds || [], c = i.removedTargetIds || [];
    e = new ma(h, c, l.key, l);
  } else if ("documentDelete" in t) {
    t.documentDelete;
    const i = t.documentDelete;
    i.document;
    const r = Ch(n, i.document), s = i.readTime ? An(i.readTime) : nt.min(), o = ye.newNoDocument(r, s), a = i.removedTargetIds || [];
    e = new ma([], a, o.key, o);
  } else if ("documentRemove" in t) {
    t.documentRemove;
    const i = t.documentRemove;
    i.document;
    const r = Ch(n, i.document), s = i.removedTargetIds || [];
    e = new ma([], s, r, null);
  } else {
    if (!("filter" in t)) return et();
    {
      t.filter;
      const i = t.filter;
      i.targetId;
      const { count: r = 0, unchangedNames: s } = i, o = new NC(r, s), a = i.targetId;
      e = new X0(a, o);
    }
  }
  return e;
}
function JC(n, t) {
  let e;
  if (t instanceof vo) e = {
    update: tm(n, t.key, t.value)
  };
  else if (t instanceof W0) e = {
    delete: Dc(n, t.key)
  };
  else if (t instanceof Zi) e = {
    update: tm(n, t.key, t.data),
    updateMask: oP(t.fieldMask)
  };
  else {
    if (!(t instanceof OC)) return et();
    e = {
      verify: Dc(n, t.key)
    };
  }
  return t.fieldTransforms.length > 0 && (e.updateTransforms = t.fieldTransforms.map((i) => function(s, o) {
    const a = o.transform;
    if (a instanceof Na) return {
      fieldPath: o.field.canonicalString(),
      setToServerValue: "REQUEST_TIME"
    };
    if (a instanceof mo) return {
      fieldPath: o.field.canonicalString(),
      appendMissingElements: {
        values: a.elements
      }
    };
    if (a instanceof go) return {
      fieldPath: o.field.canonicalString(),
      removeAllFromArray: {
        values: a.elements
      }
    };
    if (a instanceof Ua) return {
      fieldPath: o.field.canonicalString(),
      increment: a.Pe
    };
    throw et();
  }(0, i))), t.precondition.isNone || (e.currentDocument = function(r, s) {
    return s.updateTime !== void 0 ? {
      updateTime: XC(r, s.updateTime)
    } : s.exists !== void 0 ? {
      exists: s.exists
    } : et();
  }(n, t.precondition)), e;
}
function ZC(n, t) {
  return n && n.length > 0 ? (yt(t !== void 0), n.map((e) => function(r, s) {
    let o = r.updateTime ? An(r.updateTime) : An(s);
    return o.isEqual(nt.min()) && // The Firestore Emulator currently returns an update time of 0 for
    // deletes of non-existing documents (rather than null). This breaks the
    // test "get deleted doc while offline with source=cache" as NoDocuments
    // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
    // TODO(#2149): Remove this when Emulator is fixed
    (o = An(s)), new VC(o, r.transformResults || []);
  }(e, t))) : [];
}
function $C(n, t) {
  return {
    documents: [Z0(n, t.path)]
  };
}
function tP(n, t) {
  const e = {
    structuredQuery: {}
  }, i = t.path;
  let r;
  t.collectionGroup !== null ? (r = i, e.structuredQuery.from = [{
    collectionId: t.collectionGroup,
    allDescendants: !0
  }]) : (r = i.popLast(), e.structuredQuery.from = [{
    collectionId: i.lastSegment()
  }]), e.parent = Z0(n, r);
  const s = function(h) {
    if (h.length !== 0)
      return e_(dn.create(
        h,
        "and"
        /* CompositeOperator.AND */
      ));
  }(t.filters);
  s && (e.structuredQuery.where = s);
  const o = function(h) {
    if (h.length !== 0)
      return h.map((c) => (
        // visible for testing
        function(f) {
          return {
            field: pr(f.field),
            direction: iP(f.dir)
          };
        }(c)
      ));
  }(t.orderBy);
  o && (e.structuredQuery.orderBy = o);
  const a = Mc(n, t.limit);
  return a !== null && (e.structuredQuery.limit = a), t.startAt && (e.structuredQuery.startAt = function(h) {
    return {
      before: h.inclusive,
      values: h.position
    };
  }(t.startAt)), t.endAt && (e.structuredQuery.endAt = function(h) {
    return {
      before: !h.inclusive,
      values: h.position
    };
  }(t.endAt)), {
    ct: e,
    parent: r
  };
}
function eP(n) {
  let t = KC(n.parent);
  const e = n.structuredQuery, i = e.from ? e.from.length : 0;
  let r = null;
  if (i > 0) {
    yt(i === 1);
    const c = e.from[0];
    c.allDescendants ? r = c.collectionId : t = t.child(c.collectionId);
  }
  let s = [];
  e.where && (s = function(p) {
    const f = t_(p);
    return f instanceof dn && P0(f) ? f.getFilters() : [f];
  }(e.where));
  let o = [];
  e.orderBy && (o = function(p) {
    return p.map((f) => function(m) {
      return new fo(
        fr(m.field),
        // visible for testing
        function(y) {
          switch (y) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(m.direction)
      );
    }(f));
  }(e.orderBy));
  let a = null;
  e.limit && (a = function(p) {
    let f;
    return f = typeof p == "object" ? p.value : p, cl(f) ? null : f;
  }(e.limit));
  let l = null;
  e.startAt && (l = function(p) {
    const f = !!p.before, u = p.values || [];
    return new Fa(u, f);
  }(e.startAt));
  let h = null;
  return e.endAt && (h = function(p) {
    const f = !p.before, u = p.values || [];
    return new Fa(u, f);
  }(e.endAt)), xC(t, r, o, s, a, "F", l, h);
}
function nP(n, t) {
  const e = function(r) {
    switch (r) {
      case "TargetPurposeListen":
        return null;
      case "TargetPurposeExistenceFilterMismatch":
        return "existence-filter-mismatch";
      case "TargetPurposeExistenceFilterMismatchBloom":
        return "existence-filter-mismatch-bloom";
      case "TargetPurposeLimboResolution":
        return "limbo-document";
      default:
        return et();
    }
  }(t.purpose);
  return e == null ? null : {
    "goog-listen-tags": e
  };
}
function t_(n) {
  return n.unaryFilter !== void 0 ? function(e) {
    switch (e.unaryFilter.op) {
      case "IS_NAN":
        const i = fr(e.unaryFilter.field);
        return qt.create(i, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const r = fr(e.unaryFilter.field);
        return qt.create(r, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const s = fr(e.unaryFilter.field);
        return qt.create(s, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const o = fr(e.unaryFilter.field);
        return qt.create(o, "!=", {
          nullValue: "NULL_VALUE"
        });
      default:
        return et();
    }
  }(n) : n.fieldFilter !== void 0 ? function(e) {
    return qt.create(fr(e.fieldFilter.field), function(r) {
      switch (r) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        default:
          return et();
      }
    }(e.fieldFilter.op), e.fieldFilter.value);
  }(n) : n.compositeFilter !== void 0 ? function(e) {
    return dn.create(e.compositeFilter.filters.map((i) => t_(i)), function(r) {
      switch (r) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return et();
      }
    }(e.compositeFilter.op));
  }(n) : et();
}
function iP(n) {
  return HC[n];
}
function rP(n) {
  return qC[n];
}
function sP(n) {
  return WC[n];
}
function pr(n) {
  return {
    fieldPath: n.canonicalString()
  };
}
function fr(n) {
  return ce.fromServerFormat(n.fieldPath);
}
function e_(n) {
  return n instanceof qt ? function(e) {
    if (e.op === "==") {
      if (zf(e.value)) return {
        unaryFilter: {
          field: pr(e.field),
          op: "IS_NAN"
        }
      };
      if (Uf(e.value)) return {
        unaryFilter: {
          field: pr(e.field),
          op: "IS_NULL"
        }
      };
    } else if (e.op === "!=") {
      if (zf(e.value)) return {
        unaryFilter: {
          field: pr(e.field),
          op: "IS_NOT_NAN"
        }
      };
      if (Uf(e.value)) return {
        unaryFilter: {
          field: pr(e.field),
          op: "IS_NOT_NULL"
        }
      };
    }
    return {
      fieldFilter: {
        field: pr(e.field),
        op: rP(e.op),
        value: e.value
      }
    };
  }(n) : n instanceof dn ? function(e) {
    const i = e.getFilters().map((r) => e_(r));
    return i.length === 1 ? i[0] : {
      compositeFilter: {
        op: sP(e.op),
        filters: i
      }
    };
  }(n) : et();
}
function oP(n) {
  const t = [];
  return n.fields.forEach((e) => t.push(e.canonicalString())), {
    fieldPaths: t
  };
}
function n_(n) {
  return n.length >= 4 && n.get(0) === "projects" && n.get(2) === "databases";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $n {
  constructor(t, e, i, r, s = nt.min(), o = nt.min(), a = de.EMPTY_BYTE_STRING, l = null) {
    this.target = t, this.targetId = e, this.purpose = i, this.sequenceNumber = r, this.snapshotVersion = s, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = a, this.expectedCount = l;
  }
  /** Creates a new target data instance with an updated sequence number. */
  withSequenceNumber(t) {
    return new $n(this.target, this.targetId, this.purpose, t, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
  }
  /**
   * Creates a new target data instance with an updated resume token and
   * snapshot version.
   */
  withResumeToken(t, e) {
    return new $n(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      e,
      this.lastLimboFreeSnapshotVersion,
      t,
      /* expectedCount= */
      null
    );
  }
  /**
   * Creates a new target data instance with an updated expected count.
   */
  withExpectedCount(t) {
    return new $n(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, t);
  }
  /**
   * Creates a new target data instance with an updated last limbo free
   * snapshot version number.
   */
  withLastLimboFreeSnapshotVersion(t) {
    return new $n(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t, this.resumeToken, this.expectedCount);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aP {
  constructor(t) {
    this.ht = t;
  }
}
function lP(n) {
  const t = eP({
    parent: n.parent,
    structuredQuery: n.structuredQuery
  });
  return n.limitType === "LAST" ? La(
    t,
    t.limit,
    "L"
    /* LimitType.Last */
  ) : t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hP {
  constructor() {
    this.ln = new cP();
  }
  addToCollectionParentIndex(t, e) {
    return this.ln.add(e), L.resolve();
  }
  getCollectionParents(t, e) {
    return L.resolve(this.ln.getEntries(e));
  }
  addFieldIndex(t, e) {
    return L.resolve();
  }
  deleteFieldIndex(t, e) {
    return L.resolve();
  }
  deleteAllFieldIndexes(t) {
    return L.resolve();
  }
  createTargetIndexes(t, e) {
    return L.resolve();
  }
  getDocumentsMatchingTarget(t, e) {
    return L.resolve(null);
  }
  getIndexType(t, e) {
    return L.resolve(
      0
      /* IndexType.NONE */
    );
  }
  getFieldIndexes(t, e) {
    return L.resolve([]);
  }
  getNextCollectionGroupToUpdate(t) {
    return L.resolve(null);
  }
  getMinOffset(t, e) {
    return L.resolve(hi.min());
  }
  getMinOffsetFromCollectionGroup(t, e) {
    return L.resolve(hi.min());
  }
  updateCollectionGroup(t, e, i) {
    return L.resolve();
  }
  updateIndexEntries(t, e) {
    return L.resolve();
  }
}
class cP {
  constructor() {
    this.index = {};
  }
  // Returns false if the entry already existed.
  add(t) {
    const e = t.lastSegment(), i = t.popLast(), r = this.index[e] || new $t(Tt.comparator), s = !r.has(i);
    return this.index[e] = r.add(i), s;
  }
  has(t) {
    const e = t.lastSegment(), i = t.popLast(), r = this.index[e];
    return r && r.has(i);
  }
  getEntries(t) {
    return (this.index[t] || new $t(Tt.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const em = {
  didRun: !1,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
class ke {
  static withCacheSize(t) {
    return new ke(t, ke.DEFAULT_COLLECTION_PERCENTILE, ke.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
  constructor(t, e, i) {
    this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = i;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ke.DEFAULT_COLLECTION_PERCENTILE = 10, ke.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, ke.DEFAULT = new ke(41943040, ke.DEFAULT_COLLECTION_PERCENTILE, ke.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), ke.DISABLED = new ke(-1, 0, 0);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zr {
  constructor(t) {
    this.kn = t;
  }
  next() {
    return this.kn += 2, this.kn;
  }
  static qn() {
    return new zr(0);
  }
  static Qn() {
    return new zr(-1);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nm([n, t], [e, i]) {
  const r = lt(n, e);
  return r === 0 ? lt(t, i) : r;
}
class uP {
  constructor(t) {
    this.Gn = t, this.buffer = new $t(nm), this.zn = 0;
  }
  jn() {
    return ++this.zn;
  }
  Hn(t) {
    const e = [t, this.jn()];
    if (this.buffer.size < this.Gn) this.buffer = this.buffer.add(e);
    else {
      const i = this.buffer.last();
      nm(e, i) < 0 && (this.buffer = this.buffer.delete(i).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
}
class dP {
  constructor(t, e, i) {
    this.garbageCollector = t, this.asyncQueue = e, this.localStore = i, this.Jn = null;
  }
  start() {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Yn(6e4);
  }
  stop() {
    this.Jn && (this.Jn.cancel(), this.Jn = null);
  }
  get started() {
    return this.Jn !== null;
  }
  Yn(t) {
    q("LruGarbageCollector", `Garbage collection scheduled in ${t}ms`), this.Jn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t, async () => {
      this.Jn = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (e) {
        $r(e) ? q("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e) : await Zr(e);
      }
      await this.Yn(3e5);
    });
  }
}
class pP {
  constructor(t, e) {
    this.Zn = t, this.params = e;
  }
  calculateTargetCount(t, e) {
    return this.Zn.Xn(t).next((i) => Math.floor(e / 100 * i));
  }
  nthSequenceNumber(t, e) {
    if (e === 0) return L.resolve(hl.oe);
    const i = new uP(e);
    return this.Zn.forEachTarget(t, (r) => i.Hn(r.sequenceNumber)).next(() => this.Zn.er(t, (r) => i.Hn(r))).next(() => i.maxValue);
  }
  removeTargets(t, e, i) {
    return this.Zn.removeTargets(t, e, i);
  }
  removeOrphanedDocuments(t, e) {
    return this.Zn.removeOrphanedDocuments(t, e);
  }
  collect(t, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (q("LruGarbageCollector", "Garbage collection skipped; disabled"), L.resolve(em)) : this.getCacheSize(t).next((i) => i < this.params.cacheSizeCollectionThreshold ? (q("LruGarbageCollector", `Garbage collection skipped; Cache size ${i} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), em) : this.tr(t, e));
  }
  getCacheSize(t) {
    return this.Zn.getCacheSize(t);
  }
  tr(t, e) {
    let i, r, s, o, a, l, h;
    const c = Date.now();
    return this.calculateTargetCount(t, this.params.percentileToCollect).next((p) => (
      // Cap at the configured max
      (p > this.params.maximumSequenceNumbersToCollect ? (q("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${p}`), r = this.params.maximumSequenceNumbersToCollect) : r = p, o = Date.now(), this.nthSequenceNumber(t, r))
    )).next((p) => (i = p, a = Date.now(), this.removeTargets(t, i, e))).next((p) => (s = p, l = Date.now(), this.removeOrphanedDocuments(t, i))).next((p) => (h = Date.now(), ur() <= ut.DEBUG && q("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${o - c}ms
	Determined least recently used ${r} in ` + (a - o) + `ms
	Removed ${s} targets in ` + (l - a) + `ms
	Removed ${p} documents in ` + (h - l) + `ms
Total Duration: ${h - c}ms`), L.resolve({
      didRun: !0,
      sequenceNumbersCollected: r,
      targetsRemoved: s,
      documentsRemoved: p
    })));
  }
}
function fP(n, t) {
  return new pP(n, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mP {
  constructor() {
    this.changes = new Ji((t) => t.toString(), (t, e) => t.isEqual(e)), this.changesApplied = !1;
  }
  /**
   * Buffers a `RemoteDocumentCache.addEntry()` call.
   *
   * You can only modify documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  addEntry(t) {
    this.assertNotApplied(), this.changes.set(t.key, t);
  }
  /**
   * Buffers a `RemoteDocumentCache.removeEntry()` call.
   *
   * You can only remove documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  removeEntry(t, e) {
    this.assertNotApplied(), this.changes.set(t, ye.newInvalidDocument(t).setReadTime(e));
  }
  /**
   * Looks up an entry in the cache. The buffered changes will first be checked,
   * and if no buffered change applies, this will forward to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKey - The key of the entry to look up.
   * @returns The cached document or an invalid document if we have nothing
   * cached.
   */
  getEntry(t, e) {
    this.assertNotApplied();
    const i = this.changes.get(e);
    return i !== void 0 ? L.resolve(i) : this.getFromCache(t, e);
  }
  /**
   * Looks up several entries in the cache, forwarding to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKeys - The keys of the entries to look up.
   * @returns A map of cached documents, indexed by key. If an entry cannot be
   *     found, the corresponding key will be mapped to an invalid document.
   */
  getEntries(t, e) {
    return this.getAllFromCache(t, e);
  }
  /**
   * Applies buffered changes to the underlying RemoteDocumentCache, using
   * the provided transaction.
   */
  apply(t) {
    return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(t);
  }
  /** Helper to assert this.changes is not null  */
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gP {
  constructor(t, e) {
    this.overlayedDocument = t, this.mutatedFields = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yP {
  constructor(t, e, i, r) {
    this.remoteDocumentCache = t, this.mutationQueue = e, this.documentOverlayCache = i, this.indexManager = r;
  }
  /**
   * Get the local view of the document identified by `key`.
   *
   * @returns Local view of the document or null if we don't have any cached
   * state for it.
   */
  getDocument(t, e) {
    let i = null;
    return this.documentOverlayCache.getOverlay(t, e).next((r) => (i = r, this.remoteDocumentCache.getEntry(t, e))).next((r) => (i !== null && Hs(i.mutation, r, un.empty(), Zt.now()), r));
  }
  /**
   * Gets the local view of the documents identified by `keys`.
   *
   * If we don't have cached state for a document in `keys`, a NoDocument will
   * be stored for that key in the resulting set.
   */
  getDocuments(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((i) => this.getLocalViewOfDocuments(t, i, at()).next(() => i));
  }
  /**
   * Similar to `getDocuments`, but creates the local view from the given
   * `baseDocs` without retrieving documents from the local store.
   *
   * @param transaction - The transaction this operation is scoped to.
   * @param docs - The documents to apply local mutations to get the local views.
   * @param existenceStateChanged - The set of document keys whose existence state
   *   is changed. This is useful to determine if some documents overlay needs
   *   to be recalculated.
   */
  getLocalViewOfDocuments(t, e, i = at()) {
    const r = Fi();
    return this.populateOverlays(t, r, e).next(() => this.computeViews(t, e, r, i).next((s) => {
      let o = Ms();
      return s.forEach((a, l) => {
        o = o.insert(a, l.overlayedDocument);
      }), o;
    }));
  }
  /**
   * Gets the overlayed documents for the given document map, which will include
   * the local view of those documents and a `FieldMask` indicating which fields
   * are mutated locally, `null` if overlay is a Set or Delete mutation.
   */
  getOverlayedDocuments(t, e) {
    const i = Fi();
    return this.populateOverlays(t, i, e).next(() => this.computeViews(t, e, i, at()));
  }
  /**
   * Fetches the overlays for {@code docs} and adds them to provided overlay map
   * if the map does not already contain an entry for the given document key.
   */
  populateOverlays(t, e, i) {
    const r = [];
    return i.forEach((s) => {
      e.has(s) || r.push(s);
    }), this.documentOverlayCache.getOverlays(t, r).next((s) => {
      s.forEach((o, a) => {
        e.set(o, a);
      });
    });
  }
  /**
   * Computes the local view for the given documents.
   *
   * @param docs - The documents to compute views for. It also has the base
   *   version of the documents.
   * @param overlays - The overlays that need to be applied to the given base
   *   version of the documents.
   * @param existenceStateChanged - A set of documents whose existence states
   *   might have changed. This is used to determine if we need to re-calculate
   *   overlays from mutation queues.
   * @return A map represents the local documents view.
   */
  computeViews(t, e, i, r) {
    let s = Gn();
    const o = Gs(), a = function() {
      return Gs();
    }();
    return e.forEach((l, h) => {
      const c = i.get(h.key);
      r.has(h.key) && (c === void 0 || c.mutation instanceof Zi) ? s = s.insert(h.key, h) : c !== void 0 ? (o.set(h.key, c.mutation.getFieldMask()), Hs(c.mutation, h, c.mutation.getFieldMask(), Zt.now())) : (
        // no overlay exists
        // Using EMPTY to indicate there is no overlay for the document.
        o.set(h.key, un.empty())
      );
    }), this.recalculateAndSaveOverlays(t, s).next((l) => (l.forEach((h, c) => o.set(h, c)), e.forEach((h, c) => {
      var p;
      return a.set(h, new gP(c, (p = o.get(h)) !== null && p !== void 0 ? p : null));
    }), a));
  }
  recalculateAndSaveOverlays(t, e) {
    const i = Gs();
    let r = new Ot((o, a) => o - a), s = at();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, e).next((o) => {
      for (const a of o) a.keys().forEach((l) => {
        const h = e.get(l);
        if (h === null) return;
        let c = i.get(l) || un.empty();
        c = a.applyToLocalView(h, c), i.set(l, c);
        const p = (r.get(a.batchId) || at()).add(l);
        r = r.insert(a.batchId, p);
      });
    }).next(() => {
      const o = [], a = r.getReverseIterator();
      for (; a.hasNext(); ) {
        const l = a.getNext(), h = l.key, c = l.value, p = L0();
        c.forEach((f) => {
          if (!s.has(f)) {
            const u = H0(e.get(f), i.get(f));
            u !== null && p.set(f, u), s = s.add(f);
          }
        }), o.push(this.documentOverlayCache.saveOverlays(t, h, p));
      }
      return L.waitFor(o);
    }).next(() => i);
  }
  /**
   * Recalculates overlays by reading the documents from remote document cache
   * first, and saves them after they are calculated.
   */
  recalculateAndSaveOverlaysForDocumentKeys(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((i) => this.recalculateAndSaveOverlays(t, i));
  }
  /**
   * Performs a query against the local view of all documents.
   *
   * @param transaction - The persistence transaction.
   * @param query - The query to match documents against.
   * @param offset - Read time and key to start scanning by (exclusive).
   * @param context - A optional tracker to keep a record of important details
   *   during database local query execution.
   */
  getDocumentsMatchingQuery(t, e, i, r) {
    return function(o) {
      return Z.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t, e.path) : V0(e) ? this.getDocumentsMatchingCollectionGroupQuery(t, e, i, r) : this.getDocumentsMatchingCollectionQuery(t, e, i, r);
  }
  /**
   * Given a collection group, returns the next documents that follow the provided offset, along
   * with an updated batch ID.
   *
   * <p>The documents returned by this method are ordered by remote version from the provided
   * offset. If there are no more remote documents after the provided offset, documents with
   * mutations in order of batch id from the offset are returned. Since all documents in a batch are
   * returned together, the total number of documents returned can exceed {@code count}.
   *
   * @param transaction
   * @param collectionGroup The collection group for the documents.
   * @param offset The offset to index into.
   * @param count The number of documents to return
   * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.
   */
  getNextDocuments(t, e, i, r) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t, e, i, r).next((s) => {
      const o = r - s.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, e, i.largestBatchId, r - s.size) : L.resolve(Fi());
      let a = -1, l = s;
      return o.next((h) => L.forEach(h, (c, p) => (a < p.largestBatchId && (a = p.largestBatchId), s.get(c) ? L.resolve() : this.remoteDocumentCache.getEntry(t, c).next((f) => {
        l = l.insert(c, f);
      }))).next(() => this.populateOverlays(t, h, s)).next(() => this.computeViews(t, l, h, at())).next((c) => ({
        batchId: a,
        changes: F0(c)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t, e) {
    return this.getDocument(t, new Z(e)).next((i) => {
      let r = Ms();
      return i.isFoundDocument() && (r = r.insert(i.key, i)), r;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t, e, i, r) {
    const s = e.collectionGroup;
    let o = Ms();
    return this.indexManager.getCollectionParents(t, s).next((a) => L.forEach(a, (l) => {
      const h = function(p, f) {
        return new ts(
          f,
          /*collectionGroup=*/
          null,
          p.explicitOrderBy.slice(),
          p.filters.slice(),
          p.limit,
          p.limitType,
          p.startAt,
          p.endAt
        );
      }(e, l.child(s));
      return this.getDocumentsMatchingCollectionQuery(t, h, i, r).next((c) => {
        c.forEach((p, f) => {
          o = o.insert(p, f);
        });
      });
    }).next(() => o));
  }
  getDocumentsMatchingCollectionQuery(t, e, i, r) {
    let s;
    return this.documentOverlayCache.getOverlaysForCollection(t, e.path, i.largestBatchId).next((o) => (s = o, this.remoteDocumentCache.getDocumentsMatchingQuery(t, e, i, s, r))).next((o) => {
      s.forEach((l, h) => {
        const c = h.getKey();
        o.get(c) === null && (o = o.insert(c, ye.newInvalidDocument(c)));
      });
      let a = Ms();
      return o.forEach((l, h) => {
        const c = s.get(l);
        c !== void 0 && Hs(c.mutation, h, un.empty(), Zt.now()), // Finally, insert the documents that still match the query
        pl(e, h) && (a = a.insert(l, h));
      }), a;
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _P {
  constructor(t) {
    this.serializer = t, this.Tr = /* @__PURE__ */ new Map(), this.Ir = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t, e) {
    return L.resolve(this.Tr.get(e));
  }
  saveBundleMetadata(t, e) {
    return this.Tr.set(
      e.id,
      /** Decodes a BundleMetadata proto into a BundleMetadata object. */
      function(r) {
        return {
          id: r.id,
          version: r.version,
          createTime: An(r.createTime)
        };
      }(e)
    ), L.resolve();
  }
  getNamedQuery(t, e) {
    return L.resolve(this.Ir.get(e));
  }
  saveNamedQuery(t, e) {
    return this.Ir.set(e.name, function(r) {
      return {
        name: r.name,
        query: lP(r.bundledQuery),
        readTime: An(r.readTime)
      };
    }(e)), L.resolve();
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vP {
  constructor() {
    this.overlays = new Ot(Z.comparator), this.Er = /* @__PURE__ */ new Map();
  }
  getOverlay(t, e) {
    return L.resolve(this.overlays.get(e));
  }
  getOverlays(t, e) {
    const i = Fi();
    return L.forEach(e, (r) => this.getOverlay(t, r).next((s) => {
      s !== null && i.set(r, s);
    })).next(() => i);
  }
  saveOverlays(t, e, i) {
    return i.forEach((r, s) => {
      this.Tt(t, e, s);
    }), L.resolve();
  }
  removeOverlaysForBatchId(t, e, i) {
    const r = this.Er.get(i);
    return r !== void 0 && (r.forEach((s) => this.overlays = this.overlays.remove(s)), this.Er.delete(i)), L.resolve();
  }
  getOverlaysForCollection(t, e, i) {
    const r = Fi(), s = e.length + 1, o = new Z(e.child("")), a = this.overlays.getIteratorFrom(o);
    for (; a.hasNext(); ) {
      const l = a.getNext().value, h = l.getKey();
      if (!e.isPrefixOf(h.path)) break;
      h.path.length === s && l.largestBatchId > i && r.set(l.getKey(), l);
    }
    return L.resolve(r);
  }
  getOverlaysForCollectionGroup(t, e, i, r) {
    let s = new Ot((h, c) => h - c);
    const o = this.overlays.getIterator();
    for (; o.hasNext(); ) {
      const h = o.getNext().value;
      if (h.getKey().getCollectionGroup() === e && h.largestBatchId > i) {
        let c = s.get(h.largestBatchId);
        c === null && (c = Fi(), s = s.insert(h.largestBatchId, c)), c.set(h.getKey(), h);
      }
    }
    const a = Fi(), l = s.getIterator();
    for (; l.hasNext() && (l.getNext().value.forEach((h, c) => a.set(h, c)), !(a.size() >= r)); )
      ;
    return L.resolve(a);
  }
  Tt(t, e, i) {
    const r = this.overlays.get(i.key);
    if (r !== null) {
      const o = this.Er.get(r.largestBatchId).delete(i.key);
      this.Er.set(r.largestBatchId, o);
    }
    this.overlays = this.overlays.insert(i.key, new LC(e, i));
    let s = this.Er.get(e);
    s === void 0 && (s = at(), this.Er.set(e, s)), this.Er.set(e, s.add(i.key));
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xP {
  constructor() {
    this.sessionToken = de.EMPTY_BYTE_STRING;
  }
  getSessionToken(t) {
    return L.resolve(this.sessionToken);
  }
  setSessionToken(t, e) {
    return this.sessionToken = e, L.resolve();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Du {
  constructor() {
    this.dr = new $t(ie.Ar), // A set of outstanding references to a document sorted by target id.
    this.Rr = new $t(ie.Vr);
  }
  /** Returns true if the reference set contains no references. */
  isEmpty() {
    return this.dr.isEmpty();
  }
  /** Adds a reference to the given document key for the given ID. */
  addReference(t, e) {
    const i = new ie(t, e);
    this.dr = this.dr.add(i), this.Rr = this.Rr.add(i);
  }
  /** Add references to the given document keys for the given ID. */
  mr(t, e) {
    t.forEach((i) => this.addReference(i, e));
  }
  /**
   * Removes a reference to the given document key for the given
   * ID.
   */
  removeReference(t, e) {
    this.gr(new ie(t, e));
  }
  pr(t, e) {
    t.forEach((i) => this.removeReference(i, e));
  }
  /**
   * Clears all references with a given ID. Calls removeRef() for each key
   * removed.
   */
  yr(t) {
    const e = new Z(new Tt([])), i = new ie(e, t), r = new ie(e, t + 1), s = [];
    return this.Rr.forEachInRange([i, r], (o) => {
      this.gr(o), s.push(o.key);
    }), s;
  }
  wr() {
    this.dr.forEach((t) => this.gr(t));
  }
  gr(t) {
    this.dr = this.dr.delete(t), this.Rr = this.Rr.delete(t);
  }
  Sr(t) {
    const e = new Z(new Tt([])), i = new ie(e, t), r = new ie(e, t + 1);
    let s = at();
    return this.Rr.forEachInRange([i, r], (o) => {
      s = s.add(o.key);
    }), s;
  }
  containsKey(t) {
    const e = new ie(t, 0), i = this.dr.firstAfterOrEqual(e);
    return i !== null && t.isEqual(i.key);
  }
}
class ie {
  constructor(t, e) {
    this.key = t, this.br = e;
  }
  /** Compare by key then by ID */
  static Ar(t, e) {
    return Z.comparator(t.key, e.key) || lt(t.br, e.br);
  }
  /** Compare by ID then by key */
  static Vr(t, e) {
    return lt(t.br, e.br) || Z.comparator(t.key, e.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bP {
  constructor(t, e) {
    this.indexManager = t, this.referenceDelegate = e, /**
     * The set of all mutations that have been sent but not yet been applied to
     * the backend.
     */
    this.mutationQueue = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
    this.Dr = 1, /** An ordered mapping between documents and the mutations batch IDs. */
    this.vr = new $t(ie.Ar);
  }
  checkEmpty(t) {
    return L.resolve(this.mutationQueue.length === 0);
  }
  addMutationBatch(t, e, i, r) {
    const s = this.Dr;
    this.Dr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const o = new FC(s, e, i, r);
    this.mutationQueue.push(o);
    for (const a of r) this.vr = this.vr.add(new ie(a.key, s)), this.indexManager.addToCollectionParentIndex(t, a.key.path.popLast());
    return L.resolve(o);
  }
  lookupMutationBatch(t, e) {
    return L.resolve(this.Cr(e));
  }
  getNextMutationBatchAfterBatchId(t, e) {
    const i = e + 1, r = this.Fr(i), s = r < 0 ? 0 : r;
    return L.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return L.resolve(this.mutationQueue.length === 0 ? -1 : this.Dr - 1);
  }
  getAllMutationBatches(t) {
    return L.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t, e) {
    const i = new ie(e, 0), r = new ie(e, Number.POSITIVE_INFINITY), s = [];
    return this.vr.forEachInRange([i, r], (o) => {
      const a = this.Cr(o.br);
      s.push(a);
    }), L.resolve(s);
  }
  getAllMutationBatchesAffectingDocumentKeys(t, e) {
    let i = new $t(lt);
    return e.forEach((r) => {
      const s = new ie(r, 0), o = new ie(r, Number.POSITIVE_INFINITY);
      this.vr.forEachInRange([s, o], (a) => {
        i = i.add(a.br);
      });
    }), L.resolve(this.Mr(i));
  }
  getAllMutationBatchesAffectingQuery(t, e) {
    const i = e.path, r = i.length + 1;
    let s = i;
    Z.isDocumentKey(s) || (s = s.child(""));
    const o = new ie(new Z(s), 0);
    let a = new $t(lt);
    return this.vr.forEachWhile((l) => {
      const h = l.key.path;
      return !!i.isPrefixOf(h) && // Rows with document keys more than one segment longer than the query
      // path can't be matches. For example, a query on 'rooms' can't match
      // the document /rooms/abc/messages/xyx.
      // TODO(mcg): we'll need a different scanner when we implement
      // ancestor queries.
      (h.length === r && (a = a.add(l.br)), !0);
    }, o), L.resolve(this.Mr(a));
  }
  Mr(t) {
    const e = [];
    return t.forEach((i) => {
      const r = this.Cr(i);
      r !== null && e.push(r);
    }), e;
  }
  removeMutationBatch(t, e) {
    yt(this.Or(e.batchId, "removed") === 0), this.mutationQueue.shift();
    let i = this.vr;
    return L.forEach(e.mutations, (r) => {
      const s = new ie(r.key, e.batchId);
      return i = i.delete(s), this.referenceDelegate.markPotentiallyOrphaned(t, r.key);
    }).next(() => {
      this.vr = i;
    });
  }
  Ln(t) {
  }
  containsKey(t, e) {
    const i = new ie(e, 0), r = this.vr.firstAfterOrEqual(i);
    return L.resolve(e.isEqual(r && r.key));
  }
  performConsistencyCheck(t) {
    return this.mutationQueue.length, L.resolve();
  }
  /**
   * Finds the index of the given batchId in the mutation queue and asserts that
   * the resulting index is within the bounds of the queue.
   *
   * @param batchId - The batchId to search for
   * @param action - A description of what the caller is doing, phrased in passive
   * form (e.g. "acknowledged" in a routine that acknowledges batches).
   */
  Or(t, e) {
    return this.Fr(t);
  }
  /**
   * Finds the index of the given batchId in the mutation queue. This operation
   * is O(1).
   *
   * @returns The computed index of the batch with the given batchId, based on
   * the state of the queue. Note this index can be negative if the requested
   * batchId has already been removed from the queue or past the end of the
   * queue if the batchId is larger than the last added batch.
   */
  Fr(t) {
    return this.mutationQueue.length === 0 ? 0 : t - this.mutationQueue[0].batchId;
  }
  /**
   * A version of lookupMutationBatch that doesn't return a promise, this makes
   * other functions that uses this code easier to read and more efficient.
   */
  Cr(t) {
    const e = this.Fr(t);
    return e < 0 || e >= this.mutationQueue.length ? null : this.mutationQueue[e];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wP {
  /**
   * @param sizer - Used to assess the size of a document. For eager GC, this is
   * expected to just return 0 to avoid unnecessarily doing the work of
   * calculating the size.
   */
  constructor(t) {
    this.Nr = t, /** Underlying cache of documents and their read times. */
    this.docs = function() {
      return new Ot(Z.comparator);
    }(), /** Size of all cached documents. */
    this.size = 0;
  }
  setIndexManager(t) {
    this.indexManager = t;
  }
  /**
   * Adds the supplied entry to the cache and updates the cache size as appropriate.
   *
   * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  addEntry(t, e) {
    const i = e.key, r = this.docs.get(i), s = r ? r.size : 0, o = this.Nr(e);
    return this.docs = this.docs.insert(i, {
      document: e.mutableCopy(),
      size: o
    }), this.size += o - s, this.indexManager.addToCollectionParentIndex(t, i.path.popLast());
  }
  /**
   * Removes the specified entry from the cache and updates the cache size as appropriate.
   *
   * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  removeEntry(t) {
    const e = this.docs.get(t);
    e && (this.docs = this.docs.remove(t), this.size -= e.size);
  }
  getEntry(t, e) {
    const i = this.docs.get(e);
    return L.resolve(i ? i.document.mutableCopy() : ye.newInvalidDocument(e));
  }
  getEntries(t, e) {
    let i = Gn();
    return e.forEach((r) => {
      const s = this.docs.get(r);
      i = i.insert(r, s ? s.document.mutableCopy() : ye.newInvalidDocument(r));
    }), L.resolve(i);
  }
  getDocumentsMatchingQuery(t, e, i, r) {
    let s = Gn();
    const o = e.path, a = new Z(o.child("")), l = this.docs.getIteratorFrom(a);
    for (; l.hasNext(); ) {
      const { key: h, value: { document: c } } = l.getNext();
      if (!o.isPrefixOf(h.path)) break;
      h.path.length > o.length + 1 || $E(ZE(c), i) <= 0 || (r.has(c.key) || pl(e, c)) && (s = s.insert(c.key, c.mutableCopy()));
    }
    return L.resolve(s);
  }
  getAllFromCollectionGroup(t, e, i, r) {
    et();
  }
  Lr(t, e) {
    return L.forEach(this.docs, (i) => e(i));
  }
  newChangeBuffer(t) {
    return new AP(this);
  }
  getSize(t) {
    return L.resolve(this.size);
  }
}
class AP extends mP {
  constructor(t) {
    super(), this.hr = t;
  }
  applyChanges(t) {
    const e = [];
    return this.changes.forEach((i, r) => {
      r.isValidDocument() ? e.push(this.hr.addEntry(t, r)) : this.hr.removeEntry(i);
    }), L.waitFor(e);
  }
  getFromCache(t, e) {
    return this.hr.getEntry(t, e);
  }
  getAllFromCache(t, e) {
    return this.hr.getEntries(t, e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TP {
  constructor(t) {
    this.persistence = t, /**
     * Maps a target to the data about that target
     */
    this.Br = new Ji((e) => Pu(e), Iu), /** The last received snapshot version. */
    this.lastRemoteSnapshotVersion = nt.min(), /** The highest numbered target ID encountered. */
    this.highestTargetId = 0, /** The highest sequence number encountered. */
    this.kr = 0, /**
     * A ordered bidirectional mapping between documents and the remote target
     * IDs.
     */
    this.qr = new Du(), this.targetCount = 0, this.Qr = zr.qn();
  }
  forEachTarget(t, e) {
    return this.Br.forEach((i, r) => e(r)), L.resolve();
  }
  getLastRemoteSnapshotVersion(t) {
    return L.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t) {
    return L.resolve(this.kr);
  }
  allocateTargetId(t) {
    return this.highestTargetId = this.Qr.next(), L.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t, e, i) {
    return i && (this.lastRemoteSnapshotVersion = i), e > this.kr && (this.kr = e), L.resolve();
  }
  Un(t) {
    this.Br.set(t.target, t);
    const e = t.targetId;
    e > this.highestTargetId && (this.Qr = new zr(e), this.highestTargetId = e), t.sequenceNumber > this.kr && (this.kr = t.sequenceNumber);
  }
  addTargetData(t, e) {
    return this.Un(e), this.targetCount += 1, L.resolve();
  }
  updateTargetData(t, e) {
    return this.Un(e), L.resolve();
  }
  removeTargetData(t, e) {
    return this.Br.delete(e.target), this.qr.yr(e.targetId), this.targetCount -= 1, L.resolve();
  }
  removeTargets(t, e, i) {
    let r = 0;
    const s = [];
    return this.Br.forEach((o, a) => {
      a.sequenceNumber <= e && i.get(a.targetId) === null && (this.Br.delete(o), s.push(this.removeMatchingKeysForTargetId(t, a.targetId)), r++);
    }), L.waitFor(s).next(() => r);
  }
  getTargetCount(t) {
    return L.resolve(this.targetCount);
  }
  getTargetData(t, e) {
    const i = this.Br.get(e) || null;
    return L.resolve(i);
  }
  addMatchingKeys(t, e, i) {
    return this.qr.mr(e, i), L.resolve();
  }
  removeMatchingKeys(t, e, i) {
    this.qr.pr(e, i);
    const r = this.persistence.referenceDelegate, s = [];
    return r && e.forEach((o) => {
      s.push(r.markPotentiallyOrphaned(t, o));
    }), L.waitFor(s);
  }
  removeMatchingKeysForTargetId(t, e) {
    return this.qr.yr(e), L.resolve();
  }
  getMatchingKeysForTargetId(t, e) {
    const i = this.qr.Sr(e);
    return L.resolve(i);
  }
  containsKey(t, e) {
    return L.resolve(this.qr.containsKey(e));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class i_ {
  /**
   * The constructor accepts a factory for creating a reference delegate. This
   * allows both the delegate and this instance to have strong references to
   * each other without having nullable fields that would then need to be
   * checked or asserted on every access.
   */
  constructor(t, e) {
    this.Kr = {}, this.overlays = {}, this.$r = new hl(0), this.Ur = !1, this.Ur = !0, this.Wr = new xP(), this.referenceDelegate = t(this), this.Gr = new TP(this), this.indexManager = new hP(), this.remoteDocumentCache = function(r) {
      return new wP(r);
    }((i) => this.referenceDelegate.zr(i)), this.serializer = new aP(e), this.jr = new _P(this.serializer);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ur = !1, Promise.resolve();
  }
  get started() {
    return this.Ur;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t) {
    let e = this.overlays[t.toKey()];
    return e || (e = new vP(), this.overlays[t.toKey()] = e), e;
  }
  getMutationQueue(t, e) {
    let i = this.Kr[t.toKey()];
    return i || (i = new bP(e, this.referenceDelegate), this.Kr[t.toKey()] = i), i;
  }
  getGlobalsCache() {
    return this.Wr;
  }
  getTargetCache() {
    return this.Gr;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.jr;
  }
  runTransaction(t, e, i) {
    q("MemoryPersistence", "Starting transaction:", t);
    const r = new SP(this.$r.next());
    return this.referenceDelegate.Hr(), i(r).next((s) => this.referenceDelegate.Jr(r).next(() => s)).toPromise().then((s) => (r.raiseOnCommittedEvent(), s));
  }
  Yr(t, e) {
    return L.or(Object.values(this.Kr).map((i) => () => i.containsKey(t, e)));
  }
}
class SP extends eC {
  constructor(t) {
    super(), this.currentSequenceNumber = t;
  }
}
class Bu {
  constructor(t) {
    this.persistence = t, /** Tracks all documents that are active in Query views. */
    this.Zr = new Du(), /** The list of documents that are potentially GCed after each transaction. */
    this.Xr = null;
  }
  static ei(t) {
    return new Bu(t);
  }
  get ti() {
    if (this.Xr) return this.Xr;
    throw et();
  }
  addReference(t, e, i) {
    return this.Zr.addReference(i, e), this.ti.delete(i.toString()), L.resolve();
  }
  removeReference(t, e, i) {
    return this.Zr.removeReference(i, e), this.ti.add(i.toString()), L.resolve();
  }
  markPotentiallyOrphaned(t, e) {
    return this.ti.add(e.toString()), L.resolve();
  }
  removeTarget(t, e) {
    this.Zr.yr(e.targetId).forEach((r) => this.ti.add(r.toString()));
    const i = this.persistence.getTargetCache();
    return i.getMatchingKeysForTargetId(t, e.targetId).next((r) => {
      r.forEach((s) => this.ti.add(s.toString()));
    }).next(() => i.removeTargetData(t, e));
  }
  Hr() {
    this.Xr = /* @__PURE__ */ new Set();
  }
  Jr(t) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return L.forEach(this.ti, (i) => {
      const r = Z.fromPath(i);
      return this.ni(t, r).next((s) => {
        s || e.removeEntry(r, nt.min());
      });
    }).next(() => (this.Xr = null, e.apply(t)));
  }
  updateLimboDocument(t, e) {
    return this.ni(t, e).next((i) => {
      i ? this.ti.delete(e.toString()) : this.ti.add(e.toString());
    });
  }
  zr(t) {
    return 0;
  }
  ni(t, e) {
    return L.or([() => L.resolve(this.Zr.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t, e), () => this.persistence.Yr(t, e)]);
  }
}
class ja {
  constructor(t, e) {
    this.persistence = t, this.ri = new Ji((i) => rC(i.path), (i, r) => i.isEqual(r)), this.garbageCollector = fP(this, e);
  }
  static ei(t, e) {
    return new ja(t, e);
  }
  // No-ops, present so memory persistence doesn't have to care which delegate
  // it has.
  Hr() {
  }
  Jr(t) {
    return L.resolve();
  }
  forEachTarget(t, e) {
    return this.persistence.getTargetCache().forEachTarget(t, e);
  }
  Xn(t) {
    const e = this.nr(t);
    return this.persistence.getTargetCache().getTargetCount(t).next((i) => e.next((r) => i + r));
  }
  nr(t) {
    let e = 0;
    return this.er(t, (i) => {
      e++;
    }).next(() => e);
  }
  er(t, e) {
    return L.forEach(this.ri, (i, r) => this.ir(t, i, r).next((s) => s ? L.resolve() : e(r)));
  }
  removeTargets(t, e, i) {
    return this.persistence.getTargetCache().removeTargets(t, e, i);
  }
  removeOrphanedDocuments(t, e) {
    let i = 0;
    const r = this.persistence.getRemoteDocumentCache(), s = r.newChangeBuffer();
    return r.Lr(t, (o) => this.ir(t, o, e).next((a) => {
      a || (i++, s.removeEntry(o, nt.min()));
    })).next(() => s.apply(t)).next(() => i);
  }
  markPotentiallyOrphaned(t, e) {
    return this.ri.set(e, t.currentSequenceNumber), L.resolve();
  }
  removeTarget(t, e) {
    const i = e.withSequenceNumber(t.currentSequenceNumber);
    return this.persistence.getTargetCache().updateTargetData(t, i);
  }
  addReference(t, e, i) {
    return this.ri.set(i, t.currentSequenceNumber), L.resolve();
  }
  removeReference(t, e, i) {
    return this.ri.set(i, t.currentSequenceNumber), L.resolve();
  }
  updateLimboDocument(t, e) {
    return this.ri.set(e, t.currentSequenceNumber), L.resolve();
  }
  zr(t) {
    let e = t.key.toString().length;
    return t.isFoundDocument() && (e += da(t.data.value)), e;
  }
  ir(t, e, i) {
    return L.or([() => this.persistence.Yr(t, e), () => this.persistence.getTargetCache().containsKey(t, e), () => {
      const r = this.ri.get(e);
      return L.resolve(r !== void 0 && r > i);
    }]);
  }
  getCacheSize(t) {
    return this.persistence.getRemoteDocumentCache().getSize(t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ou {
  constructor(t, e, i, r) {
    this.targetId = t, this.fromCache = e, this.Wi = i, this.Gi = r;
  }
  static zi(t, e) {
    let i = at(), r = at();
    for (const s of e.docChanges) switch (s.type) {
      case 0:
        i = i.add(s.doc.key);
        break;
      case 1:
        r = r.add(s.doc.key);
    }
    return new Ou(t, e.fromCache, i, r);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EP {
  constructor() {
    this._documentReadCount = 0;
  }
  get documentReadCount() {
    return this._documentReadCount;
  }
  incrementDocumentReadCount(t) {
    this._documentReadCount += t;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CP {
  constructor() {
    this.ji = !1, this.Hi = !1, /**
     * SDK only decides whether it should create index when collection size is
     * larger than this.
     */
    this.Ji = 100, this.Yi = /**
    * This cost represents the evaluation result of
    * (([index, docKey] + [docKey, docContent]) per document in the result set)
    * / ([docKey, docContent] per documents in full collection scan) coming from
    * experiment [enter PR experiment URL here].
    */
    function() {
      return TS() ? 8 : nC(wS()) > 0 ? 6 : 4;
    }();
  }
  /** Sets the document view to query against. */
  initialize(t, e) {
    this.Zi = t, this.indexManager = e, this.ji = !0;
  }
  /** Returns all local documents matching the specified query. */
  getDocumentsMatchingQuery(t, e, i, r) {
    const s = {
      result: null
    };
    return this.Xi(t, e).next((o) => {
      s.result = o;
    }).next(() => {
      if (!s.result) return this.es(t, e, r, i).next((o) => {
        s.result = o;
      });
    }).next(() => {
      if (s.result) return;
      const o = new EP();
      return this.ts(t, e, o).next((a) => {
        if (s.result = a, this.Hi) return this.ns(t, e, o, a.size);
      });
    }).next(() => s.result);
  }
  ns(t, e, i, r) {
    return i.documentReadCount < this.Ji ? (ur() <= ut.DEBUG && q("QueryEngine", "SDK will not create cache indexes for query:", dr(e), "since it only creates cache indexes for collection contains", "more than or equal to", this.Ji, "documents"), L.resolve()) : (ur() <= ut.DEBUG && q("QueryEngine", "Query:", dr(e), "scans", i.documentReadCount, "local documents and returns", r, "documents as results."), i.documentReadCount > this.Yi * r ? (ur() <= ut.DEBUG && q("QueryEngine", "The SDK decides to create cache indexes for query:", dr(e), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(t, wn(e))) : L.resolve());
  }
  /**
   * Performs an indexed query that evaluates the query based on a collection's
   * persisted index values. Returns `null` if an index is not available.
   */
  Xi(t, e) {
    if (qf(e))
      return L.resolve(null);
    let i = wn(e);
    return this.indexManager.getIndexType(t, i).next((r) => r === 0 ? null : (e.limit !== null && r === 1 && // We cannot apply a limit for targets that are served using a partial
    // index. If a partial index will be used to serve the target, the
    // query may return a superset of documents that match the target
    // (e.g. if the index doesn't include all the target's filters), or
    // may return the correct set of documents in the wrong order (e.g. if
    // the index doesn't include a segment for one of the orderBys).
    // Therefore, a limit should not be applied in such cases.
    (e = La(
      e,
      null,
      "F"
      /* LimitType.First */
    ), i = wn(e)), this.indexManager.getDocumentsMatchingTarget(t, i).next((s) => {
      const o = at(...s);
      return this.Zi.getDocuments(t, o).next((a) => this.indexManager.getMinOffset(t, i).next((l) => {
        const h = this.rs(e, a);
        return this.ss(e, h, o, l.readTime) ? this.Xi(t, La(
          e,
          null,
          "F"
          /* LimitType.First */
        )) : this.os(t, h, e, l);
      }));
    })));
  }
  /**
   * Performs a query based on the target's persisted query mapping. Returns
   * `null` if the mapping is not available or cannot be used.
   */
  es(t, e, i, r) {
    return qf(e) || r.isEqual(nt.min()) ? L.resolve(null) : this.Zi.getDocuments(t, i).next((s) => {
      const o = this.rs(e, s);
      return this.ss(e, o, i, r) ? L.resolve(null) : (ur() <= ut.DEBUG && q("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), dr(e)), this.os(t, o, e, JE(r, -1)).next((a) => a));
    });
  }
  /** Applies the query filter and sorting to the provided documents.  */
  rs(t, e) {
    let i = new $t(B0(t));
    return e.forEach((r, s) => {
      pl(t, s) && (i = i.add(s));
    }), i;
  }
  /**
   * Determines if a limit query needs to be refilled from cache, making it
   * ineligible for index-free execution.
   *
   * @param query - The query.
   * @param sortedPreviousResults - The documents that matched the query when it
   * was last synchronized, sorted by the query's comparator.
   * @param remoteKeys - The document keys that matched the query at the last
   * snapshot.
   * @param limboFreeSnapshotVersion - The version of the snapshot when the
   * query was last synchronized.
   */
  ss(t, e, i, r) {
    if (t.limit === null)
      return !1;
    if (i.size !== e.size)
      return !0;
    const s = t.limitType === "F" ? e.last() : e.first();
    return !!s && (s.hasPendingWrites || s.version.compareTo(r) > 0);
  }
  ts(t, e, i) {
    return ur() <= ut.DEBUG && q("QueryEngine", "Using full collection scan to execute query:", dr(e)), this.Zi.getDocumentsMatchingQuery(t, e, hi.min(), i);
  }
  /**
   * Combines the results from an indexed execution with the remaining documents
   * that have not yet been indexed.
   */
  os(t, e, i, r) {
    return this.Zi.getDocumentsMatchingQuery(t, i, r).next((s) => (
      // Merge with existing results
      (e.forEach((o) => {
        s = s.insert(o.key, o);
      }), s)
    ));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PP {
  constructor(t, e, i, r) {
    this.persistence = t, this._s = e, this.serializer = r, /**
     * Maps a targetID to data about its target.
     *
     * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
     * of `applyRemoteEvent()` idempotent.
     */
    this.us = new Ot(lt), /** Maps a target to its targetID. */
    // TODO(wuandy): Evaluate if TargetId can be part of Target.
    this.cs = new Ji((s) => Pu(s), Iu), /**
     * A per collection group index of the last read time processed by
     * `getNewDocumentChanges()`.
     *
     * PORTING NOTE: This is only used for multi-tab synchronization.
     */
    this.ls = /* @__PURE__ */ new Map(), this.hs = t.getRemoteDocumentCache(), this.Gr = t.getTargetCache(), this.jr = t.getBundleCache(), this.Ps(i);
  }
  Ps(t) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t), this.indexManager = this.persistence.getIndexManager(t), this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager), this.localDocuments = new yP(this.hs, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.hs.setIndexManager(this.indexManager), this._s.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t.collect(e, this.us));
  }
}
function IP(n, t, e, i) {
  return new PP(n, t, e, i);
}
async function r_(n, t) {
  const e = it(n);
  return await e.persistence.runTransaction("Handle user change", "readonly", (i) => {
    let r;
    return e.mutationQueue.getAllMutationBatches(i).next((s) => (r = s, e.Ps(t), e.mutationQueue.getAllMutationBatches(i))).next((s) => {
      const o = [], a = [];
      let l = at();
      for (const h of r) {
        o.push(h.batchId);
        for (const c of h.mutations) l = l.add(c.key);
      }
      for (const h of s) {
        a.push(h.batchId);
        for (const c of h.mutations) l = l.add(c.key);
      }
      return e.localDocuments.getDocuments(i, l).next((h) => ({
        Ts: h,
        removedBatchIds: o,
        addedBatchIds: a
      }));
    });
  });
}
function RP(n, t) {
  const e = it(n);
  return e.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (i) => {
    const r = t.batch.keys(), s = e.hs.newChangeBuffer({
      trackRemovals: !0
    });
    return function(a, l, h, c) {
      const p = h.batch, f = p.keys();
      let u = L.resolve();
      return f.forEach((m) => {
        u = u.next(() => c.getEntry(l, m)).next((g) => {
          const y = h.docVersions.get(m);
          yt(y !== null), g.version.compareTo(y) < 0 && (p.applyToRemoteDocument(g, h), g.isValidDocument() && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          (g.setReadTime(h.commitVersion), c.addEntry(g)));
        });
      }), u.next(() => a.mutationQueue.removeMutationBatch(l, p));
    }(e, i, t, s).next(() => s.apply(i)).next(() => e.mutationQueue.performConsistencyCheck(i)).next(() => e.documentOverlayCache.removeOverlaysForBatchId(i, r, t.batch.batchId)).next(() => e.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(i, function(a) {
      let l = at();
      for (let h = 0; h < a.mutationResults.length; ++h)
        a.mutationResults[h].transformResults.length > 0 && (l = l.add(a.batch.mutations[h].key));
      return l;
    }(t))).next(() => e.localDocuments.getDocuments(i, r));
  });
}
function s_(n) {
  const t = it(n);
  return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (e) => t.Gr.getLastRemoteSnapshotVersion(e));
}
function kP(n, t) {
  const e = it(n), i = t.snapshotVersion;
  let r = e.us;
  return e.persistence.runTransaction("Apply remote event", "readwrite-primary", (s) => {
    const o = e.hs.newChangeBuffer({
      trackRemovals: !0
    });
    r = e.us;
    const a = [];
    t.targetChanges.forEach((c, p) => {
      const f = r.get(p);
      if (!f) return;
      a.push(e.Gr.removeMatchingKeys(s, c.removedDocuments, p).next(() => e.Gr.addMatchingKeys(s, c.addedDocuments, p)));
      let u = f.withSequenceNumber(s.currentSequenceNumber);
      t.targetMismatches.get(p) !== null ? u = u.withResumeToken(de.EMPTY_BYTE_STRING, nt.min()).withLastLimboFreeSnapshotVersion(nt.min()) : c.resumeToken.approximateByteSize() > 0 && (u = u.withResumeToken(c.resumeToken, i)), r = r.insert(p, u), // Update the target data if there are target changes (or if
      // sufficient time has passed since the last update).
      /**
      * Returns true if the newTargetData should be persisted during an update of
      * an active target. TargetData should always be persisted when a target is
      * being released and should not call this function.
      *
      * While the target is active, TargetData updates can be omitted when nothing
      * about the target has changed except metadata like the resume token or
      * snapshot version. Occasionally it's worth the extra write to prevent these
      * values from getting too stale after a crash, but this doesn't have to be
      * too frequent.
      */
      function(g, y, b) {
        return g.resumeToken.approximateByteSize() === 0 || y.snapshotVersion.toMicroseconds() - g.snapshotVersion.toMicroseconds() >= 3e8 ? !0 : b.addedDocuments.size + b.modifiedDocuments.size + b.removedDocuments.size > 0;
      }(f, u, c) && a.push(e.Gr.updateTargetData(s, u));
    });
    let l = Gn(), h = at();
    if (t.documentUpdates.forEach((c) => {
      t.resolvedLimboDocuments.has(c) && a.push(e.persistence.referenceDelegate.updateLimboDocument(s, c));
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all
    // the remote documents in advance in a single call.
    a.push(MP(s, o, t.documentUpdates).next((c) => {
      l = c.Is, h = c.Es;
    })), !i.isEqual(nt.min())) {
      const c = e.Gr.getLastRemoteSnapshotVersion(s).next((p) => e.Gr.setTargetsMetadata(s, s.currentSequenceNumber, i));
      a.push(c);
    }
    return L.waitFor(a).next(() => o.apply(s)).next(() => e.localDocuments.getLocalViewOfDocuments(s, l, h)).next(() => l);
  }).then((s) => (e.us = r, s));
}
function MP(n, t, e) {
  let i = at(), r = at();
  return e.forEach((s) => i = i.add(s)), t.getEntries(n, i).next((s) => {
    let o = Gn();
    return e.forEach((a, l) => {
      const h = s.get(a);
      l.isFoundDocument() !== h.isFoundDocument() && (r = r.add(a)), // Note: The order of the steps below is important, since we want
      // to ensure that rejected limbo resolutions (which fabricate
      // NoDocuments with SnapshotVersion.min()) never add documents to
      // cache.
      l.isNoDocument() && l.version.isEqual(nt.min()) ? (
        // NoDocuments with SnapshotVersion.min() are used in manufactured
        // events. We remove these documents from cache since we lost
        // access.
        (t.removeEntry(a, l.readTime), o = o.insert(a, l))
      ) : !h.isValidDocument() || l.version.compareTo(h.version) > 0 || l.version.compareTo(h.version) === 0 && h.hasPendingWrites ? (t.addEntry(l), o = o.insert(a, l)) : q("LocalStore", "Ignoring outdated watch update for ", a, ". Current version:", h.version, " Watch version:", l.version);
    }), {
      Is: o,
      Es: r
    };
  });
}
function VP(n, t) {
  const e = it(n);
  return e.persistence.runTransaction("Get next mutation batch", "readonly", (i) => (t === void 0 && (t = -1), e.mutationQueue.getNextMutationBatchAfterBatchId(i, t)));
}
function DP(n, t) {
  const e = it(n);
  return e.persistence.runTransaction("Allocate target", "readwrite", (i) => {
    let r;
    return e.Gr.getTargetData(i, t).next((s) => s ? (
      // This target has been listened to previously, so reuse the
      // previous targetID.
      // TODO(mcg): freshen last accessed date?
      (r = s, L.resolve(r))
    ) : e.Gr.allocateTargetId(i).next((o) => (r = new $n(t, o, "TargetPurposeListen", i.currentSequenceNumber), e.Gr.addTargetData(i, r).next(() => r))));
  }).then((i) => {
    const r = e.us.get(i.targetId);
    return (r === null || i.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (e.us = e.us.insert(i.targetId, i), e.cs.set(t, i.targetId)), i;
  });
}
async function Oc(n, t, e) {
  const i = it(n), r = i.us.get(t), s = e ? "readwrite" : "readwrite-primary";
  try {
    e || await i.persistence.runTransaction("Release target", s, (o) => i.persistence.referenceDelegate.removeTarget(o, r));
  } catch (o) {
    if (!$r(o)) throw o;
    q("LocalStore", `Failed to update sequence numbers for target ${t}: ${o}`);
  }
  i.us = i.us.remove(t), i.cs.delete(r.target);
}
function im(n, t, e) {
  const i = it(n);
  let r = nt.min(), s = at();
  return i.persistence.runTransaction(
    "Execute query",
    "readwrite",
    // Use readwrite instead of readonly so indexes can be created
    // Use readwrite instead of readonly so indexes can be created
    (o) => function(l, h, c) {
      const p = it(l), f = p.cs.get(c);
      return f !== void 0 ? L.resolve(p.us.get(f)) : p.Gr.getTargetData(h, c);
    }(i, o, wn(t)).next((a) => {
      if (a) return r = a.lastLimboFreeSnapshotVersion, i.Gr.getMatchingKeysForTargetId(o, a.targetId).next((l) => {
        s = l;
      });
    }).next(() => i._s.getDocumentsMatchingQuery(o, t, e ? r : nt.min(), e ? s : at())).next((a) => (BP(i, wC(t), a), {
      documents: a,
      ds: s
    }))
  );
}
function BP(n, t, e) {
  let i = n.ls.get(t) || nt.min();
  e.forEach((r, s) => {
    s.readTime.compareTo(i) > 0 && (i = s.readTime);
  }), n.ls.set(t, i);
}
class rm {
  constructor() {
    this.activeTargetIds = PC();
  }
  ps(t) {
    this.activeTargetIds = this.activeTargetIds.add(t);
  }
  ys(t) {
    this.activeTargetIds = this.activeTargetIds.delete(t);
  }
  /**
   * Converts this entry into a JSON-encoded format we can use for WebStorage.
   * Does not encode `clientId` as it is part of the key in WebStorage.
   */
  gs() {
    const t = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t);
  }
}
class OP {
  constructor() {
    this._o = new rm(), this.ao = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t) {
  }
  updateMutationState(t, e, i) {
  }
  addLocalQueryTarget(t, e = !0) {
    return e && this._o.ps(t), this.ao[t] || "not-current";
  }
  updateQueryState(t, e, i) {
    this.ao[t] = e;
  }
  removeLocalQueryTarget(t) {
    this._o.ys(t);
  }
  isLocalQueryTarget(t) {
    return this._o.activeTargetIds.has(t);
  }
  clearQueryState(t) {
    delete this.ao[t];
  }
  getAllActiveQueryTargets() {
    return this._o.activeTargetIds;
  }
  isActiveQueryTarget(t) {
    return this._o.activeTargetIds.has(t);
  }
  start() {
    return this._o = new rm(), Promise.resolve();
  }
  handleUserChange(t, e, i) {
  }
  setOnlineState(t) {
  }
  shutdown() {
  }
  writeSequenceNumber(t) {
  }
  notifyBundleLoaded(t) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FP {
  uo(t) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sm {
  constructor() {
    this.co = () => this.lo(), this.ho = () => this.Po(), this.To = [], this.Io();
  }
  uo(t) {
    this.To.push(t);
  }
  shutdown() {
    window.removeEventListener("online", this.co), window.removeEventListener("offline", this.ho);
  }
  Io() {
    window.addEventListener("online", this.co), window.addEventListener("offline", this.ho);
  }
  lo() {
    q("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t of this.To) t(
      0
      /* NetworkStatus.AVAILABLE */
    );
  }
  Po() {
    q("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t of this.To) t(
      1
      /* NetworkStatus.UNAVAILABLE */
    );
  }
  // TODO(chenbrian): Consider passing in window either into this component or
  // here for testing via FakeWindow.
  /** Checks that all used attributes of window are available. */
  static p() {
    return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let ea = null;
function Ph() {
  return ea === null ? ea = function() {
    return 268435456 + Math.round(2147483648 * Math.random());
  }() : ea++, "0x" + ea.toString(16);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LP = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NP {
  constructor(t) {
    this.Eo = t.Eo, this.Ao = t.Ao;
  }
  Ro(t) {
    this.Vo = t;
  }
  mo(t) {
    this.fo = t;
  }
  po(t) {
    this.yo = t;
  }
  onMessage(t) {
    this.wo = t;
  }
  close() {
    this.Ao();
  }
  send(t) {
    this.Eo(t);
  }
  So() {
    this.Vo();
  }
  bo() {
    this.fo();
  }
  Do(t) {
    this.yo(t);
  }
  vo(t) {
    this.wo(t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const me = "WebChannelConnection";
class UP extends /**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class {
  get Co() {
    return !1;
  }
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const i = e.ssl ? "https" : "http", r = encodeURIComponent(this.databaseId.projectId), s = encodeURIComponent(this.databaseId.database);
    this.Fo = i + "://" + e.host, this.Mo = `projects/${r}/databases/${s}`, this.xo = this.databaseId.database === "(default)" ? `project_id=${r}` : `project_id=${r}&database_id=${s}`;
  }
  Oo(e, i, r, s, o) {
    const a = Ph(), l = this.No(e, i.toUriEncodedString());
    q("RestConnection", `Sending RPC '${e}' ${a}:`, l, r);
    const h = {
      "google-cloud-resource-prefix": this.Mo,
      "x-goog-request-params": this.xo
    };
    return this.Lo(h, s, o), this.Bo(e, l, h, r).then((c) => (q("RestConnection", `Received RPC '${e}' ${a}: `, c), c), (c) => {
      throw Fr("RestConnection", `RPC '${e}' ${a} failed with error: `, c, "url: ", l, "request:", r), c;
    });
  }
  ko(e, i, r, s, o, a) {
    return this.Oo(e, i, r, s, o);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  Lo(e, i, r) {
    e["X-Goog-Api-Client"] = // SDK_VERSION is updated to different value at runtime depending on the entry point,
    // so we need to get its value when we need it in a function.
    function() {
      return "gl-js/ fire/" + Jr;
    }(), // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), i && i.headers.forEach((s, o) => e[o] = s), r && r.headers.forEach((s, o) => e[o] = s);
  }
  No(e, i) {
    const r = LP[e];
    return `${this.Fo}/v1/${i}:${r}`;
  }
  /**
   * Closes and cleans up any resources associated with the connection. This
   * implementation is a no-op because there are no resources associated
   * with the RestConnection that need to be cleaned up.
   */
  terminate() {
  }
} {
  constructor(t) {
    super(t), this.forceLongPolling = t.forceLongPolling, this.autoDetectLongPolling = t.autoDetectLongPolling, this.useFetchStreams = t.useFetchStreams, this.longPollingOptions = t.longPollingOptions;
  }
  Bo(t, e, i, r) {
    const s = Ph();
    return new Promise((o, a) => {
      const l = new g0();
      l.setWithCredentials(!0), l.listenOnce(y0.COMPLETE, () => {
        try {
          switch (l.getLastErrorCode()) {
            case ua.NO_ERROR:
              const c = l.getResponseJson();
              q(me, `XHR for RPC '${t}' ${s} received:`, JSON.stringify(c)), o(c);
              break;
            case ua.TIMEOUT:
              q(me, `RPC '${t}' ${s} timed out`), a(new Y(N.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ua.HTTP_ERROR:
              const p = l.getStatus();
              if (q(me, `RPC '${t}' ${s} failed with status:`, p, "response text:", l.getResponseText()), p > 0) {
                let f = l.getResponseJson();
                Array.isArray(f) && (f = f[0]);
                const u = f == null ? void 0 : f.error;
                if (u && u.status && u.message) {
                  const m = function(y) {
                    const b = y.toLowerCase().replace(/_/g, "-");
                    return Object.values(N).indexOf(b) >= 0 ? b : N.UNKNOWN;
                  }(u.status);
                  a(new Y(m, u.message));
                } else a(new Y(N.UNKNOWN, "Server responded with status " + l.getStatus()));
              } else
                a(new Y(N.UNAVAILABLE, "Connection failed."));
              break;
            default:
              et();
          }
        } finally {
          q(me, `RPC '${t}' ${s} completed.`);
        }
      });
      const h = JSON.stringify(r);
      q(me, `RPC '${t}' ${s} sending request:`, r), l.send(e, "POST", h, i, 15);
    });
  }
  qo(t, e, i) {
    const r = Ph(), s = [this.Fo, "/", "google.firestore.v1.Firestore", "/", t, "/channel"], o = x0(), a = v0(), l = {
      // Required for backend stickiness, routing behavior is based on this
      // parameter.
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        // This param is used to improve routing and project isolation by the
        // backend and must be included in every request.
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: !0,
      supportsCrossDomainXhr: !0,
      internalChannelParams: {
        // Override the default timeout (randomized between 10-20 seconds) since
        // a large write batch on a slow internet connection may take a long
        // time to send to the backend. Rather than have WebChannel impose a
        // tight timeout which could lead to infinite timeouts and retries, we
        // set it very large (5-10 minutes) and rely on the browser's builtin
        // timeouts to kick in if the request isn't working.
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    }, h = this.longPollingOptions.timeoutSeconds;
    h !== void 0 && (l.longPollingTimeout = Math.round(1e3 * h)), this.useFetchStreams && (l.useFetchStreams = !0), this.Lo(l.initMessageHeaders, e, i), // Sending the custom headers we just added to request.initMessageHeaders
    // (Authorization, etc.) will trigger the browser to make a CORS preflight
    // request because the XHR will no longer meet the criteria for a "simple"
    // CORS request:
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
    // Therefore to avoid the CORS preflight request (an extra network
    // roundtrip), we use the encodeInitMessageHeaders option to specify that
    // the headers should instead be encoded in the request's POST payload,
    // which is recognized by the webchannel backend.
    l.encodeInitMessageHeaders = !0;
    const c = s.join("");
    q(me, `Creating RPC '${t}' stream ${r}: ${c}`, l);
    const p = o.createWebChannel(c, l);
    let f = !1, u = !1;
    const m = new NP({
      Eo: (y) => {
        u ? q(me, `Not sending because RPC '${t}' stream ${r} is closed:`, y) : (f || (q(me, `Opening RPC '${t}' stream ${r} transport.`), p.open(), f = !0), q(me, `RPC '${t}' stream ${r} sending:`, y), p.send(y));
      },
      Ao: () => p.close()
    }), g = (y, b, T) => {
      y.listen(b, (C) => {
        try {
          T(C);
        } catch (P) {
          setTimeout(() => {
            throw P;
          }, 0);
        }
      });
    };
    return g(p, ks.EventType.OPEN, () => {
      u || (q(me, `RPC '${t}' stream ${r} transport opened.`), m.So());
    }), g(p, ks.EventType.CLOSE, () => {
      u || (u = !0, q(me, `RPC '${t}' stream ${r} transport closed`), m.Do());
    }), g(p, ks.EventType.ERROR, (y) => {
      u || (u = !0, Fr(me, `RPC '${t}' stream ${r} transport errored:`, y), m.Do(new Y(N.UNAVAILABLE, "The operation could not be completed")));
    }), g(p, ks.EventType.MESSAGE, (y) => {
      var b;
      if (!u) {
        const T = y.data[0];
        yt(!!T);
        const C = T, P = (C == null ? void 0 : C.error) || ((b = C[0]) === null || b === void 0 ? void 0 : b.error);
        if (P) {
          q(me, `RPC '${t}' stream ${r} received error:`, P);
          const S = P.status;
          let I = (
            /**
            * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
            *
            * @returns The Code equivalent to the given status string or undefined if
            *     there is no match.
            */
            function(x) {
              const A = Gt[x];
              if (A !== void 0) return Y0(A);
            }(S)
          ), w = P.message;
          I === void 0 && (I = N.INTERNAL, w = "Unknown error status: " + S + " with message " + P.message), // Mark closed so no further events are propagated
          u = !0, m.Do(new Y(I, w)), p.close();
        } else q(me, `RPC '${t}' stream ${r} received:`, T), m.vo(T);
      }
    }), g(a, _0.STAT_EVENT, (y) => {
      y.stat === Ec.PROXY ? q(me, `RPC '${t}' stream ${r} detected buffering proxy`) : y.stat === Ec.NOPROXY && q(me, `RPC '${t}' stream ${r} detected no buffering proxy`);
    }), setTimeout(() => {
      m.bo();
    }, 0), m;
  }
}
function Ih() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yl(n) {
  return new YC(
    n,
    /* useProto3Json= */
    !0
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class o_ {
  constructor(t, e, i = 1e3, r = 1.5, s = 6e4) {
    this.li = t, this.timerId = e, this.Qo = i, this.Ko = r, this.$o = s, this.Uo = 0, this.Wo = null, /** The last backoff attempt, as epoch milliseconds. */
    this.Go = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.Uo = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  zo() {
    this.Uo = this.$o;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  jo(t) {
    this.cancel();
    const e = Math.floor(this.Uo + this.Ho()), i = Math.max(0, Date.now() - this.Go), r = Math.max(0, e - i);
    r > 0 && q("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.Uo} ms, delay with jitter: ${e} ms, last attempt: ${i} ms ago)`), this.Wo = this.li.enqueueAfterDelay(this.timerId, r, () => (this.Go = Date.now(), t())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.Uo *= this.Ko, this.Uo < this.Qo && (this.Uo = this.Qo), this.Uo > this.$o && (this.Uo = this.$o);
  }
  Jo() {
    this.Wo !== null && (this.Wo.skipDelay(), this.Wo = null);
  }
  cancel() {
    this.Wo !== null && (this.Wo.cancel(), this.Wo = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  Ho() {
    return (Math.random() - 0.5) * this.Uo;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class a_ {
  constructor(t, e, i, r, s, o, a, l) {
    this.li = t, this.Yo = i, this.Zo = r, this.connection = s, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = a, this.listener = l, this.state = 0, /**
     * A close count that's incremented every time the stream is closed; used by
     * getCloseGuardedDispatcher() to invalidate callbacks that happen after
     * close.
     */
    this.Xo = 0, this.e_ = null, this.t_ = null, this.stream = null, /**
     * Count of response messages received.
     */
    this.n_ = 0, this.r_ = new o_(t, e);
  }
  /**
   * Returns true if start() has been called and no error has occurred. True
   * indicates the stream is open or in the process of opening (which
   * encompasses respecting backoff, getting auth tokens, and starting the
   * actual RPC). Use isOpen() to determine if the stream is open and ready for
   * outbound requests.
   */
  i_() {
    return this.state === 1 || this.state === 5 || this.s_();
  }
  /**
   * Returns true if the underlying RPC is open (the onOpen() listener has been
   * called) and the stream is ready for outbound requests.
   */
  s_() {
    return this.state === 2 || this.state === 3;
  }
  /**
   * Starts the RPC. Only allowed if isStarted() returns false. The stream is
   * not immediately ready for use: onOpen() will be invoked when the RPC is
   * ready for outbound requests, at which point isOpen() will return true.
   *
   * When start returns, isStarted() will return true.
   */
  start() {
    this.n_ = 0, this.state !== 4 ? this.auth() : this.o_();
  }
  /**
   * Stops the RPC. This call is idempotent and allowed regardless of the
   * current isStarted() state.
   *
   * When stop returns, isStarted() and isOpen() will both return false.
   */
  async stop() {
    this.i_() && await this.close(
      0
      /* PersistentStreamState.Initial */
    );
  }
  /**
   * After an error the stream will usually back off on the next attempt to
   * start it. If the error warrants an immediate restart of the stream, the
   * sender can use this to indicate that the receiver should not back off.
   *
   * Each error will call the onClose() listener. That function can decide to
   * inhibit backoff if required.
   */
  __() {
    this.state = 0, this.r_.reset();
  }
  /**
   * Marks this stream as idle. If no further actions are performed on the
   * stream for one minute, the stream will automatically close itself and
   * notify the stream's onClose() handler with Status.OK. The stream will then
   * be in a !isStarted() state, requiring the caller to start the stream again
   * before further use.
   *
   * Only streams that are in state 'Open' can be marked idle, as all other
   * states imply pending network operations.
   */
  a_() {
    this.s_() && this.e_ === null && (this.e_ = this.li.enqueueAfterDelay(this.Yo, 6e4, () => this.u_()));
  }
  /** Sends a message to the underlying stream. */
  c_(t) {
    this.l_(), this.stream.send(t);
  }
  /** Called by the idle timer when the stream should close due to inactivity. */
  async u_() {
    if (this.s_())
      return this.close(
        0
        /* PersistentStreamState.Initial */
      );
  }
  /** Marks the stream as active again. */
  l_() {
    this.e_ && (this.e_.cancel(), this.e_ = null);
  }
  /** Cancels the health check delayed operation. */
  h_() {
    this.t_ && (this.t_.cancel(), this.t_ = null);
  }
  /**
   * Closes the stream and cleans up as necessary:
   *
   * * closes the underlying GRPC stream;
   * * calls the onClose handler with the given 'error';
   * * sets internal stream state to 'finalState';
   * * adjusts the backoff timer based on the error
   *
   * A new stream can be opened by calling start().
   *
   * @param finalState - the intended state of the stream after closing.
   * @param error - the error the connection was closed with.
   */
  async close(t, e) {
    this.l_(), this.h_(), this.r_.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
    // underlying stream), guaranteeing they won't execute.
    this.Xo++, t !== 4 ? (
      // If this is an intentional close ensure we don't delay our next connection attempt.
      this.r_.reset()
    ) : e && e.code === N.RESOURCE_EXHAUSTED ? (
      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
      (jn(e.toString()), jn("Using maximum backoff delay to prevent overloading the backend."), this.r_.zo())
    ) : e && e.code === N.UNAUTHENTICATED && this.state !== 3 && // "unauthenticated" error means the token was rejected. This should rarely
    // happen since both Auth and AppCheck ensure a sufficient TTL when we
    // request a token. If a user manually resets their system clock this can
    // fail, however. In this case, we should get a Code.UNAUTHENTICATED error
    // before we received the first message and we need to invalidate the token
    // to ensure that we fetch a new token.
    (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), // Clean up the underlying stream because we are no longer interested in events.
    this.stream !== null && (this.P_(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
    // inhibit backoff or otherwise manipulate the state in its non-started state.
    this.state = t, // Notify the listener that the stream closed.
    await this.listener.po(e);
  }
  /**
   * Can be overridden to perform additional cleanup before the stream is closed.
   * Calling super.tearDown() is not required.
   */
  P_() {
  }
  auth() {
    this.state = 1;
    const t = this.T_(this.Xo), e = this.Xo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([i, r]) => {
      this.Xo === e && // Normally we'd have to schedule the callback on the AsyncQueue.
      // However, the following calls are safe to be called outside the
      // AsyncQueue since they don't chain asynchronous calls
      this.I_(i, r);
    }, (i) => {
      t(() => {
        const r = new Y(N.UNKNOWN, "Fetching auth token failed: " + i.message);
        return this.E_(r);
      });
    });
  }
  I_(t, e) {
    const i = this.T_(this.Xo);
    this.stream = this.d_(t, e), this.stream.Ro(() => {
      i(() => this.listener.Ro());
    }), this.stream.mo(() => {
      i(() => (this.state = 2, this.t_ = this.li.enqueueAfterDelay(this.Zo, 1e4, () => (this.s_() && (this.state = 3), Promise.resolve())), this.listener.mo()));
    }), this.stream.po((r) => {
      i(() => this.E_(r));
    }), this.stream.onMessage((r) => {
      i(() => ++this.n_ == 1 ? this.A_(r) : this.onNext(r));
    });
  }
  o_() {
    this.state = 5, this.r_.jo(async () => {
      this.state = 0, this.start();
    });
  }
  // Visible for tests
  E_(t) {
    return q("PersistentStream", `close with error: ${t}`), this.stream = null, this.close(4, t);
  }
  /**
   * Returns a "dispatcher" function that dispatches operations onto the
   * AsyncQueue but only runs them if closeCount remains unchanged. This allows
   * us to turn auth / stream callbacks into no-ops if the stream is closed /
   * re-opened, etc.
   */
  T_(t) {
    return (e) => {
      this.li.enqueueAndForget(() => this.Xo === t ? e() : (q("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class zP extends a_ {
  constructor(t, e, i, r, s, o) {
    super(t, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, i, r, o), this.serializer = s;
  }
  d_(t, e) {
    return this.connection.qo("Listen", t, e);
  }
  A_(t) {
    return this.onNext(t);
  }
  onNext(t) {
    this.r_.reset();
    const e = QC(this.serializer, t), i = function(s) {
      if (!("targetChange" in s)) return nt.min();
      const o = s.targetChange;
      return o.targetIds && o.targetIds.length ? nt.min() : o.readTime ? An(o.readTime) : nt.min();
    }(t);
    return this.listener.R_(e, i);
  }
  /**
   * Registers interest in the results of the given target. If the target
   * includes a resumeToken it will be included in the request. Results that
   * affect the target will be streamed back as WatchChange messages that
   * reference the targetId.
   */
  V_(t) {
    const e = {};
    e.database = Bc(this.serializer), e.addTarget = function(s, o) {
      let a;
      const l = o.target;
      if (a = Rc(l) ? {
        documents: $C(s, l)
      } : {
        query: tP(s, l).ct
      }, a.targetId = o.targetId, o.resumeToken.approximateByteSize() > 0) {
        a.resumeToken = Q0(s, o.resumeToken);
        const h = Mc(s, o.expectedCount);
        h !== null && (a.expectedCount = h);
      } else if (o.snapshotVersion.compareTo(nt.min()) > 0) {
        a.readTime = za(s, o.snapshotVersion.toTimestamp());
        const h = Mc(s, o.expectedCount);
        h !== null && (a.expectedCount = h);
      }
      return a;
    }(this.serializer, t);
    const i = nP(this.serializer, t);
    i && (e.labels = i), this.c_(e);
  }
  /**
   * Unregisters interest in the results of the target associated with the
   * given targetId.
   */
  m_(t) {
    const e = {};
    e.database = Bc(this.serializer), e.removeTarget = t, this.c_(e);
  }
}
class jP extends a_ {
  constructor(t, e, i, r, s, o) {
    super(t, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, i, r, o), this.serializer = s;
  }
  /**
   * Tracks whether or not a handshake has been successfully exchanged and
   * the stream is ready to accept mutations.
   */
  get f_() {
    return this.n_ > 0;
  }
  // Override of PersistentStream.start
  start() {
    this.lastStreamToken = void 0, super.start();
  }
  P_() {
    this.f_ && this.g_([]);
  }
  d_(t, e) {
    return this.connection.qo("Write", t, e);
  }
  A_(t) {
    return yt(!!t.streamToken), this.lastStreamToken = t.streamToken, // The first response is always the handshake response
    yt(!t.writeResults || t.writeResults.length === 0), this.listener.p_();
  }
  onNext(t) {
    yt(!!t.streamToken), this.lastStreamToken = t.streamToken, // A successful first write response means the stream is healthy,
    // Note, that we could consider a successful handshake healthy, however,
    // the write itself might be causing an error we want to back off from.
    this.r_.reset();
    const e = ZC(t.writeResults, t.commitTime), i = An(t.commitTime);
    return this.listener.y_(i, e);
  }
  /**
   * Sends an initial streamToken to the server, performing the handshake
   * required to make the StreamingWrite RPC work. Subsequent
   * calls should wait until onHandshakeComplete was called.
   */
  w_() {
    const t = {};
    t.database = Bc(this.serializer), this.c_(t);
  }
  /** Sends a group of mutations to the Firestore backend to apply. */
  g_(t) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t.map((i) => JC(this.serializer, i))
    };
    this.c_(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GP extends class {
} {
  constructor(t, e, i, r) {
    super(), this.authCredentials = t, this.appCheckCredentials = e, this.connection = i, this.serializer = r, this.S_ = !1;
  }
  b_() {
    if (this.S_) throw new Y(N.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  Oo(t, e, i, r) {
    return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, o]) => this.connection.Oo(t, Vc(e, i), r, s, o)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === N.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new Y(N.UNKNOWN, s.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  ko(t, e, i, r, s) {
    return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([o, a]) => this.connection.ko(t, Vc(e, i), r, o, a, s)).catch((o) => {
      throw o.name === "FirebaseError" ? (o.code === N.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), o) : new Y(N.UNKNOWN, o.toString());
    });
  }
  terminate() {
    this.S_ = !0, this.connection.terminate();
  }
}
class HP {
  constructor(t, e) {
    this.asyncQueue = t, this.onlineStateHandler = e, /** The current OnlineState. */
    this.state = "Unknown", /**
     * A count of consecutive failures to open the stream. If it reaches the
     * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
     * Offline.
     */
    this.D_ = 0, /**
     * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
     * transition from OnlineState.Unknown to OnlineState.Offline without waiting
     * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
     */
    this.v_ = null, /**
     * Whether the client should log a warning message if it fails to connect to
     * the backend (initially true, cleared after a successful stream, or if we've
     * logged the message already).
     */
    this.C_ = !0;
  }
  /**
   * Called by RemoteStore when a watch stream is started (including on each
   * backoff attempt).
   *
   * If this is the first attempt, it sets the OnlineState to Unknown and starts
   * the onlineStateTimer.
   */
  F_() {
    this.D_ === 0 && (this.M_(
      "Unknown"
      /* OnlineState.Unknown */
    ), this.v_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.v_ = null, this.x_("Backend didn't respond within 10 seconds."), this.M_(
      "Offline"
      /* OnlineState.Offline */
    ), Promise.resolve())));
  }
  /**
   * Updates our OnlineState as appropriate after the watch stream reports a
   * failure. The first failure moves us to the 'Unknown' state. We then may
   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
   * actually transition to the 'Offline' state.
   */
  O_(t) {
    this.state === "Online" ? this.M_(
      "Unknown"
      /* OnlineState.Unknown */
    ) : (this.D_++, this.D_ >= 1 && (this.N_(), this.x_(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.M_(
      "Offline"
      /* OnlineState.Offline */
    )));
  }
  /**
   * Explicitly sets the OnlineState to the specified state.
   *
   * Note that this resets our timers / failure counters, etc. used by our
   * Offline heuristics, so must not be used in place of
   * handleWatchStreamStart() and handleWatchStreamFailure().
   */
  set(t) {
    this.N_(), this.D_ = 0, t === "Online" && // We've connected to watch at least once. Don't warn the developer
    // about being offline going forward.
    (this.C_ = !1), this.M_(t);
  }
  M_(t) {
    t !== this.state && (this.state = t, this.onlineStateHandler(t));
  }
  x_(t) {
    const e = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.C_ ? (jn(e), this.C_ = !1) : q("OnlineStateTracker", e);
  }
  N_() {
    this.v_ !== null && (this.v_.cancel(), this.v_ = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qP {
  constructor(t, e, i, r, s) {
    this.localStore = t, this.datastore = e, this.asyncQueue = i, this.remoteSyncer = {}, /**
     * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
     * LocalStore via fillWritePipeline() and have or will send to the write
     * stream.
     *
     * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
     * restart the write stream. When the stream is established the writes in the
     * pipeline will be sent in order.
     *
     * Writes remain in writePipeline until they are acknowledged by the backend
     * and thus will automatically be re-sent if the stream is interrupted /
     * restarted before they're acknowledged.
     *
     * Write responses from the backend are linked to their originating request
     * purely based on order, and so we can just shift() writes from the front of
     * the writePipeline as we receive responses.
     */
    this.L_ = [], /**
     * A mapping of watched targets that the client cares about tracking and the
     * user has explicitly called a 'listen' for this target.
     *
     * These targets may or may not have been sent to or acknowledged by the
     * server. On re-establishing the listen stream, these targets should be sent
     * to the server. The targets removed with unlistens are removed eagerly
     * without waiting for confirmation from the listen stream.
     */
    this.B_ = /* @__PURE__ */ new Map(), /**
     * A set of reasons for why the RemoteStore may be offline. If empty, the
     * RemoteStore may start its network connections.
     */
    this.k_ = /* @__PURE__ */ new Set(), /**
     * Event handlers that get called when the network is disabled or enabled.
     *
     * PORTING NOTE: These functions are used on the Web client to create the
     * underlying streams (to support tree-shakeable streams). On Android and iOS,
     * the streams are created during construction of RemoteStore.
     */
    this.q_ = [], this.Q_ = s, this.Q_.uo((o) => {
      i.enqueueAndForget(async () => {
        $i(this) && (q("RemoteStore", "Restarting streams for network reachability change."), await async function(l) {
          const h = it(l);
          h.k_.add(
            4
            /* OfflineCause.ConnectivityChange */
          ), await bo(h), h.K_.set(
            "Unknown"
            /* OnlineState.Unknown */
          ), h.k_.delete(
            4
            /* OfflineCause.ConnectivityChange */
          ), await _l(h);
        }(this));
      });
    }), this.K_ = new HP(i, r);
  }
}
async function _l(n) {
  if ($i(n)) for (const t of n.q_) await t(
    /* enabled= */
    !0
  );
}
async function bo(n) {
  for (const t of n.q_) await t(
    /* enabled= */
    !1
  );
}
function l_(n, t) {
  const e = it(n);
  e.B_.has(t.targetId) || // Mark this as something the client is currently listening for.
  (e.B_.set(t.targetId, t), Uu(e) ? (
    // The listen will be sent in onWatchStreamOpen
    Nu(e)
  ) : es(e).s_() && Lu(e, t));
}
function Fu(n, t) {
  const e = it(n), i = es(e);
  e.B_.delete(t), i.s_() && h_(e, t), e.B_.size === 0 && (i.s_() ? i.a_() : $i(e) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  e.K_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function Lu(n, t) {
  if (n.U_.xe(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(nt.min()) > 0) {
    const e = n.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;
    t = t.withExpectedCount(e);
  }
  es(n).V_(t);
}
function h_(n, t) {
  n.U_.xe(t), es(n).m_(t);
}
function Nu(n) {
  n.U_ = new GC({
    getRemoteKeysForTarget: (t) => n.remoteSyncer.getRemoteKeysForTarget(t),
    ut: (t) => n.B_.get(t) || null,
    nt: () => n.datastore.serializer.databaseId
  }), es(n).start(), n.K_.F_();
}
function Uu(n) {
  return $i(n) && !es(n).i_() && n.B_.size > 0;
}
function $i(n) {
  return it(n).k_.size === 0;
}
function c_(n) {
  n.U_ = void 0;
}
async function WP(n) {
  n.K_.set(
    "Online"
    /* OnlineState.Online */
  );
}
async function YP(n) {
  n.B_.forEach((t, e) => {
    Lu(n, t);
  });
}
async function XP(n, t) {
  c_(n), // If we still need the watch stream, retry the connection.
  Uu(n) ? (n.K_.O_(t), Nu(n)) : (
    // No need to restart watch stream because there are no active targets.
    // The online state is set to unknown because there is no active attempt
    // at establishing a connection
    n.K_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )
  );
}
async function KP(n, t, e) {
  if (
    // Mark the client as online since we got a message from the server
    n.K_.set(
      "Online"
      /* OnlineState.Online */
    ), t instanceof K0 && t.state === 2 && t.cause
  )
    try {
      await /** Handles an error on a target */
      async function(r, s) {
        const o = s.cause;
        for (const a of s.targetIds)
          r.B_.has(a) && (await r.remoteSyncer.rejectListen(a, o), r.B_.delete(a), r.U_.removeTarget(a));
      }(n, t);
    } catch (i) {
      q("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), i), await Ga(n, i);
    }
  else if (t instanceof ma ? n.U_.$e(t) : t instanceof X0 ? n.U_.Je(t) : n.U_.Ge(t), !e.isEqual(nt.min())) try {
    const i = await s_(n.localStore);
    e.compareTo(i) >= 0 && // We have received a target change with a global snapshot if the snapshot
    // version is not equal to SnapshotVersion.min().
    await /**
    * Takes a batch of changes from the Datastore, repackages them as a
    * RemoteEvent, and passes that on to the listener, which is typically the
    * SyncEngine.
    */
    function(s, o) {
      const a = s.U_.it(o);
      return a.targetChanges.forEach((l, h) => {
        if (l.resumeToken.approximateByteSize() > 0) {
          const c = s.B_.get(h);
          c && s.B_.set(h, c.withResumeToken(l.resumeToken, o));
        }
      }), // Re-establish listens for the targets that have been invalidated by
      // existence filter mismatches.
      a.targetMismatches.forEach((l, h) => {
        const c = s.B_.get(l);
        if (!c)
          return;
        s.B_.set(l, c.withResumeToken(de.EMPTY_BYTE_STRING, c.snapshotVersion)), // Cause a hard reset by unwatching and rewatching immediately, but
        // deliberately don't send a resume token so that we get a full update.
        h_(s, l);
        const p = new $n(c.target, l, h, c.sequenceNumber);
        Lu(s, p);
      }), s.remoteSyncer.applyRemoteEvent(a);
    }(n, e);
  } catch (i) {
    q("RemoteStore", "Failed to raise snapshot:", i), await Ga(n, i);
  }
}
async function Ga(n, t, e) {
  if (!$r(t)) throw t;
  n.k_.add(
    1
    /* OfflineCause.IndexedDbFailed */
  ), // Disable network and raise offline snapshots
  await bo(n), n.K_.set(
    "Offline"
    /* OnlineState.Offline */
  ), e || // Use a simple read operation to determine if IndexedDB recovered.
  // Ideally, we would expose a health check directly on SimpleDb, but
  // RemoteStore only has access to persistence through LocalStore.
  (e = () => s_(n.localStore)), // Probe IndexedDB periodically and re-enable network
  n.asyncQueue.enqueueRetryable(async () => {
    q("RemoteStore", "Retrying IndexedDB access"), await e(), n.k_.delete(
      1
      /* OfflineCause.IndexedDbFailed */
    ), await _l(n);
  });
}
function u_(n, t) {
  return t().catch((e) => Ga(n, e, t));
}
async function vl(n) {
  const t = it(n), e = pi(t);
  let i = t.L_.length > 0 ? t.L_[t.L_.length - 1].batchId : -1;
  for (; QP(t); ) try {
    const r = await VP(t.localStore, i);
    if (r === null) {
      t.L_.length === 0 && e.a_();
      break;
    }
    i = r.batchId, JP(t, r);
  } catch (r) {
    await Ga(t, r);
  }
  d_(t) && p_(t);
}
function QP(n) {
  return $i(n) && n.L_.length < 10;
}
function JP(n, t) {
  n.L_.push(t);
  const e = pi(n);
  e.s_() && e.f_ && e.g_(t.mutations);
}
function d_(n) {
  return $i(n) && !pi(n).i_() && n.L_.length > 0;
}
function p_(n) {
  pi(n).start();
}
async function ZP(n) {
  pi(n).w_();
}
async function $P(n) {
  const t = pi(n);
  for (const e of n.L_) t.g_(e.mutations);
}
async function tI(n, t, e) {
  const i = n.L_.shift(), r = ku.from(i, t, e);
  await u_(n, () => n.remoteSyncer.applySuccessfulWrite(r)), // It's possible that with the completion of this mutation another
  // slot has freed up.
  await vl(n);
}
async function eI(n, t) {
  t && pi(n).f_ && // This error affects the actual write.
  await async function(i, r) {
    if (function(o) {
      return UC(o) && o !== N.ABORTED;
    }(r.code)) {
      const s = i.L_.shift();
      pi(i).__(), await u_(i, () => i.remoteSyncer.rejectFailedWrite(s.batchId, r)), // It's possible that with the completion of this mutation
      // another slot has freed up.
      await vl(i);
    }
  }(n, t), // The write stream might have been started by refilling the write
  // pipeline for failed writes
  d_(n) && p_(n);
}
async function om(n, t) {
  const e = it(n);
  e.asyncQueue.verifyOperationInProgress(), q("RemoteStore", "RemoteStore received new credentials");
  const i = $i(e);
  e.k_.add(
    3
    /* OfflineCause.CredentialChange */
  ), await bo(e), i && // Don't set the network status to Unknown if we are offline.
  e.K_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ), await e.remoteSyncer.handleCredentialChange(t), e.k_.delete(
    3
    /* OfflineCause.CredentialChange */
  ), await _l(e);
}
async function nI(n, t) {
  const e = it(n);
  t ? (e.k_.delete(
    2
    /* OfflineCause.IsSecondary */
  ), await _l(e)) : t || (e.k_.add(
    2
    /* OfflineCause.IsSecondary */
  ), await bo(e), e.K_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function es(n) {
  return n.W_ || // Create stream (but note that it is not started yet).
  (n.W_ = function(e, i, r) {
    const s = it(e);
    return s.b_(), new zP(i, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r);
  }(n.datastore, n.asyncQueue, {
    Ro: WP.bind(null, n),
    mo: YP.bind(null, n),
    po: XP.bind(null, n),
    R_: KP.bind(null, n)
  }), n.q_.push(async (t) => {
    t ? (n.W_.__(), Uu(n) ? Nu(n) : n.K_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )) : (await n.W_.stop(), c_(n));
  })), n.W_;
}
function pi(n) {
  return n.G_ || // Create stream (but note that it is not started yet).
  (n.G_ = function(e, i, r) {
    const s = it(e);
    return s.b_(), new jP(i, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r);
  }(n.datastore, n.asyncQueue, {
    Ro: () => Promise.resolve(),
    mo: ZP.bind(null, n),
    po: eI.bind(null, n),
    p_: $P.bind(null, n),
    y_: tI.bind(null, n)
  }), n.q_.push(async (t) => {
    t ? (n.G_.__(), // This will start the write stream if necessary.
    await vl(n)) : (await n.G_.stop(), n.L_.length > 0 && (q("RemoteStore", `Stopping write stream with ${n.L_.length} pending writes`), n.L_ = []));
  })), n.G_;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zu {
  constructor(t, e, i, r, s) {
    this.asyncQueue = t, this.timerId = e, this.targetTimeMs = i, this.op = r, this.removalCallback = s, this.deferred = new ri(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((o) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(t, e, i, r, s) {
    const o = Date.now() + i, a = new zu(t, e, o, r, s);
    return a.start(i), a;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(t) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Y(N.CANCELLED, "Operation cancelled" + (t ? ": " + t : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function ju(n, t) {
  if (jn("AsyncQueue", `${t}: ${n}`), $r(n)) return new Y(N.UNAVAILABLE, `${t}: ${n}`);
  throw n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Er {
  /**
   * Returns an empty copy of the existing DocumentSet, using the same
   * comparator.
   */
  static emptySet(t) {
    return new Er(t.comparator);
  }
  /** The default ordering is by key if the comparator is omitted */
  constructor(t) {
    this.comparator = t ? (e, i) => t(e, i) || Z.comparator(e.key, i.key) : (e, i) => Z.comparator(e.key, i.key), this.keyedMap = Ms(), this.sortedSet = new Ot(this.comparator);
  }
  has(t) {
    return this.keyedMap.get(t) != null;
  }
  get(t) {
    return this.keyedMap.get(t);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  /**
   * Returns the index of the provided key in the document set, or -1 if the
   * document key is not present in the set;
   */
  indexOf(t) {
    const e = this.keyedMap.get(t);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  /** Iterates documents in order defined by "comparator" */
  forEach(t) {
    this.sortedSet.inorderTraversal((e, i) => (t(e), !1));
  }
  /** Inserts or updates a document with the same key */
  add(t) {
    const e = this.delete(t.key);
    return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));
  }
  /** Deletes a document with a given key */
  delete(t) {
    const e = this.get(t);
    return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;
  }
  isEqual(t) {
    if (!(t instanceof Er) || this.size !== t.size) return !1;
    const e = this.sortedSet.getIterator(), i = t.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const r = e.getNext().key, s = i.getNext().key;
      if (!r.isEqual(s)) return !1;
    }
    return !0;
  }
  toString() {
    const t = [];
    return this.forEach((e) => {
      t.push(e.toString());
    }), t.length === 0 ? "DocumentSet ()" : `DocumentSet (
  ` + t.join(`  
`) + `
)`;
  }
  copy(t, e) {
    const i = new Er();
    return i.comparator = this.comparator, i.keyedMap = t, i.sortedSet = e, i;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class am {
  constructor() {
    this.z_ = new Ot(Z.comparator);
  }
  track(t) {
    const e = t.doc.key, i = this.z_.get(e);
    i ? (
      // Merge the new change with the existing change.
      t.type !== 0 && i.type === 3 ? this.z_ = this.z_.insert(e, t) : t.type === 3 && i.type !== 1 ? this.z_ = this.z_.insert(e, {
        type: i.type,
        doc: t.doc
      }) : t.type === 2 && i.type === 2 ? this.z_ = this.z_.insert(e, {
        type: 2,
        doc: t.doc
      }) : t.type === 2 && i.type === 0 ? this.z_ = this.z_.insert(e, {
        type: 0,
        doc: t.doc
      }) : t.type === 1 && i.type === 0 ? this.z_ = this.z_.remove(e) : t.type === 1 && i.type === 2 ? this.z_ = this.z_.insert(e, {
        type: 1,
        doc: i.doc
      }) : t.type === 0 && i.type === 1 ? this.z_ = this.z_.insert(e, {
        type: 2,
        doc: t.doc
      }) : (
        // This includes these cases, which don't make sense:
        // Added->Added
        // Removed->Removed
        // Modified->Added
        // Removed->Modified
        // Metadata->Added
        // Removed->Metadata
        et()
      )
    ) : this.z_ = this.z_.insert(e, t);
  }
  j_() {
    const t = [];
    return this.z_.inorderTraversal((e, i) => {
      t.push(i);
    }), t;
  }
}
class jr {
  constructor(t, e, i, r, s, o, a, l, h) {
    this.query = t, this.docs = e, this.oldDocs = i, this.docChanges = r, this.mutatedKeys = s, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = l, this.hasCachedResults = h;
  }
  /** Returns a view snapshot as if all documents in the snapshot were added. */
  static fromInitialDocuments(t, e, i, r, s) {
    const o = [];
    return e.forEach((a) => {
      o.push({
        type: 0,
        doc: a
      });
    }), new jr(
      t,
      e,
      Er.emptySet(e),
      o,
      i,
      r,
      /* syncStateChanged= */
      !0,
      /* excludesMetadataChanges= */
      !1,
      s
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t) {
    if (!(this.fromCache === t.fromCache && this.hasCachedResults === t.hasCachedResults && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && dl(this.query, t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;
    const e = this.docChanges, i = t.docChanges;
    if (e.length !== i.length) return !1;
    for (let r = 0; r < e.length; r++) if (e[r].type !== i[r].type || !e[r].doc.isEqual(i[r].doc)) return !1;
    return !0;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iI {
  constructor() {
    this.H_ = void 0, this.J_ = [];
  }
  // Helper methods that checks if the query has listeners that listening to remote store
  Y_() {
    return this.J_.some((t) => t.Z_());
  }
}
class rI {
  constructor() {
    this.queries = lm(), this.onlineState = "Unknown", this.X_ = /* @__PURE__ */ new Set();
  }
  terminate() {
    (function(e, i) {
      const r = it(e), s = r.queries;
      r.queries = lm(), s.forEach((o, a) => {
        for (const l of a.J_) l.onError(i);
      });
    })(this, new Y(N.ABORTED, "Firestore shutting down"));
  }
}
function lm() {
  return new Ji((n) => D0(n), dl);
}
async function sI(n, t) {
  const e = it(n);
  let i = 3;
  const r = t.query;
  let s = e.queries.get(r);
  s ? !s.Y_() && t.Z_() && // Query has been listening to local cache, and tries to add a new listener sourced from watch.
  (i = 2) : (s = new iI(), i = t.Z_() ? 0 : 1);
  try {
    switch (i) {
      case 0:
        s.H_ = await e.onListen(
          r,
          /** enableRemoteListen= */
          !0
        );
        break;
      case 1:
        s.H_ = await e.onListen(
          r,
          /** enableRemoteListen= */
          !1
        );
        break;
      case 2:
        await e.onFirstRemoteStoreListen(r);
    }
  } catch (o) {
    const a = ju(o, `Initialization of query '${dr(t.query)}' failed`);
    return void t.onError(a);
  }
  e.queries.set(r, s), s.J_.push(t), // Run global snapshot listeners if a consistent snapshot has been emitted.
  t.ea(e.onlineState), s.H_ && t.ta(s.H_) && Gu(e);
}
async function oI(n, t) {
  const e = it(n), i = t.query;
  let r = 3;
  const s = e.queries.get(i);
  if (s) {
    const o = s.J_.indexOf(t);
    o >= 0 && (s.J_.splice(o, 1), s.J_.length === 0 ? r = t.Z_() ? 0 : 1 : !s.Y_() && t.Z_() && // The removed listener is the last one that sourced from watch.
    (r = 2));
  }
  switch (r) {
    case 0:
      return e.queries.delete(i), e.onUnlisten(
        i,
        /** disableRemoteListen= */
        !0
      );
    case 1:
      return e.queries.delete(i), e.onUnlisten(
        i,
        /** disableRemoteListen= */
        !1
      );
    case 2:
      return e.onLastRemoteStoreUnlisten(i);
    default:
      return;
  }
}
function aI(n, t) {
  const e = it(n);
  let i = !1;
  for (const r of t) {
    const s = r.query, o = e.queries.get(s);
    if (o) {
      for (const a of o.J_) a.ta(r) && (i = !0);
      o.H_ = r;
    }
  }
  i && Gu(e);
}
function lI(n, t, e) {
  const i = it(n), r = i.queries.get(t);
  if (r) for (const s of r.J_) s.onError(e);
  i.queries.delete(t);
}
function Gu(n) {
  n.X_.forEach((t) => {
    t.next();
  });
}
var Fc, hm;
(hm = Fc || (Fc = {})).na = "default", /** Listen to changes in cache only */
hm.Cache = "cache";
class hI {
  constructor(t, e, i) {
    this.query = t, this.ra = e, /**
     * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
     * observer. This flag is set to true once we've actually raised an event.
     */
    this.ia = !1, this.sa = null, this.onlineState = "Unknown", this.options = i || {};
  }
  /**
   * Applies the new ViewSnapshot to this listener, raising a user-facing event
   * if applicable (depending on what changed, whether the user has opted into
   * metadata-only changes, etc.). Returns true if a user-facing event was
   * indeed raised.
   */
  ta(t) {
    if (!this.options.includeMetadataChanges) {
      const i = [];
      for (const r of t.docChanges) r.type !== 3 && i.push(r);
      t = new jr(
        t.query,
        t.docs,
        t.oldDocs,
        i,
        t.mutatedKeys,
        t.fromCache,
        t.syncStateChanged,
        /* excludesMetadataChanges= */
        !0,
        t.hasCachedResults
      );
    }
    let e = !1;
    return this.ia ? this.oa(t) && (this.ra.next(t), e = !0) : this._a(t, this.onlineState) && (this.aa(t), e = !0), this.sa = t, e;
  }
  onError(t) {
    this.ra.error(t);
  }
  /** Returns whether a snapshot was raised. */
  ea(t) {
    this.onlineState = t;
    let e = !1;
    return this.sa && !this.ia && this._a(this.sa, t) && (this.aa(this.sa), e = !0), e;
  }
  _a(t, e) {
    if (!t.fromCache || !this.Z_()) return !0;
    const i = e !== "Offline";
    return (!this.options.ua || !i) && (!t.docs.isEmpty() || t.hasCachedResults || e === "Offline");
  }
  oa(t) {
    if (t.docChanges.length > 0) return !0;
    const e = this.sa && this.sa.hasPendingWrites !== t.hasPendingWrites;
    return !(!t.syncStateChanged && !e) && this.options.includeMetadataChanges === !0;
  }
  aa(t) {
    t = jr.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache, t.hasCachedResults), this.ia = !0, this.ra.next(t);
  }
  Z_() {
    return this.options.source !== Fc.Cache;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class f_ {
  constructor(t) {
    this.key = t;
  }
}
class m_ {
  constructor(t) {
    this.key = t;
  }
}
class cI {
  constructor(t, e) {
    this.query = t, this.da = e, this.Aa = null, this.hasCachedResults = !1, /**
     * A flag whether the view is current with the backend. A view is considered
     * current after it has seen the current flag from the backend and did not
     * lose consistency within the watch stream (e.g. because of an existence
     * filter mismatch).
     */
    this.current = !1, /** Documents in the view but not in the remote target */
    this.Ra = at(), /** Document Keys that have local changes */
    this.mutatedKeys = at(), this.Va = B0(t), this.ma = new Er(this.Va);
  }
  /**
   * The set of remote documents that the server has told us belongs to the target associated with
   * this view.
   */
  get fa() {
    return this.da;
  }
  /**
   * Iterates over a set of doc changes, applies the query limit, and computes
   * what the new results should be, what the changes were, and whether we may
   * need to go back to the local cache for more results. Does not make any
   * changes to the view.
   * @param docChanges - The doc changes to apply to this view.
   * @param previousChanges - If this is being called with a refill, then start
   *        with this set of docs and changes instead of the current view.
   * @returns a new set of docs, changes, and refill flag.
   */
  ga(t, e) {
    const i = e ? e.pa : new am(), r = e ? e.ma : this.ma;
    let s = e ? e.mutatedKeys : this.mutatedKeys, o = r, a = !1;
    const l = this.query.limitType === "F" && r.size === this.query.limit ? r.last() : null, h = this.query.limitType === "L" && r.size === this.query.limit ? r.first() : null;
    if (t.inorderTraversal((c, p) => {
      const f = r.get(c), u = pl(this.query, p) ? p : null, m = !!f && this.mutatedKeys.has(f.key), g = !!u && (u.hasLocalMutations || // We only consider committed mutations for documents that were
      // mutated during the lifetime of the view.
      this.mutatedKeys.has(u.key) && u.hasCommittedMutations);
      let y = !1;
      f && u ? f.data.isEqual(u.data) ? m !== g && (i.track({
        type: 3,
        doc: u
      }), y = !0) : this.ya(f, u) || (i.track({
        type: 2,
        doc: u
      }), y = !0, (l && this.Va(u, l) > 0 || h && this.Va(u, h) < 0) && // This doc moved from inside the limit to outside the limit.
      // That means there may be some other doc in the local cache
      // that should be included instead.
      (a = !0)) : !f && u ? (i.track({
        type: 0,
        doc: u
      }), y = !0) : f && !u && (i.track({
        type: 1,
        doc: f
      }), y = !0, (l || h) && // A doc was removed from a full limit query. We'll need to
      // requery from the local cache to see if we know about some other
      // doc that should be in the results.
      (a = !0)), y && (u ? (o = o.add(u), s = g ? s.add(c) : s.delete(c)) : (o = o.delete(c), s = s.delete(c)));
    }), this.query.limit !== null) for (; o.size > this.query.limit; ) {
      const c = this.query.limitType === "F" ? o.last() : o.first();
      o = o.delete(c.key), s = s.delete(c.key), i.track({
        type: 1,
        doc: c
      });
    }
    return {
      ma: o,
      pa: i,
      ss: a,
      mutatedKeys: s
    };
  }
  ya(t, e) {
    return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  /**
   * Updates the view with the given ViewDocumentChanges and optionally updates
   * limbo docs and sync state from the provided target change.
   * @param docChanges - The set of changes to make to the view's docs.
   * @param limboResolutionEnabled - Whether to update limbo documents based on
   *        this change.
   * @param targetChange - A target change to apply for computing limbo docs and
   *        sync state.
   * @param targetIsPendingReset - Whether the target is pending to reset due to
   *        existence filter mismatch. If not explicitly specified, it is treated
   *        equivalently to `false`.
   * @returns A new ViewChange with the given docs, changes, and sync state.
   */
  // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
  applyChanges(t, e, i, r) {
    const s = this.ma;
    this.ma = t.ma, this.mutatedKeys = t.mutatedKeys;
    const o = t.pa.j_();
    o.sort((c, p) => function(u, m) {
      const g = (y) => {
        switch (y) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return et();
        }
      };
      return g(u) - g(m);
    }(c.type, p.type) || this.Va(c.doc, p.doc)), this.wa(i), r = r != null && r;
    const a = e && !r ? this.Sa() : [], l = this.Ra.size === 0 && this.current && !r ? 1 : 0, h = l !== this.Aa;
    return this.Aa = l, o.length !== 0 || h ? {
      snapshot: new jr(
        this.query,
        t.ma,
        s,
        o,
        t.mutatedKeys,
        l === 0,
        h,
        /* excludesMetadataChanges= */
        !1,
        !!i && i.resumeToken.approximateByteSize() > 0
      ),
      ba: a
    } : {
      ba: a
    };
  }
  /**
   * Applies an OnlineState change to the view, potentially generating a
   * ViewChange if the view's syncState changes as a result.
   */
  ea(t) {
    return this.current && t === "Offline" ? (
      // If we're offline, set `current` to false and then call applyChanges()
      // to refresh our syncState and generate a ViewChange as appropriate. We
      // are guaranteed to get a new TargetChange that sets `current` back to
      // true once the client is back online.
      (this.current = !1, this.applyChanges(
        {
          ma: this.ma,
          pa: new am(),
          mutatedKeys: this.mutatedKeys,
          ss: !1
        },
        /* limboResolutionEnabled= */
        !1
      ))
    ) : {
      ba: []
    };
  }
  /**
   * Returns whether the doc for the given key should be in limbo.
   */
  Da(t) {
    return !this.da.has(t) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
    !!this.ma.has(t) && !this.ma.get(t).hasLocalMutations;
  }
  /**
   * Updates syncedDocuments, current, and limbo docs based on the given change.
   * Returns the list of changes to which docs are in limbo.
   */
  wa(t) {
    t && (t.addedDocuments.forEach((e) => this.da = this.da.add(e)), t.modifiedDocuments.forEach((e) => {
    }), t.removedDocuments.forEach((e) => this.da = this.da.delete(e)), this.current = t.current);
  }
  Sa() {
    if (!this.current) return [];
    const t = this.Ra;
    this.Ra = at(), this.ma.forEach((i) => {
      this.Da(i.key) && (this.Ra = this.Ra.add(i.key));
    });
    const e = [];
    return t.forEach((i) => {
      this.Ra.has(i) || e.push(new m_(i));
    }), this.Ra.forEach((i) => {
      t.has(i) || e.push(new f_(i));
    }), e;
  }
  /**
   * Update the in-memory state of the current view with the state read from
   * persistence.
   *
   * We update the query view whenever a client's primary status changes:
   * - When a client transitions from primary to secondary, it can miss
   *   LocalStorage updates and its query views may temporarily not be
   *   synchronized with the state on disk.
   * - For secondary to primary transitions, the client needs to update the list
   *   of `syncedDocuments` since secondary clients update their query views
   *   based purely on synthesized RemoteEvents.
   *
   * @param queryResult.documents - The documents that match the query according
   * to the LocalStore.
   * @param queryResult.remoteKeys - The keys of the documents that match the
   * query according to the backend.
   *
   * @returns The ViewChange that resulted from this synchronization.
   */
  // PORTING NOTE: Multi-tab only.
  va(t) {
    this.da = t.ds, this.Ra = at();
    const e = this.ga(t.documents);
    return this.applyChanges(
      e,
      /* limboResolutionEnabled= */
      !0
    );
  }
  /**
   * Returns a view snapshot as if this query was just listened to. Contains
   * a document add for every existing document and the `fromCache` and
   * `hasPendingWrites` status of the already established view.
   */
  // PORTING NOTE: Multi-tab only.
  Ca() {
    return jr.fromInitialDocuments(this.query, this.ma, this.mutatedKeys, this.Aa === 0, this.hasCachedResults);
  }
}
class uI {
  constructor(t, e, i) {
    this.query = t, this.targetId = e, this.view = i;
  }
}
class dI {
  constructor(t) {
    this.key = t, /**
     * Set to true once we've received a document. This is used in
     * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
     * decide whether it needs to manufacture a delete event for the target once
     * the target is CURRENT.
     */
    this.Fa = !1;
  }
}
class pI {
  constructor(t, e, i, r, s, o) {
    this.localStore = t, this.remoteStore = e, this.eventManager = i, this.sharedClientState = r, this.currentUser = s, this.maxConcurrentLimboResolutions = o, this.Ma = {}, this.xa = new Ji((a) => D0(a), dl), this.Oa = /* @__PURE__ */ new Map(), /**
     * The keys of documents that are in limbo for which we haven't yet started a
     * limbo resolution query. The strings in this set are the result of calling
     * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
     *
     * The `Set` type was chosen because it provides efficient lookup and removal
     * of arbitrary elements and it also maintains insertion order, providing the
     * desired queue-like FIFO semantics.
     */
    this.Na = /* @__PURE__ */ new Set(), /**
     * Keeps track of the target ID for each document that is in limbo with an
     * active target.
     */
    this.La = new Ot(Z.comparator), /**
     * Keeps track of the information about an active limbo resolution for each
     * active target ID that was started for the purpose of limbo resolution.
     */
    this.Ba = /* @__PURE__ */ new Map(), this.ka = new Du(), /** Stores user completion handlers, indexed by User and BatchId. */
    this.qa = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
    this.Qa = /* @__PURE__ */ new Map(), this.Ka = zr.Qn(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
    // startup. In the interim, a client should only be considered primary if
    // `isPrimary` is true.
    this.$a = void 0;
  }
  get isPrimaryClient() {
    return this.$a === !0;
  }
}
async function fI(n, t, e = !0) {
  const i = b_(n);
  let r;
  const s = i.xa.get(t);
  return s ? (
    // PORTING NOTE: With Multi-Tab Web, it is possible that a query view
    // already exists when EventManager calls us for the first time. This
    // happens when the primary tab is already listening to this query on
    // behalf of another tab and the user of the primary also starts listening
    // to the query. EventManager will not have an assigned target ID in this
    // case and calls `listen` to obtain this ID.
    (i.sharedClientState.addLocalQueryTarget(s.targetId), r = s.view.Ca())
  ) : r = await g_(
    i,
    t,
    e,
    /** shouldInitializeView= */
    !0
  ), r;
}
async function mI(n, t) {
  const e = b_(n);
  await g_(
    e,
    t,
    /** shouldListenToRemote= */
    !0,
    /** shouldInitializeView= */
    !1
  );
}
async function g_(n, t, e, i) {
  const r = await DP(n.localStore, wn(t)), s = r.targetId, o = n.sharedClientState.addLocalQueryTarget(s, e);
  let a;
  return i && (a = await gI(n, t, s, o === "current", r.resumeToken)), n.isPrimaryClient && e && l_(n.remoteStore, r), a;
}
async function gI(n, t, e, i, r) {
  n.Ua = (p, f, u) => async function(g, y, b, T) {
    let C = y.view.ga(b);
    C.ss && // The query has a limit and some docs were removed, so we need
    // to re-run the query against the local store to make sure we
    // didn't lose any good docs that had been past the limit.
    (C = await im(
      g.localStore,
      y.query,
      /* usePreviousResults= */
      !1
    ).then(({ documents: w }) => y.view.ga(w, C)));
    const P = T && T.targetChanges.get(y.targetId), S = T && T.targetMismatches.get(y.targetId) != null, I = y.view.applyChanges(
      C,
      /* limboResolutionEnabled= */
      g.isPrimaryClient,
      P,
      S
    );
    return um(g, y.targetId, I.ba), I.snapshot;
  }(n, p, f, u);
  const s = await im(
    n.localStore,
    t,
    /* usePreviousResults= */
    !0
  ), o = new cI(t, s.ds), a = o.ga(s.documents), l = xo.createSynthesizedTargetChangeForCurrentChange(e, i && n.onlineState !== "Offline", r), h = o.applyChanges(
    a,
    /* limboResolutionEnabled= */
    n.isPrimaryClient,
    l
  );
  um(n, e, h.ba);
  const c = new uI(t, e, o);
  return n.xa.set(t, c), n.Oa.has(e) ? n.Oa.get(e).push(t) : n.Oa.set(e, [t]), h.snapshot;
}
async function yI(n, t, e) {
  const i = it(n), r = i.xa.get(t), s = i.Oa.get(r.targetId);
  if (s.length > 1) return i.Oa.set(r.targetId, s.filter((o) => !dl(o, t))), void i.xa.delete(t);
  i.isPrimaryClient ? (i.sharedClientState.removeLocalQueryTarget(r.targetId), i.sharedClientState.isActiveQueryTarget(r.targetId) || await Oc(
    i.localStore,
    r.targetId,
    /*keepPersistedTargetData=*/
    !1
  ).then(() => {
    i.sharedClientState.clearQueryState(r.targetId), e && Fu(i.remoteStore, r.targetId), Lc(i, r.targetId);
  }).catch(Zr)) : (Lc(i, r.targetId), await Oc(
    i.localStore,
    r.targetId,
    /*keepPersistedTargetData=*/
    !0
  ));
}
async function _I(n, t) {
  const e = it(n), i = e.xa.get(t), r = e.Oa.get(i.targetId);
  e.isPrimaryClient && r.length === 1 && // PORTING NOTE: Unregister the target ID with local Firestore client as
  // watch target.
  (e.sharedClientState.removeLocalQueryTarget(i.targetId), Fu(e.remoteStore, i.targetId));
}
async function vI(n, t, e) {
  const i = EI(n);
  try {
    const r = await function(o, a) {
      const l = it(o), h = Zt.now(), c = a.reduce((u, m) => u.add(m.key), at());
      let p, f;
      return l.persistence.runTransaction("Locally write mutations", "readwrite", (u) => {
        let m = Gn(), g = at();
        return l.hs.getEntries(u, c).next((y) => {
          m = y, m.forEach((b, T) => {
            T.isValidDocument() || (g = g.add(b));
          });
        }).next(() => l.localDocuments.getOverlayedDocuments(u, m)).next((y) => {
          p = y;
          const b = [];
          for (const T of a) {
            const C = BC(T, p.get(T.key).overlayedDocument);
            C != null && // NOTE: The base state should only be applied if there's some
            // existing document to override, so use a Precondition of
            // exists=true
            b.push(new Zi(T.key, C, S0(C.value.mapValue), Ln.exists(!0)));
          }
          return l.mutationQueue.addMutationBatch(u, h, b, a);
        }).next((y) => {
          f = y;
          const b = y.applyToLocalDocumentSet(p, g);
          return l.documentOverlayCache.saveOverlays(u, y.batchId, b);
        });
      }).then(() => ({
        batchId: f.batchId,
        changes: F0(p)
      }));
    }(i.localStore, t);
    i.sharedClientState.addPendingMutation(r.batchId), function(o, a, l) {
      let h = o.qa[o.currentUser.toKey()];
      h || (h = new Ot(lt)), h = h.insert(a, l), o.qa[o.currentUser.toKey()] = h;
    }(i, r.batchId, e), await wo(i, r.changes), await vl(i.remoteStore);
  } catch (r) {
    const s = ju(r, "Failed to persist write");
    e.reject(s);
  }
}
async function y_(n, t) {
  const e = it(n);
  try {
    const i = await kP(e.localStore, t);
    t.targetChanges.forEach((r, s) => {
      const o = e.Ba.get(s);
      o && // Since this is a limbo resolution lookup, it's for a single document
      // and it could be added, modified, or removed, but not a combination.
      (yt(r.addedDocuments.size + r.modifiedDocuments.size + r.removedDocuments.size <= 1), r.addedDocuments.size > 0 ? o.Fa = !0 : r.modifiedDocuments.size > 0 ? yt(o.Fa) : r.removedDocuments.size > 0 && (yt(o.Fa), o.Fa = !1));
    }), await wo(e, i, t);
  } catch (i) {
    await Zr(i);
  }
}
function cm(n, t, e) {
  const i = it(n);
  if (i.isPrimaryClient && e === 0 || !i.isPrimaryClient && e === 1) {
    const r = [];
    i.xa.forEach((s, o) => {
      const a = o.view.ea(t);
      a.snapshot && r.push(a.snapshot);
    }), function(o, a) {
      const l = it(o);
      l.onlineState = a;
      let h = !1;
      l.queries.forEach((c, p) => {
        for (const f of p.J_)
          f.ea(a) && (h = !0);
      }), h && Gu(l);
    }(i.eventManager, t), r.length && i.Ma.R_(r), i.onlineState = t, i.isPrimaryClient && i.sharedClientState.setOnlineState(t);
  }
}
async function xI(n, t, e) {
  const i = it(n);
  i.sharedClientState.updateQueryState(t, "rejected", e);
  const r = i.Ba.get(t), s = r && r.key;
  if (s) {
    let o = new Ot(Z.comparator);
    o = o.insert(s, ye.newNoDocument(s, nt.min()));
    const a = at().add(s), l = new gl(
      nt.min(),
      /* targetChanges= */
      /* @__PURE__ */ new Map(),
      /* targetMismatches= */
      new Ot(lt),
      o,
      a
    );
    await y_(i, l), // Since this query failed, we won't want to manually unlisten to it.
    // We only remove it from bookkeeping after we successfully applied the
    // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
    // this query when the RemoteStore restarts the Watch stream, which should
    // re-trigger the target failure.
    i.La = i.La.remove(s), i.Ba.delete(t), Hu(i);
  } else await Oc(
    i.localStore,
    t,
    /* keepPersistedTargetData */
    !1
  ).then(() => Lc(i, t, e)).catch(Zr);
}
async function bI(n, t) {
  const e = it(n), i = t.batch.batchId;
  try {
    const r = await RP(e.localStore, t);
    v_(
      e,
      i,
      /*error=*/
      null
    ), __(e, i), e.sharedClientState.updateMutationState(i, "acknowledged"), await wo(e, r);
  } catch (r) {
    await Zr(r);
  }
}
async function wI(n, t, e) {
  const i = it(n);
  try {
    const r = await function(o, a) {
      const l = it(o);
      return l.persistence.runTransaction("Reject batch", "readwrite-primary", (h) => {
        let c;
        return l.mutationQueue.lookupMutationBatch(h, a).next((p) => (yt(p !== null), c = p.keys(), l.mutationQueue.removeMutationBatch(h, p))).next(() => l.mutationQueue.performConsistencyCheck(h)).next(() => l.documentOverlayCache.removeOverlaysForBatchId(h, c, a)).next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(h, c)).next(() => l.localDocuments.getDocuments(h, c));
      });
    }(i.localStore, t);
    v_(i, t, e), __(i, t), i.sharedClientState.updateMutationState(t, "rejected", e), await wo(i, r);
  } catch (r) {
    await Zr(r);
  }
}
function __(n, t) {
  (n.Qa.get(t) || []).forEach((e) => {
    e.resolve();
  }), n.Qa.delete(t);
}
function v_(n, t, e) {
  const i = it(n);
  let r = i.qa[i.currentUser.toKey()];
  if (r) {
    const s = r.get(t);
    s && (e ? s.reject(e) : s.resolve(), r = r.remove(t)), i.qa[i.currentUser.toKey()] = r;
  }
}
function Lc(n, t, e = null) {
  n.sharedClientState.removeLocalQueryTarget(t);
  for (const i of n.Oa.get(t)) n.xa.delete(i), e && n.Ma.Wa(i, e);
  n.Oa.delete(t), n.isPrimaryClient && n.ka.yr(t).forEach((i) => {
    n.ka.containsKey(i) || // We removed the last reference for this key
    x_(n, i);
  });
}
function x_(n, t) {
  n.Na.delete(t.path.canonicalString());
  const e = n.La.get(t);
  e !== null && (Fu(n.remoteStore, e), n.La = n.La.remove(t), n.Ba.delete(e), Hu(n));
}
function um(n, t, e) {
  for (const i of e) i instanceof f_ ? (n.ka.addReference(i.key, t), AI(n, i)) : i instanceof m_ ? (q("SyncEngine", "Document no longer in limbo: " + i.key), n.ka.removeReference(i.key, t), n.ka.containsKey(i.key) || // We removed the last reference for this key
  x_(n, i.key)) : et();
}
function AI(n, t) {
  const e = t.key, i = e.path.canonicalString();
  n.La.get(e) || n.Na.has(i) || (q("SyncEngine", "New document in limbo: " + e), n.Na.add(i), Hu(n));
}
function Hu(n) {
  for (; n.Na.size > 0 && n.La.size < n.maxConcurrentLimboResolutions; ) {
    const t = n.Na.values().next().value;
    n.Na.delete(t);
    const e = new Z(Tt.fromString(t)), i = n.Ka.next();
    n.Ba.set(i, new dI(e)), n.La = n.La.insert(e, i), l_(n.remoteStore, new $n(wn(M0(e.path)), i, "TargetPurposeLimboResolution", hl.oe));
  }
}
async function wo(n, t, e) {
  const i = it(n), r = [], s = [], o = [];
  i.xa.isEmpty() || (i.xa.forEach((a, l) => {
    o.push(i.Ua(l, t, e).then((h) => {
      var c;
      if ((h || e) && i.isPrimaryClient) {
        const p = h ? !h.fromCache : (c = e == null ? void 0 : e.targetChanges.get(l.targetId)) === null || c === void 0 ? void 0 : c.current;
        i.sharedClientState.updateQueryState(l.targetId, p ? "current" : "not-current");
      }
      if (h) {
        r.push(h);
        const p = Ou.zi(l.targetId, h);
        s.push(p);
      }
    }));
  }), await Promise.all(o), i.Ma.R_(r), await async function(l, h) {
    const c = it(l);
    try {
      await c.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (p) => L.forEach(h, (f) => L.forEach(f.Wi, (u) => c.persistence.referenceDelegate.addReference(p, f.targetId, u)).next(() => L.forEach(f.Gi, (u) => c.persistence.referenceDelegate.removeReference(p, f.targetId, u)))));
    } catch (p) {
      if (!$r(p)) throw p;
      q("LocalStore", "Failed to update sequence numbers: " + p);
    }
    for (const p of h) {
      const f = p.targetId;
      if (!p.fromCache) {
        const u = c.us.get(f), m = u.snapshotVersion, g = u.withLastLimboFreeSnapshotVersion(m);
        c.us = c.us.insert(f, g);
      }
    }
  }(i.localStore, s));
}
async function TI(n, t) {
  const e = it(n);
  if (!e.currentUser.isEqual(t)) {
    q("SyncEngine", "User change. New user:", t.toKey());
    const i = await r_(e.localStore, t);
    e.currentUser = t, // Fails tasks waiting for pending writes requested by previous user.
    function(s, o) {
      s.Qa.forEach((a) => {
        a.forEach((l) => {
          l.reject(new Y(N.CANCELLED, o));
        });
      }), s.Qa.clear();
    }(e, "'waitForPendingWrites' promise is rejected due to a user change."), // TODO(b/114226417): Consider calling this only in the primary tab.
    e.sharedClientState.handleUserChange(t, i.removedBatchIds, i.addedBatchIds), await wo(e, i.Ts);
  }
}
function SI(n, t) {
  const e = it(n), i = e.Ba.get(t);
  if (i && i.Fa) return at().add(i.key);
  {
    let r = at();
    const s = e.Oa.get(t);
    if (!s) return r;
    for (const o of s) {
      const a = e.xa.get(o);
      r = r.unionWith(a.view.fa);
    }
    return r;
  }
}
function b_(n) {
  const t = it(n);
  return t.remoteStore.remoteSyncer.applyRemoteEvent = y_.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = SI.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = xI.bind(null, t), t.Ma.R_ = aI.bind(null, t.eventManager), t.Ma.Wa = lI.bind(null, t.eventManager), t;
}
function EI(n) {
  const t = it(n);
  return t.remoteStore.remoteSyncer.applySuccessfulWrite = bI.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = wI.bind(null, t), t;
}
class Ha {
  constructor() {
    this.kind = "memory", this.synchronizeTabs = !1;
  }
  async initialize(t) {
    this.serializer = yl(t.databaseInfo.databaseId), this.sharedClientState = this.za(t), this.persistence = this.ja(t), await this.persistence.start(), this.localStore = this.Ha(t), this.gcScheduler = this.Ja(t, this.localStore), this.indexBackfillerScheduler = this.Ya(t, this.localStore);
  }
  Ja(t, e) {
    return null;
  }
  Ya(t, e) {
    return null;
  }
  Ha(t) {
    return IP(this.persistence, new CP(), t.initialUser, this.serializer);
  }
  ja(t) {
    return new i_(Bu.ei, this.serializer);
  }
  za(t) {
    return new OP();
  }
  async terminate() {
    var t, e;
    (t = this.gcScheduler) === null || t === void 0 || t.stop(), (e = this.indexBackfillerScheduler) === null || e === void 0 || e.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
Ha.provider = {
  build: () => new Ha()
};
class CI extends Ha {
  constructor(t) {
    super(), this.cacheSizeBytes = t;
  }
  Ja(t, e) {
    yt(this.persistence.referenceDelegate instanceof ja);
    const i = this.persistence.referenceDelegate.garbageCollector;
    return new dP(i, t.asyncQueue, e);
  }
  ja(t) {
    const e = this.cacheSizeBytes !== void 0 ? ke.withCacheSize(this.cacheSizeBytes) : ke.DEFAULT;
    return new i_((i) => ja.ei(i, e), this.serializer);
  }
}
class Nc {
  async initialize(t, e) {
    this.localStore || (this.localStore = t.localStore, this.sharedClientState = t.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(
      e,
      /* startAsPrimary=*/
      !t.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (i) => cm(
      this.syncEngine,
      i,
      1
      /* OnlineStateSource.SharedClientState */
    ), this.remoteStore.remoteSyncer.handleCredentialChange = TI.bind(null, this.syncEngine), await nI(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t) {
    return function() {
      return new rI();
    }();
  }
  createDatastore(t) {
    const e = yl(t.databaseInfo.databaseId), i = function(s) {
      return new UP(s);
    }(t.databaseInfo);
    return function(s, o, a, l) {
      return new GP(s, o, a, l);
    }(t.authCredentials, t.appCheckCredentials, i, e);
  }
  createRemoteStore(t) {
    return function(i, r, s, o, a) {
      return new qP(i, r, s, o, a);
    }(this.localStore, this.datastore, t.asyncQueue, (e) => cm(
      this.syncEngine,
      e,
      0
      /* OnlineStateSource.RemoteStore */
    ), function() {
      return sm.p() ? new sm() : new FP();
    }());
  }
  createSyncEngine(t, e) {
    return function(r, s, o, a, l, h, c) {
      const p = new pI(r, s, o, a, l, h);
      return c && (p.$a = !0), p;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t.initialUser, t.maxConcurrentLimboResolutions, e);
  }
  async terminate() {
    var t, e;
    await async function(r) {
      const s = it(r);
      q("RemoteStore", "RemoteStore shutting down."), s.k_.add(
        5
        /* OfflineCause.Shutdown */
      ), await bo(s), s.Q_.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
      // triggering spurious listener events with cached data, etc.
      s.K_.set(
        "Unknown"
        /* OnlineState.Unknown */
      );
    }(this.remoteStore), (t = this.datastore) === null || t === void 0 || t.terminate(), (e = this.eventManager) === null || e === void 0 || e.terminate();
  }
}
Nc.provider = {
  build: () => new Nc()
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PI {
  constructor(t) {
    this.observer = t, /**
     * When set to true, will not raise future events. Necessary to deal with
     * async detachment of listener.
     */
    this.muted = !1;
  }
  next(t) {
    this.muted || this.observer.next && this.Xa(this.observer.next, t);
  }
  error(t) {
    this.muted || (this.observer.error ? this.Xa(this.observer.error, t) : jn("Uncaught Error in snapshot listener:", t.toString()));
  }
  eu() {
    this.muted = !0;
  }
  Xa(t, e) {
    setTimeout(() => {
      this.muted || t(e);
    }, 0);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class II {
  constructor(t, e, i, r, s) {
    this.authCredentials = t, this.appCheckCredentials = e, this.asyncQueue = i, this.databaseInfo = r, this.user = ge.UNAUTHENTICATED, this.clientId = w0.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = s, this.authCredentials.start(i, async (o) => {
      q("FirestoreClient", "Received user=", o.uid), await this.authCredentialListener(o), this.user = o;
    }), this.appCheckCredentials.start(i, (o) => (q("FirestoreClient", "Received new app check token=", o), this.appCheckCredentialListener(o, this.user)));
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t) {
    this.authCredentialListener = t;
  }
  setAppCheckTokenChangeListener(t) {
    this.appCheckCredentialListener = t;
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t = new ri();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
        // RemoteStore as it will prevent the RemoteStore from retrieving auth
        // tokens.
        this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t.resolve();
      } catch (e) {
        const i = ju(e, "Failed to shutdown persistence");
        t.reject(i);
      }
    }), t.promise;
  }
}
async function Rh(n, t) {
  n.asyncQueue.verifyOperationInProgress(), q("FirestoreClient", "Initializing OfflineComponentProvider");
  const e = n.configuration;
  await t.initialize(e);
  let i = e.initialUser;
  n.setCredentialChangeListener(async (r) => {
    i.isEqual(r) || (await r_(t.localStore, r), i = r);
  }), // When a user calls clearPersistence() in one client, all other clients
  // need to be terminated to allow the delete to succeed.
  t.persistence.setDatabaseDeletedListener(() => n.terminate()), n._offlineComponents = t;
}
async function dm(n, t) {
  n.asyncQueue.verifyOperationInProgress();
  const e = await RI(n);
  q("FirestoreClient", "Initializing OnlineComponentProvider"), await t.initialize(e, n.configuration), // The CredentialChangeListener of the online component provider takes
  // precedence over the offline component provider.
  n.setCredentialChangeListener((i) => om(t.remoteStore, i)), n.setAppCheckTokenChangeListener((i, r) => om(t.remoteStore, r)), n._onlineComponents = t;
}
async function RI(n) {
  if (!n._offlineComponents) if (n._uninitializedComponentsProvider) {
    q("FirestoreClient", "Using user provided OfflineComponentProvider");
    try {
      await Rh(n, n._uninitializedComponentsProvider._offline);
    } catch (t) {
      const e = t;
      if (!function(r) {
        return r.name === "FirebaseError" ? r.code === N.FAILED_PRECONDITION || r.code === N.UNIMPLEMENTED : !(typeof DOMException < "u" && r instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
        // or an aborted error depending on whether the error happened during
        // schema migration.
        r.code === 22 || r.code === 20 || // Firefox Private Browsing mode disables IndexedDb and returns
        // INVALID_STATE for any usage.
        r.code === 11;
      }(e)) throw e;
      Fr("Error using user provided cache. Falling back to memory cache: " + e), await Rh(n, new Ha());
    }
  } else q("FirestoreClient", "Using default OfflineComponentProvider"), await Rh(n, new CI(void 0));
  return n._offlineComponents;
}
async function w_(n) {
  return n._onlineComponents || (n._uninitializedComponentsProvider ? (q("FirestoreClient", "Using user provided OnlineComponentProvider"), await dm(n, n._uninitializedComponentsProvider._online)) : (q("FirestoreClient", "Using default OnlineComponentProvider"), await dm(n, new Nc()))), n._onlineComponents;
}
function kI(n) {
  return w_(n).then((t) => t.syncEngine);
}
async function MI(n) {
  const t = await w_(n), e = t.eventManager;
  return e.onListen = fI.bind(null, t.syncEngine), e.onUnlisten = yI.bind(null, t.syncEngine), e.onFirstRemoteStoreListen = mI.bind(null, t.syncEngine), e.onLastRemoteStoreUnlisten = _I.bind(null, t.syncEngine), e;
}
function VI(n, t, e = {}) {
  const i = new ri();
  return n.asyncQueue.enqueueAndForget(async () => function(s, o, a, l, h) {
    const c = new PI({
      next: (f) => {
        c.eu(), o.enqueueAndForget(() => oI(s, p)), f.fromCache && l.source === "server" ? h.reject(new Y(N.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : h.resolve(f);
      },
      error: (f) => h.reject(f)
    }), p = new hI(a, c, {
      includeMetadataChanges: !0,
      ua: !0
    });
    return sI(s, p);
  }(await MI(n), n.asyncQueue, t, e, i)), i.promise;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function A_(n) {
  const t = {};
  return n.timeoutSeconds !== void 0 && (t.timeoutSeconds = n.timeoutSeconds), t;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pm = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function T_(n, t, e) {
  if (!e) throw new Y(N.INVALID_ARGUMENT, `Function ${n}() cannot be called with an empty ${t}.`);
}
function DI(n, t, e, i) {
  if (t === !0 && i === !0) throw new Y(N.INVALID_ARGUMENT, `${n} and ${e} cannot be used together.`);
}
function fm(n) {
  if (!Z.isDocumentKey(n)) throw new Y(N.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function mm(n) {
  if (Z.isDocumentKey(n)) throw new Y(N.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function xl(n) {
  if (n === void 0) return "undefined";
  if (n === null) return "null";
  if (typeof n == "string") return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == "number" || typeof n == "boolean") return "" + n;
  if (typeof n == "object") {
    if (n instanceof Array) return "an array";
    {
      const t = (
        /** try to get the constructor name for an object. */
        function(i) {
          return i.constructor ? i.constructor.name : null;
        }(n)
      );
      return t ? `a custom ${t} object` : "an object";
    }
  }
  return typeof n == "function" ? "a function" : et();
}
function yo(n, t) {
  if ("_delegate" in n && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (n = n._delegate), !(n instanceof t)) {
    if (t.name === n.constructor.name) throw new Y(N.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const e = xl(n);
      throw new Y(N.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${e}`);
    }
  }
  return n;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gm {
  constructor(t) {
    var e, i;
    if (t.host === void 0) {
      if (t.ssl !== void 0) throw new Y(N.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else this.host = t.host, this.ssl = (e = t.ssl) === null || e === void 0 || e;
    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, this.localCache = t.localCache, t.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040;
    else {
      if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576) throw new Y(N.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t.cacheSizeBytes;
    }
    DI("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : t.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling
    ), this.experimentalLongPollingOptions = A_((i = t.experimentalLongPollingOptions) !== null && i !== void 0 ? i : {}), function(s) {
      if (s.timeoutSeconds !== void 0) {
        if (isNaN(s.timeoutSeconds)) throw new Y(N.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`);
        if (s.timeoutSeconds < 5) throw new Y(N.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`);
        if (s.timeoutSeconds > 30) throw new Y(N.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`);
      }
    }(this.experimentalLongPollingOptions), this.useFetchStreams = !!t.useFetchStreams;
  }
  isEqual(t) {
    return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && function(i, r) {
      return i.timeoutSeconds === r.timeoutSeconds;
    }(this.experimentalLongPollingOptions, t.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;
  }
}
class bl {
  /** @hideconstructor */
  constructor(t, e, i, r) {
    this._authCredentials = t, this._appCheckCredentials = e, this._databaseId = i, this._app = r, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new gm({}), this._settingsFrozen = !1, // A task that is assigned when the terminate() is invoked and resolved when
    // all components have shut down. Otherwise, Firestore is not terminated,
    // which can mean either the FirestoreClient is in the process of starting,
    // or restarting.
    this._terminateTask = "notTerminated";
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new Y(N.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== "notTerminated";
  }
  _setSettings(t) {
    if (this._settingsFrozen) throw new Y(N.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new gm(t), t.credentials !== void 0 && (this._authCredentials = function(i) {
      if (!i) return new jE();
      switch (i.type) {
        case "firstParty":
          return new WE(i.sessionIndex || "0", i.iamToken || null, i.authTokenFactory || null);
        case "provider":
          return i.client;
        default:
          throw new Y(N.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask;
  }
  async _restart() {
    this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated";
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(e) {
      const i = pm.get(e);
      i && (q("ComponentProvider", "Removing Datastore"), pm.delete(e), i.terminate());
    }(this), Promise.resolve();
  }
}
function BI(n, t, e, i = {}) {
  var r;
  const s = (n = yo(n, bl))._getSettings(), o = `${t}:${e}`;
  if (s.host !== "firestore.googleapis.com" && s.host !== o && Fr("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), n._setSettings(Object.assign(Object.assign({}, s), {
    host: o,
    ssl: !1
  })), i.mockUserToken) {
    let a, l;
    if (typeof i.mockUserToken == "string") a = i.mockUserToken, l = ge.MOCK_USER;
    else {
      a = bS(i.mockUserToken, (r = n._app) === null || r === void 0 ? void 0 : r.options.projectId);
      const h = i.mockUserToken.sub || i.mockUserToken.user_id;
      if (!h) throw new Y(N.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      l = new ge(h);
    }
    n._authCredentials = new GE(new b0(a, l));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mi {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(t, e, i) {
    this.converter = e, this._query = i, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = t;
  }
  withConverter(t) {
    return new mi(this.firestore, t, this._query);
  }
}
class Ke {
  /** @hideconstructor */
  constructor(t, e, i) {
    this.converter = e, this._key = i, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = t;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new si(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t) {
    return new Ke(this.firestore, t, this._key);
  }
}
class si extends mi {
  /** @hideconstructor */
  constructor(t, e, i) {
    super(t, e, M0(i)), this._path = i, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const t = this._path.popLast();
    return t.isEmpty() ? null : new Ke(
      this.firestore,
      /* converter= */
      null,
      new Z(t)
    );
  }
  withConverter(t) {
    return new si(this.firestore, t, this._path);
  }
}
function OI(n, t, ...e) {
  if (n = Or(n), T_("collection", "path", t), n instanceof bl) {
    const i = Tt.fromString(t, ...e);
    return mm(i), new si(
      n,
      /* converter= */
      null,
      i
    );
  }
  {
    if (!(n instanceof Ke || n instanceof si)) throw new Y(N.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const i = n._path.child(Tt.fromString(t, ...e));
    return mm(i), new si(
      n.firestore,
      /* converter= */
      null,
      i
    );
  }
}
function FI(n, t, ...e) {
  if (n = Or(n), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  arguments.length === 1 && (t = w0.newId()), T_("doc", "path", t), n instanceof bl) {
    const i = Tt.fromString(t, ...e);
    return fm(i), new Ke(
      n,
      /* converter= */
      null,
      new Z(i)
    );
  }
  {
    if (!(n instanceof Ke || n instanceof si)) throw new Y(N.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const i = n._path.child(Tt.fromString(t, ...e));
    return fm(i), new Ke(n.firestore, n instanceof si ? n.converter : null, new Z(i));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ym {
  constructor(t = Promise.resolve()) {
    this.Iu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Eu = !1, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.du = [], // visible for testing
    this.Au = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.Ru = !1, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.Vu = !1, // List of TimerIds to fast-forward delays for.
    this.mu = [], // Backoff timer used to schedule retries for retryable operations
    this.r_ = new o_(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.fu = () => {
      const i = Ih();
      i && q("AsyncQueue", "Visibility state changed to " + i.visibilityState), this.r_.Jo();
    }, this.gu = t;
    const e = Ih();
    e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this.fu);
  }
  get isShuttingDown() {
    return this.Eu;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(t) {
    this.enqueue(t);
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.pu(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.yu(t);
  }
  enterRestrictedMode(t) {
    if (!this.Eu) {
      this.Eu = !0, this.Vu = t || !1;
      const e = Ih();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.fu);
    }
  }
  enqueue(t) {
    if (this.pu(), this.Eu)
      return new Promise(() => {
      });
    const e = new ri();
    return this.yu(() => this.Eu && this.Vu ? Promise.resolve() : (t().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.Iu.push(t), this.wu()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async wu() {
    if (this.Iu.length !== 0) {
      try {
        await this.Iu[0](), this.Iu.shift(), this.r_.reset();
      } catch (t) {
        if (!$r(t)) throw t;
        q("AsyncQueue", "Operation failed with retryable error: " + t);
      }
      this.Iu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.r_.jo(() => this.wu());
    }
  }
  yu(t) {
    const e = this.gu.then(() => (this.Ru = !0, t().catch((i) => {
      this.Au = i, this.Ru = !1;
      const r = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(o) {
          let a = o.message || "";
          return o.stack && (a = o.stack.includes(o.message) ? o.stack : o.message + `
` + o.stack), a;
        }(i)
      );
      throw jn("INTERNAL UNHANDLED ERROR: ", r), i;
    }).then((i) => (this.Ru = !1, i))));
    return this.gu = e, e;
  }
  enqueueAfterDelay(t, e, i) {
    this.pu(), // Fast-forward delays for timerIds that have been overridden.
    this.mu.indexOf(t) > -1 && (e = 0);
    const r = zu.createAndSchedule(this, t, e, i, (s) => this.Su(s));
    return this.du.push(r), r;
  }
  pu() {
    this.Au && et();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async bu() {
    let t;
    do
      t = this.gu, await t;
    while (t !== this.gu);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Du(t) {
    for (const e of this.du) if (e.timerId === t) return !0;
    return !1;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  vu(t) {
    return this.bu().then(() => {
      this.du.sort((e, i) => e.targetTimeMs - i.targetTimeMs);
      for (const e of this.du) if (e.skipDelay(), t !== "all" && e.timerId === t) break;
      return this.bu();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Cu(t) {
    this.mu.push(t);
  }
  /** Called once a DelayedOperation is run or canceled. */
  Su(t) {
    const e = this.du.indexOf(t);
    this.du.splice(e, 1);
  }
}
class qu extends bl {
  /** @hideconstructor */
  constructor(t, e, i, r) {
    super(t, e, i, r), /**
     * Whether it's a {@link Firestore} or Firestore Lite instance.
     */
    this.type = "firestore", this._queue = new ym(), this._persistenceKey = (r == null ? void 0 : r.name) || "[DEFAULT]";
  }
  async _terminate() {
    if (this._firestoreClient) {
      const t = this._firestoreClient.terminate();
      this._queue = new ym(t), this._firestoreClient = void 0, await t;
    }
  }
}
function LI(n, t) {
  const e = typeof n == "object" ? n : RE(), i = typeof n == "string" ? n : "(default)", r = EE(e, "firestore").getImmediate({
    identifier: i
  });
  if (!r._initialized) {
    const s = vS("firestore");
    s && BI(r, ...s);
  }
  return r;
}
function S_(n) {
  if (n._terminated) throw new Y(N.FAILED_PRECONDITION, "The client has already been terminated.");
  return n._firestoreClient || NI(n), n._firestoreClient;
}
function NI(n) {
  var t, e, i;
  const r = n._freezeSettings(), s = function(a, l, h, c) {
    return new aC(a, l, h, c.host, c.ssl, c.experimentalForceLongPolling, c.experimentalAutoDetectLongPolling, A_(c.experimentalLongPollingOptions), c.useFetchStreams);
  }(n._databaseId, ((t = n._app) === null || t === void 0 ? void 0 : t.options.appId) || "", n._persistenceKey, r);
  n._componentsProvider || !((e = r.localCache) === null || e === void 0) && e._offlineComponentProvider && (!((i = r.localCache) === null || i === void 0) && i._onlineComponentProvider) && (n._componentsProvider = {
    _offline: r.localCache._offlineComponentProvider,
    _online: r.localCache._onlineComponentProvider
  }), n._firestoreClient = new II(n._authCredentials, n._appCheckCredentials, n._queue, s, n._componentsProvider && function(a) {
    const l = a == null ? void 0 : a._online.build();
    return {
      _offline: a == null ? void 0 : a._offline.build(l),
      _online: l
    };
  }(n._componentsProvider));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gr {
  /** @hideconstructor */
  constructor(t) {
    this._byteString = t;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(t) {
    try {
      return new Gr(de.fromBase64String(t));
    } catch (e) {
      throw new Y(N.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(t) {
    return new Gr(de.fromUint8Array(t));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(t) {
    return this._byteString.isEqual(t._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wu {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...t) {
    for (let e = 0; e < t.length; ++e) if (t[e].length === 0) throw new Y(N.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ce(t);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class E_ {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(t) {
    this._methodName = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yu {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(t, e) {
    if (!isFinite(t) || t < -90 || t > 90) throw new Y(N.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t);
    if (!isFinite(e) || e < -180 || e > 180) throw new Y(N.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t, this._long = e;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(t) {
    return lt(this._lat, t._lat) || lt(this._long, t._long);
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xu {
  /**
   * @private
   * @internal
   */
  constructor(t) {
    this._values = (t || []).map((e) => e);
  }
  /**
   * Returns a copy of the raw number array form of the vector.
   */
  toArray() {
    return this._values.map((t) => t);
  }
  /**
   * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.
   */
  isEqual(t) {
    return function(i, r) {
      if (i.length !== r.length) return !1;
      for (let s = 0; s < i.length; ++s) if (i[s] !== r[s]) return !1;
      return !0;
    }(this._values, t._values);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UI = /^__.*__$/;
class zI {
  constructor(t, e, i) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = i;
  }
  toMutation(t, e) {
    return this.fieldMask !== null ? new Zi(t, this.data, this.fieldMask, e, this.fieldTransforms) : new vo(t, this.data, e, this.fieldTransforms);
  }
}
function C_(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw et();
  }
}
class Ku {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(t, e, i, r, s, o) {
    this.settings = t, this.databaseId = e, this.serializer = i, this.ignoreUndefinedProperties = r, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    s === void 0 && this.Fu(), this.fieldTransforms = s || [], this.fieldMask = o || [];
  }
  get path() {
    return this.settings.path;
  }
  get Mu() {
    return this.settings.Mu;
  }
  /** Returns a new context with the specified settings overwritten. */
  xu(t) {
    return new Ku(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Ou(t) {
    var e;
    const i = (e = this.path) === null || e === void 0 ? void 0 : e.child(t), r = this.xu({
      path: i,
      Nu: !1
    });
    return r.Lu(t), r;
  }
  Bu(t) {
    var e;
    const i = (e = this.path) === null || e === void 0 ? void 0 : e.child(t), r = this.xu({
      path: i,
      Nu: !1
    });
    return r.Fu(), r;
  }
  ku(t) {
    return this.xu({
      path: void 0,
      Nu: !0
    });
  }
  qu(t) {
    return qa(t, this.settings.methodName, this.settings.Qu || !1, this.path, this.settings.Ku);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(t) {
    return this.fieldMask.find((e) => t.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t.isPrefixOf(e.field)) !== void 0;
  }
  Fu() {
    if (this.path) for (let t = 0; t < this.path.length; t++) this.Lu(this.path.get(t));
  }
  Lu(t) {
    if (t.length === 0) throw this.qu("Document fields must not be empty");
    if (C_(this.Mu) && UI.test(t)) throw this.qu('Document fields cannot begin and end with "__"');
  }
}
class jI {
  constructor(t, e, i) {
    this.databaseId = t, this.ignoreUndefinedProperties = e, this.serializer = i || yl(t);
  }
  /** Creates a new top-level parse context. */
  $u(t, e, i, r = !1) {
    return new Ku({
      Mu: t,
      methodName: e,
      Ku: i,
      path: ce.emptyPath(),
      Nu: !1,
      Qu: r
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
}
function P_(n) {
  const t = n._freezeSettings(), e = yl(n._databaseId);
  return new jI(n._databaseId, !!t.ignoreUndefinedProperties, e);
}
function GI(n, t, e, i, r, s = {}) {
  const o = n.$u(s.merge || s.mergeFields ? 2 : 0, t, e, r);
  k_("Data must be an object, but it was:", o, i);
  const a = I_(i, o);
  let l, h;
  if (s.merge) l = new un(o.fieldMask), h = o.fieldTransforms;
  else if (s.mergeFields) {
    const c = [];
    for (const p of s.mergeFields) {
      const f = qI(t, p, e);
      if (!o.contains(f)) throw new Y(N.INVALID_ARGUMENT, `Field '${f}' is specified in your field mask but missing from your input data.`);
      YI(c, f) || c.push(f);
    }
    l = new un(c), h = o.fieldTransforms.filter((p) => l.covers(p.field));
  } else l = null, h = o.fieldTransforms;
  return new zI(new en(a), l, h);
}
function HI(n, t, e, i = !1) {
  return Qu(e, n.$u(i ? 4 : 3, t));
}
function Qu(n, t) {
  if (R_(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    n = Or(n)
  )) return k_("Unsupported field value:", t, n), I_(n, t);
  if (n instanceof E_)
    return function(i, r) {
      if (!C_(r.Mu)) throw r.qu(`${i._methodName}() can only be used with update() and set()`);
      if (!r.path) throw r.qu(`${i._methodName}() is not currently supported inside arrays`);
      const s = i._toFieldTransform(r);
      s && r.fieldTransforms.push(s);
    }(n, t), null;
  if (n === void 0 && t.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    t.path && t.fieldMask.push(t.path), n instanceof Array
  ) {
    if (t.settings.Nu && t.Mu !== 4) throw t.qu("Nested arrays are not supported");
    return function(i, r) {
      const s = [];
      let o = 0;
      for (const a of i) {
        let l = Qu(a, r.ku(o));
        l == null && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (l = {
          nullValue: "NULL_VALUE"
        }), s.push(l), o++;
      }
      return {
        arrayValue: {
          values: s
        }
      };
    }(n, t);
  }
  return function(i, r) {
    if ((i = Or(i)) === null) return {
      nullValue: "NULL_VALUE"
    };
    if (typeof i == "number") return IC(r.serializer, i);
    if (typeof i == "boolean") return {
      booleanValue: i
    };
    if (typeof i == "string") return {
      stringValue: i
    };
    if (i instanceof Date) {
      const s = Zt.fromDate(i);
      return {
        timestampValue: za(r.serializer, s)
      };
    }
    if (i instanceof Zt) {
      const s = new Zt(i.seconds, 1e3 * Math.floor(i.nanoseconds / 1e3));
      return {
        timestampValue: za(r.serializer, s)
      };
    }
    if (i instanceof Yu) return {
      geoPointValue: {
        latitude: i.latitude,
        longitude: i.longitude
      }
    };
    if (i instanceof Gr) return {
      bytesValue: Q0(r.serializer, i._byteString)
    };
    if (i instanceof Ke) {
      const s = r.databaseId, o = i.firestore._databaseId;
      if (!o.isEqual(s)) throw r.qu(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`);
      return {
        referenceValue: Vu(i.firestore._databaseId || r.databaseId, i._key.path)
      };
    }
    if (i instanceof Xu)
      return function(o, a) {
        return {
          mapValue: {
            fields: {
              __type__: {
                stringValue: "__vector__"
              },
              value: {
                arrayValue: {
                  values: o.toArray().map((l) => {
                    if (typeof l != "number") throw a.qu("VectorValues must only contain numeric values.");
                    return Ru(a.serializer, l);
                  })
                }
              }
            }
          }
        };
      }(i, r);
    throw r.qu(`Unsupported field value: ${xl(i)}`);
  }(n, t);
}
function I_(n, t) {
  const e = {};
  return A0(n) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    t.path && t.path.length > 0 && t.fieldMask.push(t.path)
  ) : Qi(n, (i, r) => {
    const s = Qu(r, t.Ou(i));
    s != null && (e[i] = s);
  }), {
    mapValue: {
      fields: e
    }
  };
}
function R_(n) {
  return !(typeof n != "object" || n === null || n instanceof Array || n instanceof Date || n instanceof Zt || n instanceof Yu || n instanceof Gr || n instanceof Ke || n instanceof E_ || n instanceof Xu);
}
function k_(n, t, e) {
  if (!R_(e) || !function(r) {
    return typeof r == "object" && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null);
  }(e)) {
    const i = xl(e);
    throw i === "an object" ? t.qu(n + " a custom object") : t.qu(n + " " + i);
  }
}
function qI(n, t, e) {
  if (
    // If required, replace the FieldPath Compat class with the firestore-exp
    // FieldPath.
    (t = Or(t)) instanceof Wu
  ) return t._internalPath;
  if (typeof t == "string") return M_(n, t);
  throw qa(
    "Field path arguments must be of type string or ",
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    e
  );
}
const WI = new RegExp("[~\\*/\\[\\]]");
function M_(n, t, e) {
  if (t.search(WI) >= 0) throw qa(
    `Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    e
  );
  try {
    return new Wu(...t.split("."))._internalPath;
  } catch {
    throw qa(
      `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      e
    );
  }
}
function qa(n, t, e, i, r) {
  const s = i && !i.isEmpty(), o = r !== void 0;
  let a = `Function ${t}() called with invalid data`;
  e && (a += " (via `toFirestore()`)"), a += ". ";
  let l = "";
  return (s || o) && (l += " (found", s && (l += ` in field ${i}`), o && (l += ` in document ${r}`), l += ")"), new Y(N.INVALID_ARGUMENT, a + n + l);
}
function YI(n, t) {
  return n.some((e) => e.isEqual(t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class V_ {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(t, e, i, r, s) {
    this._firestore = t, this._userDataWriter = e, this._key = i, this._document = r, this._converter = s;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new Ke(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const t = new XI(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(t);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(t) {
    if (this._document) {
      const e = this._document.data.field(Ju("DocumentSnapshot.get", t));
      if (e !== null) return this._userDataWriter.convertValue(e);
    }
  }
}
class XI extends V_ {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
function Ju(n, t) {
  return typeof t == "string" ? M_(n, t) : t instanceof Wu ? t._internalPath : t._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function KI(n) {
  if (n.limitType === "L" && n.explicitOrderBy.length === 0) throw new Y(N.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class Zu {
}
class $u extends Zu {
}
function QI(n, t, ...e) {
  let i = [];
  t instanceof Zu && i.push(t), i = i.concat(e), function(s) {
    const o = s.filter((l) => l instanceof ed).length, a = s.filter((l) => l instanceof td).length;
    if (o > 1 || o > 0 && a > 0) throw new Y(N.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(i);
  for (const r of i) n = r._apply(n);
  return n;
}
class td extends $u {
  /**
   * @internal
   */
  constructor(t, e, i) {
    super(), this._field = t, this._op = e, this._value = i, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(t, e, i) {
    return new td(t, e, i);
  }
  _apply(t) {
    const e = this._parse(t);
    return D_(t._query, e), new mi(t.firestore, t.converter, kc(t._query, e));
  }
  _parse(t) {
    const e = P_(t.firestore);
    return function(s, o, a, l, h, c, p) {
      let f;
      if (h.isKeyField()) {
        if (c === "array-contains" || c === "array-contains-any") throw new Y(N.INVALID_ARGUMENT, `Invalid Query. You can't perform '${c}' queries on documentId().`);
        if (c === "in" || c === "not-in") {
          vm(p, c);
          const u = [];
          for (const m of p) u.push(_m(l, s, m));
          f = {
            arrayValue: {
              values: u
            }
          };
        } else f = _m(l, s, p);
      } else c !== "in" && c !== "not-in" && c !== "array-contains-any" || vm(p, c), f = HI(
        a,
        o,
        p,
        /* allowArrays= */
        c === "in" || c === "not-in"
      );
      return qt.create(h, c, f);
    }(t._query, "where", e, t.firestore._databaseId, this._field, this._op, this._value);
  }
}
class ed extends Zu {
  /**
   * @internal
   */
  constructor(t, e) {
    super(), this.type = t, this._queryConstraints = e;
  }
  static _create(t, e) {
    return new ed(t, e);
  }
  _parse(t) {
    const e = this._queryConstraints.map((i) => i._parse(t)).filter((i) => i.getFilters().length > 0);
    return e.length === 1 ? e[0] : dn.create(e, this._getOperator());
  }
  _apply(t) {
    const e = this._parse(t);
    return e.getFilters().length === 0 ? t : (function(r, s) {
      let o = r;
      const a = s.getFlattenedFilters();
      for (const l of a) D_(o, l), o = kc(o, l);
    }(t._query, e), new mi(t.firestore, t.converter, kc(t._query, e)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === "and" ? "and" : "or";
  }
}
class nd extends $u {
  /**
   * @internal
   */
  constructor(t, e) {
    super(), this._field = t, this._direction = e, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(t, e) {
    return new nd(t, e);
  }
  _apply(t) {
    const e = function(r, s, o) {
      if (r.startAt !== null) throw new Y(N.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (r.endAt !== null) throw new Y(N.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      return new fo(s, o);
    }(t._query, this._field, this._direction);
    return new mi(t.firestore, t.converter, function(r, s) {
      const o = r.explicitOrderBy.concat([s]);
      return new ts(r.path, r.collectionGroup, o, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt);
    }(t._query, e));
  }
}
function JI(n, t = "asc") {
  const e = t, i = Ju("orderBy", n);
  return nd._create(i, e);
}
class id extends $u {
  /**
   * @internal
   */
  constructor(t, e, i) {
    super(), this.type = t, this._limit = e, this._limitType = i;
  }
  static _create(t, e, i) {
    return new id(t, e, i);
  }
  _apply(t) {
    return new mi(t.firestore, t.converter, La(t._query, this._limit, this._limitType));
  }
}
function ZI(n) {
  return id._create(
    "limit",
    n,
    "F"
    /* LimitType.First */
  );
}
function _m(n, t, e) {
  if (typeof (e = Or(e)) == "string") {
    if (e === "") throw new Y(N.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!V0(t) && e.indexOf("/") !== -1) throw new Y(N.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${e}' contains a '/' character.`);
    const i = t.path.child(Tt.fromString(e));
    if (!Z.isDocumentKey(i)) throw new Y(N.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${i}' is not because it has an odd number of segments (${i.length}).`);
    return Nf(n, new Z(i));
  }
  if (e instanceof Ke) return Nf(n, e._key);
  throw new Y(N.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${xl(e)}.`);
}
function vm(n, t) {
  if (!Array.isArray(n) || n.length === 0) throw new Y(N.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`);
}
function D_(n, t) {
  const e = function(r, s) {
    for (const o of r) for (const a of o.getFlattenedFilters()) if (s.indexOf(a.op) >= 0) return a.op;
    return null;
  }(n.filters, function(r) {
    switch (r) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(t.op));
  if (e !== null)
    throw e === t.op ? new Y(N.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new Y(N.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${e.toString()}' filters.`);
}
class $I {
  convertValue(t, e = "none") {
    switch (di(t)) {
      case 0:
        return null;
      case 1:
        return t.booleanValue;
      case 2:
        return zt(t.integerValue || t.doubleValue);
      case 3:
        return this.convertTimestamp(t.timestampValue);
      case 4:
        return this.convertServerTimestamp(t, e);
      case 5:
        return t.stringValue;
      case 6:
        return this.convertBytes(ui(t.bytesValue));
      case 7:
        return this.convertReference(t.referenceValue);
      case 8:
        return this.convertGeoPoint(t.geoPointValue);
      case 9:
        return this.convertArray(t.arrayValue, e);
      case 11:
        return this.convertObject(t.mapValue, e);
      case 10:
        return this.convertVectorValue(t.mapValue);
      default:
        throw et();
    }
  }
  convertObject(t, e) {
    return this.convertObjectMap(t.fields, e);
  }
  /**
   * @internal
   */
  convertObjectMap(t, e = "none") {
    const i = {};
    return Qi(t, (r, s) => {
      i[r] = this.convertValue(s, e);
    }), i;
  }
  /**
   * @internal
   */
  convertVectorValue(t) {
    var e, i, r;
    const s = (r = (i = (e = t.fields) === null || e === void 0 ? void 0 : e.value.arrayValue) === null || i === void 0 ? void 0 : i.values) === null || r === void 0 ? void 0 : r.map((o) => zt(o.doubleValue));
    return new Xu(s);
  }
  convertGeoPoint(t) {
    return new Yu(zt(t.latitude), zt(t.longitude));
  }
  convertArray(t, e) {
    return (t.values || []).map((i) => this.convertValue(i, e));
  }
  convertServerTimestamp(t, e) {
    switch (e) {
      case "previous":
        const i = ul(t);
        return i == null ? null : this.convertValue(i, e);
      case "estimate":
        return this.convertTimestamp(co(t));
      default:
        return null;
    }
  }
  convertTimestamp(t) {
    const e = ci(t);
    return new Zt(e.seconds, e.nanos);
  }
  convertDocumentKey(t, e) {
    const i = Tt.fromString(t);
    yt(n_(i));
    const r = new uo(i.get(1), i.get(3)), s = new Z(i.popFirst(5));
    return r.isEqual(e) || // TODO(b/64130202): Somehow support foreign references.
    jn(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), s;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tR(n, t, e) {
  let i;
  return i = n ? e && (e.merge || e.mergeFields) ? n.toFirestore(t, e) : n.toFirestore(t) : t, i;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class na {
  /** @hideconstructor */
  constructor(t, e) {
    this.hasPendingWrites = t, this.fromCache = e;
  }
  /**
   * Returns true if this `SnapshotMetadata` is equal to the provided one.
   *
   * @param other - The `SnapshotMetadata` to compare against.
   * @returns true if this `SnapshotMetadata` is equal to the provided one.
   */
  isEqual(t) {
    return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;
  }
}
class eR extends V_ {
  /** @hideconstructor protected */
  constructor(t, e, i, r, s, o) {
    super(t, e, i, r, o), this._firestore = t, this._firestoreImpl = t, this.metadata = s;
  }
  /**
   * Returns whether or not the data exists. True if the document exists.
   */
  exists() {
    return super.exists();
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document or `undefined` if
   * the document doesn't exist.
   */
  data(t = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new ga(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(e, t);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * By default, a `serverTimestamp()` that has not yet been set to
   * its final value will be returned as `null`. You can override this by
   * passing an options object.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @param options - An options object to configure how the field is retrieved
   * from the snapshot (for example the desired behavior for server timestamps
   * that have not yet been set to their final value).
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(t, e = {}) {
    if (this._document) {
      const i = this._document.data.field(Ju("DocumentSnapshot.get", t));
      if (i !== null) return this._userDataWriter.convertValue(i, e.serverTimestamps);
    }
  }
}
class ga extends eR {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @override
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document.
   */
  data(t = {}) {
    return super.data(t);
  }
}
class nR {
  /** @hideconstructor */
  constructor(t, e, i, r) {
    this._firestore = t, this._userDataWriter = e, this._snapshot = r, this.metadata = new na(r.hasPendingWrites, r.fromCache), this.query = i;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    const t = [];
    return this.forEach((e) => t.push(e)), t;
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this._snapshot.docs.size;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.size === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(t, e) {
    this._snapshot.docs.forEach((i) => {
      t.call(e, new ga(this._firestore, this._userDataWriter, i.key, i, new na(this._snapshot.mutatedKeys.has(i.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  /**
   * Returns an array of the documents changes since the last snapshot. If this
   * is the first snapshot, all documents will be in the list as 'added'
   * changes.
   *
   * @param options - `SnapshotListenOptions` that control whether metadata-only
   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger
   * snapshot events.
   */
  docChanges(t = {}) {
    const e = !!t.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges) throw new Y(N.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = /** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */
    function(r, s) {
      if (r._snapshot.oldDocs.isEmpty()) {
        let o = 0;
        return r._snapshot.docChanges.map((a) => {
          const l = new ga(r._firestore, r._userDataWriter, a.doc.key, a.doc, new na(r._snapshot.mutatedKeys.has(a.doc.key), r._snapshot.fromCache), r.query.converter);
          return a.doc, {
            type: "added",
            doc: l,
            oldIndex: -1,
            newIndex: o++
          };
        });
      }
      {
        let o = r._snapshot.oldDocs;
        return r._snapshot.docChanges.filter((a) => s || a.type !== 3).map((a) => {
          const l = new ga(r._firestore, r._userDataWriter, a.doc.key, a.doc, new na(r._snapshot.mutatedKeys.has(a.doc.key), r._snapshot.fromCache), r.query.converter);
          let h = -1, c = -1;
          return a.type !== 0 && (h = o.indexOf(a.doc.key), o = o.delete(a.doc.key)), a.type !== 1 && (o = o.add(a.doc), c = o.indexOf(a.doc.key)), {
            type: iR(a.type),
            doc: l,
            oldIndex: h,
            newIndex: c
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
}
function iR(n) {
  switch (n) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return et();
  }
}
class rR extends $I {
  constructor(t) {
    super(), this.firestore = t;
  }
  convertBytes(t) {
    return new Gr(t);
  }
  convertReference(t) {
    const e = this.convertDocumentKey(t, this.firestore._databaseId);
    return new Ke(
      this.firestore,
      /* converter= */
      null,
      e
    );
  }
}
function sR(n) {
  n = yo(n, mi);
  const t = yo(n.firestore, qu), e = S_(t), i = new rR(t);
  return KI(n._query), VI(e, n._query).then((r) => new nR(t, i, n, r));
}
function oR(n, t, e) {
  n = yo(n, Ke);
  const i = yo(n.firestore, qu), r = tR(n.converter, t, e);
  return aR(i, [GI(P_(i), "setDoc", n._key, r, n.converter !== null, e).toMutation(n._key, Ln.none())]);
}
function aR(n, t) {
  return function(i, r) {
    const s = new ri();
    return i.asyncQueue.enqueueAndForget(async () => vI(await kI(i), r, s)), s.promise;
  }(S_(n), t);
}
(function(t, e = !0) {
  (function(r) {
    Jr = r;
  })(IE), Ba(new ao("firestore", (i, { instanceIdentifier: r, options: s }) => {
    const o = i.getProvider("app").getImmediate(), a = new qu(new HE(i.getProvider("auth-internal")), new XE(i.getProvider("app-check-internal")), function(h, c) {
      if (!Object.prototype.hasOwnProperty.apply(h.options, ["projectId"])) throw new Y(N.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new uo(h.options.projectId, c);
    }(o, r), o);
    return s = Object.assign({
      useFetchStreams: e
    }, s), a._setSettings(s), a;
  }, "PUBLIC").setMultipleInstances(!0)), Sr(Vf, "4.7.5", t), // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation
  Sr(Vf, "4.7.5", "esm2017");
})();
const B_ = "couplesRun_nickname", O_ = "couplesRun_playerId", F_ = "couplesRun_highScore";
let rd;
const L_ = () => localStorage.getItem(B_) ?? "", lR = (n) => localStorage.setItem(B_, n) ?? "", sd = () => localStorage.getItem(O_) ?? "", hR = (n) => localStorage.setItem(O_, n), cR = async (n) => {
  let t = sd();
  t || (t = window.crypto.randomUUID(), hR(t));
  const e = Uc();
  return n <= e.amount ? !0 : (U_({ amount: n, stored: !1 }), await N_());
}, uR = () => {
  const n = d0({
    apiKey: tt.fireBaseApiKey,
    authDomain: tt.fireBaseAuthDomain,
    projectId: tt.fireBaseProjectId,
    storageBucket: tt.fireBaseStorageBucket,
    messagingSenderId: tt.fireBaseMessagingSenderId,
    appId: tt.fireBaseAppId
  });
  rd = LI(n), setInterval(() => N_(), 5e3);
}, dR = async () => {
  if (!navigator.onLine) return [];
  try {
    const n = QI(
      OI(rd, "scores"),
      JI("score", "desc"),
      ZI(10)
    ), t = await sR(n), e = [];
    return t.forEach((i) => {
      const r = i.data();
      e.push({
        id: i.id,
        nickname: r.nickname,
        score: r.score
      });
    }), e;
  } catch (n) {
    return console.error("An error occurred while fetching the leaderboard", n), [];
  }
}, N_ = async () => {
  if (!navigator.onLine) return !1;
  const { amount: n, stored: t } = Uc();
  if (n === 0 || t) return !0;
  try {
    await oR(
      FI(rd, "scores", sd()),
      {
        nickname: L_(),
        score: n,
        timestamp: Date.now()
      },
      { merge: !0 }
    );
  } catch (e) {
    return console.error("An error occurred while saving to firestore", e), !1;
  }
  return Uc().amount === n && U_({ amount: n, stored: !0 }), !0;
}, Uc = () => {
  const n = localStorage.getItem(F_);
  return n ? JSON.parse(n) : { amount: 0, stored: !1 };
}, U_ = (n) => localStorage.setItem(F_, JSON.stringify(n));
class pR extends Je {
  constructor() {
    super({
      label: "form-screen",
      alpha: 0
    });
    vt(this, "_accepted", !1);
    vt(this, "_nickname", L_());
    this.addComponent(
      new Qt({
        label: "text",
        text: "Enter your nickname:",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        landscape: {
          position: { x: 20, y: 44 },
          anchor: { x: 0, y: 0.5 }
        },
        portrait: {
          position: { x: 20, y: 20 },
          anchor: 0
        }
      })
    ), this.addComponent(
      new bT({
        background: "input.png",
        fontFamily: "Arial, sans-serif",
        fontSize: 24,
        label: "nickname",
        textColor: 0,
        text: this._nickname,
        maxLength: 10,
        padding: 15,
        landscape: {
          position: { x: 520, y: 20 }
        },
        portrait: {
          position: { x: 20, y: 80 }
        },
        onChange: (s) => {
          var o;
          this._nickname = s, r.enabled = !!((o = this._nickname) != null && o.trim()) && this._accepted, r.interactive = r.enabled;
        }
      })
    );
    const e = this.addComponent(
      new Le({
        label: "checkbox",
        resource: "checkbox-off.png",
        interactive: !0,
        cursor: "pointer",
        landscape: {
          position: { x: 20, y: 120 }
        },
        portrait: {
          position: { x: 20, y: 180 }
        },
        onClick: () => {
          var s;
          this._accepted = !this._accepted, r.enabled = !!((s = this._nickname) != null && s.trim()) && this._accepted, r.interactive = r.enabled, e.texture = this._accepted ? "checkbox-on.png" : "checkbox-off.png";
        }
      })
    );
    this.addComponent(
      new Qt({
        label: "agreement",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        text: "",
        lineHeight: 40,
        landscape: {
          position: { x: 100, y: 125 },
          text: "By accepting you agree to the privacy policy"
        },
        portrait: {
          position: { x: 100, y: 185 },
          text: `By accepting you agree to
the privacy policy`
        }
      })
    );
    const i = this.addComponent(
      new Je({
        label: "buttons",
        landscape: {
          y: 250
        },
        portrait: {
          y: 340
        },
        horizontalAlignment: "center",
        width: 650
      })
    );
    i.addComponent(
      new Qy({
        label: "policy-button",
        url: tt.privacyPolicyUrl,
        resource: "policy-button.png",
        hoverResource: "policy-button-hover.png",
        disabledResource: "policy-button.png",
        interactive: !0,
        cursor: "pointer"
      })
    );
    const r = i.addComponent(
      new ll({
        label: "play-button",
        resource: "play-button.png",
        hoverResource: "play-button-hover.png",
        disabledResource: "play-button-disabled.png",
        position: { x: 350, y: 0 },
        cursor: "pointer",
        onClick: async () => {
          r.interactive = !1, lR(this._nickname), this.parent.goToGame();
        }
      })
    );
    r.enabled = !1, this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    });
  }
}
class fR extends Kr {
  async init() {
    this.alpha = 0, this.addComponent(
      new Zy({
        label: "city-bg",
        resource: "city-bg.png"
      })
    ), await Promise.all([
      this.animate({ from: { alpha: 0 }, to: { alpha: 1 }, duration: 2 }),
      xu(tt.sounds.menuLoop, {
        toVolume: 0.3,
        fadeDuration: 0.5,
        loop: !0
      })
    ]), this.addComponent(new rS());
  }
  showCharacterSelectionScreen() {
    this.components[1].destroy(), this.addComponent(new hS());
  }
  showFormScreen() {
    this.components[1].destroy(), this.addComponent(new pR());
  }
  async goToGame() {
    await Promise.all([
      bu(tt.sounds.menuLoop, { fadeDuration: 2 }),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 2
      })
    ]), Pe(tt.signals.goToGame);
  }
}
class mR extends Jy {
  constructor() {
    super({
      label: "background",
      resource: "city-bg.png"
    }), this._registerToSignal(tt.signals.moveScreen, this._move);
  }
  _move(t) {
    this.tilePosition.x = -t;
  }
}
class gR extends Je {
  constructor() {
    super({
      label: "info",
      position: { x: 20, y: 20 }
    });
    vt(this, "_totalLifePoints");
    let e = this.addComponent(
      new Qt({
        label: "life-points-indicator",
        text: "Life Points:",
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: 0, y: 3 }
      })
    ).width + 10;
    for (let i = 0; i < tt.lifePoints; i++)
      e += this.addComponent(
        new Le({
          label: `life-point-${i}`,
          resource: "life.png",
          position: { x: e, y: 0 }
        })
      ).width + 5;
    e += this.addComponent(
      new Le({
        label: "separator",
        resource: "separator.png",
        position: { x: e + 10, y: 0 }
      })
    ).width + 25, e += this.addComponent(
      new Qt({
        label: "score-indicator",
        text: "Score:",
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: e, y: 3 }
      })
    ).width + 10, this.addComponent(
      new Qt({
        label: "score",
        text: pt.score.toString(),
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: e, y: 3 },
        bitmap: !0
      })
    ), this._totalLifePoints = tt.lifePoints, this._registerToSignal(
      tt.signals.loseLifePoints,
      this._removeLifePoints
    ), this._registerToSignal(tt.signals.updateScore, this._updateScore);
  }
  get _score() {
    return this.components[this.components.length - 1];
  }
  async _removeLifePoints(e) {
    for (let i = this.components.length - 1; i >= 0 && e > 0; i--)
      if (this.components[i].label.startsWith("life-point-") && (this.removeComponent(this.components[i]), i++, this._totalLifePoints--, e--, this._totalLifePoints === 0)) {
        pt.started = !1, bu(tt.sounds.mainLoop, { fadeDuration: 0.5 }), Ki(tt.sounds.gameOver), await this.delay(4), Pe(tt.signals.gameOver);
        break;
      }
  }
  _updateScore() {
    this._score.text = pt.score.toString();
  }
}
const kh = {
  run: (n, t) => `${n}/run/${n}-run-${t % 8 + 1}.png`,
  jump: (n, t) => t <= 6 ? `${n}/${n}-jump.png` : `${n}/${n}-idle.png`,
  idle: (n, t) => `${n}/${n}-idle.png`
}, yR = 5;
class wl extends Le {
  constructor(e) {
    super({
      label: "character",
      resource: kh.idle(e, 0),
      scale: { x: 2, y: 2 },
      position: { x: 130, y: -100 }
    });
    vt(this, "_resourceType");
    vt(this, "_moveFrame", 0);
    vt(this, "_moveSprite", 0);
    vt(this, "_moveState", "idle");
    vt(this, "_onGround", !1);
    vt(this, "_currentJump", 0);
    vt(this, "_pressing", !1);
    vt(this, "_pressed", !1);
    vt(this, "_nextIncreaseSpeedMilestone", 0);
    vt(this, "_canDamage", !0);
    this._resourceType = e, sl({
      target: this,
      rectangle: {
        x: this.x + 49,
        y: this.y + 40,
        width: 46,
        height: 64
      },
      movement: {
        linearMovement: {
          velocity: { x: 0, y: 0 }
        }
      },
      onUpdatePosition: this._updatePosition.bind(this)
    });
  }
  jump() {
    this._canJump() && (this._currentJump++, this._changeState("jump"));
  }
  press() {
    !this.hasPressAndRelease || !this._canJump() || (this._pressing = !0, this._setVelocity());
  }
  release() {
    !this.hasPressAndRelease || !this._pressing || !pt.started || (this._pressing = !1, this._pressed = !0, this._currentJump++, this._changeState("jump"));
  }
  async damage() {
    if (!this._canDamage || !pt.started) return;
    this._canDamage = !1, Ki(tt.sounds.playerHit, { volume: 2 }), Pe(tt.signals.loseLifePoints, 1);
    const e = this.tint;
    await this.animate({
      from: { tint: 16763904 },
      to: { tint: 16711680 },
      duration: 0.2,
      repeat: 10,
      revert: !0
    }), this.tint = e, this._canDamage = !0;
  }
  _onTick() {
    pt.started && (this._moveState === "idle" && this._changeState("run"), this._moveFrame++, this._moveFrame % yR === 0 && (this._moveFrame = 0, this._moveSprite++, this.texture = kh[this._moveState](
      this._resourceType,
      this._moveSprite
    )));
  }
  _changeState(e) {
    this._moveState = e, this._moveFrame = 0, this._moveSprite = 0, this.texture = kh[this._moveState](
      this._resourceType,
      this._moveSprite + 1
    ), this._setVelocity();
  }
  _updatePosition(e, i, r) {
    if (!(!pt.started && this._moveState !== "idle")) {
      if (this.x = e - 49, this.y = i - 40, this._onGround = r, this.y > st.screen.height + 100) {
        Pe(tt.signals.loseLifePoints, tt.lifePoints);
        return;
      }
      Pe(tt.signals.moveScreen, this.x - 130), r && this._moveState !== "run" && pt.started && (this._pressed = !1, this._currentJump = 0, this._changeState("run")), this._canIncreaseSpeed() && (this._nextIncreaseSpeedMilestone > 0 && pt.speed++, this._nextIncreaseSpeedMilestone = this.x + this._increaseSpeedMilestone);
    }
  }
  _canIncreaseSpeed() {
    return this.x >= this._nextIncreaseSpeedMilestone;
  }
  _canJump() {
    return pt.started ? this._moveState === "jump" && this._currentJump < this._totalAllowedJumps ? !0 : this._moveState === "run" && this._onGround : !1;
  }
  _setVelocity() {
    const { x: e, y: i } = this._getNewVelocity();
    vu(this, {
      linearMovement: {
        velocity: { x: e, y: i }
      }
    });
  }
  _getNewVelocity() {
    return this._moveState === "jump" ? {
      x: pt.speed,
      y: this._pressed ? -15 : -10
    } : this._moveState === "run" ? {
      x: this._pressing ? pt.speed / 2 : pt.speed,
      y: 0
    } : { x: 0, y: 0 };
  }
}
class _R extends Le {
  constructor(t, e) {
    super({
      label: `drink-${t.x}-${t.y}`,
      resource: "drink.png",
      position: t,
      scale: { x: 3, y: 3 }
    }), sl({
      target: this,
      rectangle: {
        x: e + this.x,
        y: this.y,
        width: this.width,
        height: this.height
      },
      onCollision: async (i) => {
        pt.started && i instanceof wl && (pt.score += 10, Pe(tt.signals.updateScore), Ki(tt.sounds.coin, { volume: 2 }), this.destroy());
      }
    }), this.animate({
      from: { y: this.y },
      to: { y: this.y - 5 },
      duration: 1,
      repeat: -1,
      revert: !0
    });
  }
}
const vR = 5;
class xR extends Le {
  constructor(e, i) {
    super({
      label: `position-${e.x}-${e.y}`,
      resource: "zombie/walk/zombie-walk-1.png",
      position: e,
      scale: { x: 0.2, y: 0.2 }
    });
    vt(this, "_started", !1);
    vt(this, "_distance", 0);
    vt(this, "_moveFrame", 0);
    vt(this, "_moveSprite", 0);
    vt(this, "_acceleration", 0);
    this._distance = i, sl({
      target: this,
      rectangle: {
        x: this._distance + this.x,
        y: this.y,
        width: this.width,
        height: this.height
      },
      onUpdatePosition: this._updatePosition.bind(this),
      onCollision: this._onCollision.bind(this)
    }), this._registerToSignal(tt.signals.moveScreen, this._onMoveScreen);
  }
  _onTick() {
    !this._started || !pt.started || (this.x + this.width >= 0 ? yf(this, -1, 0) : (this._acceleration++, yf(this, 0, this._acceleration)), this._moveFrame++, this._moveFrame % vR === 0 && (this._moveFrame = 0, this._moveSprite++, this.texture = `zombie/walk/zombie-walk-${this._moveSprite % 10 + 1}.png`));
  }
  _updatePosition(e, i) {
    this.x = e - this._distance, this.y = i;
  }
  _onCollision(e) {
    pt.started && e instanceof wl && e.damage();
  }
  _onMoveScreen(e) {
    pt.started && e + st.screen.width >= this._distance + this.x && (this._started = !0, vu(this, {
      linearMovement: {
        velocity: { x: -1, y: 0 }
      }
    }), this._unregisterFromSignal(tt.signals.moveScreen));
  }
}
class xm extends Je {
  constructor(e, i, r) {
    super({
      label: `platform-${r}`,
      position: { x: r, y: 0 }
    });
    vt(this, "_topOffset", 0);
    this._topOffset = (8 - e) * 32;
    let s = this._topOffset;
    s += this.addComponent(
      new ro({
        label: "platform-top",
        resource: "platform-top.png",
        width: i,
        position: { x: 0, y: s }
      })
    ).height;
    for (let o = 0; o < e; o++)
      s += this.addComponent(
        new ro({
          label: `platform-middle-${o}`,
          resource: "platform-middle.png",
          width: i,
          position: { x: 0, y: s }
        })
      ).height;
    sl({
      target: this,
      rectangle: {
        x: this.x,
        y: this.components[0].position.y + 4,
        width: this.width,
        height: this.height - 4
      },
      surface: !0
    }), this._createDrinks(r), this._createZombies(r);
  }
  _createDrinks(e) {
    let i = e === 0 ? 200 : 0;
    const r = 37, s = 49, o = 5, a = 5;
    for (; i + r <= this.width; ) {
      i += Kn(0, this.width - r);
      const l = this._topOffset - s - Kn(0, o) * s, h = Kn(0, a);
      for (let c = 0; c < h && i + r <= this.width; c++)
        this.addComponent(new _R({ x: i, y: l }, e)), i += r;
      i += 20;
    }
  }
  _createZombies(e) {
    if (e === 0) return;
    const i = 40, r = 61.6;
    let s = Kn(0, 1e3);
    const o = this._topOffset - r;
    for (; s + i <= this.width; )
      this.addComponent(new xR({ x: s, y: o }, e)), s += 300 + Kn(0, this.width - i);
  }
}
class bR extends wl {
  constructor() {
    super("girl");
  }
  get hasPressAndRelease() {
    return !0;
  }
  get _increaseSpeedMilestone() {
    return 2e4;
  }
  get _totalAllowedJumps() {
    return 1;
  }
}
class wR extends wl {
  constructor() {
    super("boy");
  }
  get hasPressAndRelease() {
    return !1;
  }
  get _increaseSpeedMilestone() {
    return 1e4;
  }
  get _totalAllowedJumps() {
    return 2;
  }
}
class AR extends Je {
  constructor() {
    super({
      label: "platforms",
      verticalAlignment: "bottom",
      height: 292
    });
    vt(this, "_limit", 0);
    this.addComponent(
      pt.selectedCharacter === "girl" ? new bR() : new wR()
    ), this._limit = this.addComponent(new xm(2, 1e3, 0)).width, this._createPlatforms(), this._registerToSignal(tt.signals.moveScreen, this._move);
  }
  get character() {
    return this.components[0];
  }
  _move(e) {
    this.x = -e, this._deleteExpiredPlatforms(), this._createPlatforms();
  }
  _createPlatforms() {
    for (; this._limit + this.x <= W.screen.width + 1e3; ) {
      const e = Kn(1, 8), i = Kn(200, 1500), r = Kn(100, 200);
      this.addComponent(
        new xm(e, i, this._limit + r)
      ), this._limit += r + i;
    }
  }
  _deleteExpiredPlatforms() {
    for (; ; ) {
      const e = this.components[1];
      if (e.x + e.width + 100 < -this.x)
        e.destroy();
      else
        break;
    }
  }
}
class bm extends Kr {
  constructor() {
    super(...arguments);
    vt(this, "_cancelClickDebounce", null);
    vt(this, "_keepingClick", !1);
  }
  get _platforms() {
    return this.components[2];
  }
  async init() {
    pt.speed = pt.originalSpeed, pt.score = 0, this.alpha = 0, this.interactive = !0, this.addComponent(new mR()), this.addComponent(new gR()), this.addComponent(new AR()), await Promise.all([
      this.animate({
        from: { alpha: 0 },
        to: { alpha: 1 },
        duration: 1
      }),
      xu(tt.sounds.mainLoop, {
        toVolume: 0.3,
        fadeDuration: 0.5,
        loop: !0
      })
    ]), await this.delay(1), pt.started = !0;
  }
  _onClick() {
    if (!pt.started) return;
    if (!this._platforms.character.hasPressAndRelease) {
      this._platforms.character.jump();
      return;
    }
    this._keepingClick = !1;
    const { start: e, cancel: i } = wu(
      () => {
        this._keepingClick = !0, this._platforms.character.press();
      },
      () => {
      },
      300,
      0
    );
    this._cancelClickDebounce = i, e();
  }
  _onPointerUp() {
    var e;
    !pt.started || !this._platforms.character.hasPressAndRelease || ((e = this._cancelClickDebounce) == null || e.call(this), this._cancelClickDebounce = null, this._keepingClick ? this._platforms.character.release() : this._platforms.character.jump());
  }
}
const TR = [
  {
    name: "default",
    assets: [
      {
        alias: [
          "audio/sounds.json"
        ],
        src: [
          "audio/sounds-EgVUtQ.json"
        ],
        data: {
          tags: {}
        }
      },
      {
        alias: [
          "audio/sounds.mp3"
        ],
        src: [
          "audio/sounds-wkfo.mp3",
          "audio/sounds-nYlG.ogg"
        ],
        data: {
          tags: {}
        }
      },
      {
        alias: [
          "default"
        ],
        src: [
          "default-vbWOIQ@0.5x.png.json",
          "default-uhPi.png.json",
          "default-PxBCOQ.webp.json",
          "default-Hk_gWQ@0.5x.avif.json",
          "default-h9YFuA.avif.json",
          "default-ca-T0Q@0.5x.webp.json"
        ],
        data: {
          tags: {
            tps: !0
          }
        }
      }
    ]
  }
], SR = {
  bundles: TR
};
class ER extends Kr {
  constructor() {
    super(...arguments);
    vt(this, "_leaderboard", []);
  }
  async init() {
    const e = this.addComponent(
      new Qt({
        label: "game-over",
        text: "Game Over",
        fontFamily: W.loadingScene.fontFamily,
        fontSize: 48,
        textColor: W.loadingScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: -50 }
      })
    ), i = this.addComponent(
      new Qt({
        label: "score",
        text: `Your score is ${pt.score}`,
        fontFamily: W.loadingScene.fontFamily,
        fontSize: 28,
        textColor: W.loadingScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: 50 }
      })
    );
    if (await Promise.all([this.delay(2), this._saveAndGetLeaderboard()]), this._leaderboard.length === 0) {
      Pe(tt.signals.goToGame);
      return;
    }
    await Promise.all([
      e.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 1
      }),
      i.animate({ from: { alpha: 1 }, to: { alpha: 0 }, duration: 1 })
    ]), e.destroy(), i.destroy(), this._showLeaderboard(), await this.delay(2 + 0.5 * (this._leaderboard.length + 1)), Pe(tt.signals.goToGame);
  }
  _showLeaderboard() {
    const i = this.addComponent(
      new Je({
        label: "leaderboard",
        width: 549,
        height: 549,
        verticalAlignment: "center",
        horizontalAlignment: "center"
      })
    );
    let r = 0;
    r += i.addComponent(
      new Qt({
        label: "title",
        text: "Leaderboard",
        fontFamily: W.loadingScene.fontFamily,
        fontSize: 48,
        textColor: W.loadingScene.textColor,
        anchor: { x: 0.5, y: 0 },
        position: { x: 549 / 2, y: 0 },
        alpha: 0,
        animations: [
          {
            from: { alpha: 0 },
            to: { alpha: 1 },
            duration: 0.5
          }
        ]
      })
    ).height + 50, this._leaderboard.forEach((s, o) => {
      const a = s.id === sd() ? 16763904 : W.loadingScene.textColor;
      i.addComponent(
        new Qt({
          label: `player-${o}`,
          text: `${o + 1}. ${s.nickname}`,
          fontFamily: W.loadingScene.fontFamily,
          fontSize: 24,
          textColor: a,
          position: { x: 0, y: r },
          alpha: 0,
          animations: [
            {
              from: { alpha: 0 },
              to: { alpha: 1 },
              duration: 0.5,
              delay: 0.5 * (o + 1)
            }
          ]
        })
      ), r += i.addComponent(
        new Qt({
          label: `score-${o}`,
          text: s.score.toString(),
          fontFamily: W.loadingScene.fontFamily,
          fontSize: 24,
          textColor: a,
          anchor: { x: 1, y: 0 },
          position: { x: 549, y: r },
          alpha: 0,
          animations: [
            {
              from: { alpha: 0 },
              to: { alpha: 1 },
              duration: 0.5,
              delay: 0.5 * (o + 1)
            }
          ]
        })
      ).height + 20;
    });
  }
  async _saveAndGetLeaderboard() {
    if (!await cR(pt.score)) return [];
    this._leaderboard = await dR();
  }
}
const VR = (n) => {
  const t = new URLSearchParams(window.location.search ?? ""), e = Ss(
    W.signals.destroyLoadingScene,
    () => {
      ba(
        e.name,
        e.binding
      ), Rs(
        t.has("character") ? new bm() : new tS()
      );
    }
  ), i = Ss(tt.signals.goToIntro, () => {
    ba(i.name, i.binding), Rs(new fR());
  });
  Ss(tt.signals.goToGame, () => {
    uR(), Rs(new bm());
  }), Ss(tt.signals.gameOver, () => {
    Rs(new ER());
  }), W.gameName = "couples-run", W.assets.basePath = n.assetsBasePath, W.maxFPS = Number(t.get("maxFPS")) || 60, W.debug = !!t.get("debug"), W.assets.manifest = SR, W.assets.extra = [
    { alias: "Lobster", src: eS, data: { family: "Lobster" } },
    {
      alias: "PressStart2P",
      src: nS,
      data: { family: "PressStart2P" }
    }
  ], tt.creditsUrl = n.creditsUrl, tt.privacyPolicyUrl = n.privacyPolicyUrl, tt.fireBaseApiKey = n.fireBaseApiKey, tt.fireBaseAppId = n.fireBaseAppId, tt.fireBaseAuthDomain = n.fireBaseAuthDomain, tt.fireBaseMessagingSenderId = n.fireBaseMessagingSenderId, tt.fireBaseProjectId = n.fireBaseProjectId, tt.fireBaseStorageBucket = n.fireBaseStorageBucket, pt.selectedCharacter = t.get("character") === "boy" ? "boy" : "girl", UT();
};
export {
  mt as $,
  ve as A,
  jb as B,
  xe as C,
  K as D,
  tc as E,
  Gb as F,
  Yb as G,
  ft as H,
  Ie as I,
  Qb as J,
  Hb as K,
  Kb as L,
  Jb as M,
  Zb as N,
  Bt as O,
  Wt as P,
  tp as Q,
  Me as R,
  Bn as S,
  Ae as T,
  Tx as U,
  wp as V,
  ot as W,
  Di as X,
  eg as Y,
  vg as Z,
  zh as _,
  sg as a,
  Xa as a0,
  Iv as a1,
  dg as a2,
  fb as a3,
  Ap as a4,
  yb as a5,
  Hc as a6,
  hg as a7,
  qm as a8,
  En as a9,
  t1 as aa,
  Vm as ab,
  dp as ac,
  Bm as ad,
  tu as ae,
  nb as af,
  Ir as ag,
  Vx as ah,
  Jx as ai,
  Jt as aj,
  fp as ak,
  ix as al,
  Xl as am,
  pg as an,
  Rv as ao,
  VR as ap,
  oi as b,
  jt as c,
  Fh as d,
  Ig as e,
  X1 as f,
  Mt as g,
  kg as h,
  kv as i,
  qp as j,
  $h as k,
  Ks as l,
  Gv as m,
  Hi as n,
  Zh as o,
  Yt as p,
  Ab as q,
  Wp as r,
  Tp as s,
  Pr as t,
  gt as u,
  j1 as v,
  Dn as w,
  qc as x,
  zb as y,
  ra as z
};
